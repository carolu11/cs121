problem_id,link,solution,usernane_posted
1,https://leetcode.com/problems/two-sum/discuss/2361743/Python-Simple-Solution-oror-O(n)-Time-oror-O(n)-Space,"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        d = {}
        for i, j in enumerate(nums):
            r = target - j
            if r in d: return [d[r], i]
            d[j] = i
		
		# An Upvote will be encouraging",rajkumarerrakutti
2,https://leetcode.com/problems/add-two-numbers/discuss/1835217/Python3-DUMMY-CARRY-(-**-)-Explained,"class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        res = dummy = ListNode()
        carry = 0
        while l1 or l2:
            v1, v2 = 0, 0
            if l1: v1, l1 = l1.val, l1.next
            if l2: v2, l2 = l2.val, l2.next
            
            val = carry + v1 + v2
            res.next = ListNode(val%10)
            res, carry = res.next, val//10
            
        if carry:
            res.next = ListNode(carry)
            
        return dummy.next",artod
3,https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/742926/Simple-Explanation-or-Concise-or-Thinking-Process-and-Example,"class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """"""
        :type s: str
        :rtype: int abcabcbb
        """"""
        if len(s) == 0:
            return 0
        seen = {}
        left, right = 0, 0
        longest = 1
        while right < len(s):
            if s[right] in seen:
                left = max(left,seen[s[right]]+1)
            longest = max(longest, right - left + 1)
            seen[s[right]] = right
            right += 1
            print(left, right, longest)
        return longest",ivankatrump
4,https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/949705/Python3-two-pointer-greater9621-runtime-commented,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
	    # Get the lengths of both lists
        l1,l2 = len(nums1), len(nums2)
		# Determine the middle
        middle = (l1 + l2) / 2
		
		# EDGE CASE:
		# If we only have 1 value (e.g. [1], []), return nums1[0] if the length of
		# that list is greater than the length of l2, otherwise return nums2[1]
		if middle == 0.5: return float(nums1[0]) if l1 > l2 else float(nums2[0])

		# Initialize 2 pointers
        x =  y = 0
		# Initialize 2 values to store the previous and current value (in case of an even
		# amount of values, we need to average 2 values)
        cur = prev = 0
		# Determine the amount of loops we need. If the middle is even, loop that amount + 1:
		# eg: [1, 2, 3, 4, 5, 6]        6 values, middle = 3, loops = 3+1
		#            ^  ^ 
		#            |  +-- cur
		#            +----- prev
 		# If the middle is odd, loop that amount + 0.5
		# eg: [1, 2, 3, 4, 5]           5 values, middle = 2.5, loops = 2.5+0.5
		#            ^
        #            +--- cur
        loops = middle+1 if middle % 1 == 0 else middle+0.5

		# Walk forward the amount of loops
        for _ in range(int(loops)):
            # Store the value of cur in prev
			prev = cur
			# If the x pointer is equal to the amount of elements of nums1 (l1 == len(nums1))
            if x == l1:
			    # Store nums2[y] in cur, 'cause we hit the end of nums1
                cur =  nums2[y]
				# Move the y pointer one ahead
                y += 1
		    # If the y pointer is equal to the amount of elements of nums2 (l2 == len(nums2))
            elif y == l2:
			    # Store nums1[x] in cur, 'cause we hit the end of nums2
                cur =  nums1[x]
				# Move the x pointer one ahead
                x += 1
		    # If the value in nums1 is bigger than the value in nums2
            elif nums1[x] > nums2[y]:
			    # Store nums2[y] in cur, because it's the lowest value
                cur =  nums2[y]
				# Move the y pointer one ahead
                y += 1
			# If the value in nums2 is bigger than the value in nums1
            else:
				# Store nums1[x] in, because it's the lowest value
                cur =  nums1[x]
				# Move the x pointer one ahead
                x += 1
        
		# If middle is even
        if middle % 1 == 0.0:
			# Return the average of the cur + prev values (which will return a float)
            return (cur+prev)/2
		# If middle is odd
        else:
			# Return the cur value, as a float
            return float(cur)",tomhagen
5,https://leetcode.com/problems/longest-palindromic-substring/discuss/2156659/Python-Easy-O(1)-Space-approach,"class Solution:
    def longestPalindrome(self, s: str) -> str:
        n=len(s)
        def expand_pallindrome(i,j):            
            while 0<=i<=j<n and s[i]==s[j]:
                i-=1
                j+=1                            
            return (i+1, j)
        
        res=(0,0)
        for i in range(n):
            b1 = expand_pallindrome(i,i)
            b2 = expand_pallindrome(i,i+1)            
            res=max(res, b1, b2,key=lambda x: x[1]-x[0]+1) # find max based on the length of the pallindrome strings.
                    
        return s[res[0]:res[1]]",constantine786
6,https://leetcode.com/problems/zigzag-conversion/discuss/817306/Very-simple-and-intuitive-O(n)-python-solution-with-explanation,"class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
            
        row_arr = [""""] * numRows
        row_idx = 1
        going_up = True

        for ch in s:
            row_arr[row_idx-1] += ch
            if row_idx == numRows:
                going_up = False
            elif row_idx == 1:
                going_up = True
            
            if going_up:
                row_idx += 1
            else:
                row_idx -= 1
        
        return """".join(row_arr)",wmv3317
7,https://leetcode.com/problems/reverse-integer/discuss/1061403/Clean-pythonic-solution,"class Solution:
    def reverse(self, x: int) -> int:
        retval = int(str(abs(x))[::-1])
        
        if(retval.bit_length()>31):
            return 0
    
        if x<0:
            return -1*retval
        else:
            return retval",njain07
8,https://leetcode.com/problems/string-to-integer-atoi/discuss/1510014/Python-Simple-Solution-without-Strip-beats-95,"class Solution:
    def myAtoi(self, s: str) -> int:
     
        if not s:
            return 0
        sign = 1
        integer = 0
        i = 0
        while i < len(s) and s[i] == ' ':
            i+=1    #skipping leading white space
        if i < len(s) and (s[i] == '-' or s[i] == '+'):
            if s[i] == '-':
                sign = -1
            i+=1
        while(i < len(s) and s[i].isdigit()):
            integer = integer * 10 + int(s[i])
            i+=1
            
        integer = sign*integer
        ans = self.limit(integer)
        return ans
    
    def limit(self, num):
        if num > pow(2, 31) -1:
            return pow(2, 31) -1
        if num < -1*pow(2, 31):
            return -1*pow(2, 31)
        return num",emerald19
9,https://leetcode.com/problems/palindrome-number/discuss/2797115/Easy-Python-Solution-with-O(1)-space,"class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        
        res = 0
        temp = x
        
        while temp:
            temp, n = divmod(temp, 10)
            res = (res * 10) + n
                
        return res == x",tragob
10,https://leetcode.com/problems/regular-expression-matching/discuss/2383634/Fastest-Solution-Explained0ms100-O(n)time-complexity-O(n)space-complexity,"class Solution:
   def isMatch(self, s, p):
       n = len(s)
       m = len(p)
       dp = [[False for _ in range (m+1)] for _ in range (n+1)]
       dp[0][0] = True
       for c in range(1,m+1):
           if p[c-1] == '*' and c > 1:
               dp[0][c] = dp[0][c-2]
       for r in range(1,n+1):
           for c in range(1,m+1):
               if p[c-1] == s[r-1] or p[c-1] == '.':
                   dp[r][c] = dp[r-1][c-1]
               elif c > 1 and p[c-1] == '*':
                   if  p[c-2] =='.' or s[r-1]==p[c-2]:
                       dp[r][c] =dp[r][c-2] or dp[r-1][c]
                   else:
                       dp[r][c] = dp[r][c-2]
       return dp[n][m]",cucerdariancatalin
11,https://leetcode.com/problems/container-with-most-water/discuss/1915108/Python3-GREEDY-TWO-POINTERS-~(~)-Explained,"class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r, area = 0, len(height) - 1, 0
        while l < r:
            area = max(area, (r - l) * min(height[l], height[r]))
            if height[l] < height[r]:
				l += 1
            else:
				r -= 1
				
        return area",artod
12,https://leetcode.com/problems/integer-to-roman/discuss/2724200/Python's-Simple-and-Easy-to-Understand-Solution-or-99-Faster,"class Solution:
    def intToRoman(self, num: int) -> str:
        # Creating Dictionary for Lookup
        num_map = {
            1: ""I"",
            5: ""V"",    4: ""IV"",
            10: ""X"",   9: ""IX"",
            50: ""L"",   40: ""XL"",
            100: ""C"",  90: ""XC"",
            500: ""D"",  400: ""CD"",
            1000: ""M"", 900: ""CM"",
        }
        
        # Result Variable
        r = ''
        
        
        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:
            # If n in list then add the roman value to result variable
            while n <= num:
                r += num_map[n]
                num-=n
        return r",pniraj657
13,https://leetcode.com/problems/roman-to-integer/discuss/264743/Clean-Python-beats-99.78.,"class Solution:
    def romanToInt(self, s: str) -> int:
        translations = {
            ""I"": 1,
            ""V"": 5,
            ""X"": 10,
            ""L"": 50,
            ""C"": 100,
            ""D"": 500,
            ""M"": 1000
        }
        number = 0
        s = s.replace(""IV"", ""IIII"").replace(""IX"", ""VIIII"")
        s = s.replace(""XL"", ""XXXX"").replace(""XC"", ""LXXXX"")
        s = s.replace(""CD"", ""CCCC"").replace(""CM"", ""DCCCC"")
        for char in s:
            number += translations[char]
        return number",hgrsd
14,https://leetcode.com/problems/longest-common-prefix/discuss/1351149/Python-and-startswith,"class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        
        pre = strs[0]
        
        for i in strs:
            while not i.startswith(pre):
                pre = pre[:-1]
        
        return pre",lokeshsenthilkumar
102,https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/2790811/Python-solution,"class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        levels = []
        
        def order(node, level):
            if level >= len(levels):
                levels.append([])
            
            if node:
                levels[level].append(node.val)
            
                if node.left:
                    order(node.left, level + 1)
                
                if node.right:
                    order(node.right, level + 1)
        
        if not root:
            return []
        
        order(root, 0)
        return levels",maomao1010
103,https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/discuss/2098804/Python3-Clean-Solution-using-Queue-Level-Order-Traversal,"class Solution:
    def zigzagLevelOrder(self, root):
        
        res = []
        if not root: return res
        zigzag = True
        
        q = collections.deque()
        q.append(root)
        
        while q:
            n = len(q)
            nodesOfThisLevel = []
            
            for i in range(n):
                node = q.popleft()
                nodesOfThisLevel.append(node.val)
                
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
                    
            if zigzag:
                res.append(nodesOfThisLevel)
                zigzag = False
            else:
                res.append(nodesOfThisLevel[::-1])
                zigzag = True
        
        return res
    
# Time: O(N)
# Space: O(N)",samirpaul1
104,https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/1769367/Python3-RECURSIVE-DFS-(-**-)-Explained,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        def dfs(root, depth):
            if not root: return depth
            return max(dfs(root.left, depth + 1), dfs(root.right, depth + 1))
                       
        return dfs(root, 0)",artod
105,https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/689647/Python3-stack-O(N),"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        loc = {x : i for i, x in enumerate(inorder)}
        root = None
        stack = []
        for x in preorder: 
            if not root: root = node = TreeNode(x)
            elif loc[x] < loc[node.val]: 
                stack.append(node)
                node.left = node = TreeNode(x)
            else: 
                while stack and loc[stack[-1].val] < loc[x]: node = stack.pop() # backtracking
                node.right = node = TreeNode(x)
        return root",ye15
106,https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/2098606/Python3-O(n)-Time-O(1)-Space-Solution-faster-than-95,"class Solution:
    def buildTree(self, inorder, postorder):
        inorderIndexDict = {ch : i for i, ch in enumerate(inorder)}
        self.rootIndex = len(postorder) - 1
        
        def solve(l, r):
            if l > r: return None
            
            root = TreeNode(postorder[self.rootIndex]) 
            self.rootIndex -= 1
            
            i = inorderIndexDict[root.val]
            
            # As we a approaching from end and all right side nodes of i in inorder are
            # from right sub-tree so first call solve for right then left.
            root.right = solve(i+1, r)
            root.left =  solve(l, i-1)
            
            return root
        
        return solve(0, len(inorder)-1)
    
    
# Time: O(N)
# Space: O(1)",samirpaul1
107,https://leetcode.com/problems/binary-tree-level-order-traversal-ii/discuss/359962/Python-recursive-and-iterative,"class Solution:
    def helper(self, result, depth, node):
        if not node:
            return
        
        if len(result) < depth:
            result.append([])
            
        result[depth-1].append(node.val)
        self.helper(result, depth+1, node.left)
        self.helper(result, depth+1, node.right)
        
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        
        result = []
        depth = 1
        self.helper(result, depth, root)
        result.reverse()
        return result",amchoukir
108,https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/2428167/Easy-oror-0-ms-oror-100-oror-Fully-Explained-oror-(Java-C%2B%2B-Python-JS-C-Python3),"class Solution(object):
    def sortedArrayToBST(self, nums):
        # Base condition...
        if len(nums) == 0:
            return None
        # set the middle node...
        mid = len(nums)//2
        # Initialise root node with value same as nums[mid]
        root = TreeNode(nums[mid])
        # Assign left subtrees as the same function called on left subranges...
        root.left = self.sortedArrayToBST(nums[:mid])
        # Assign right subtrees as the same function called on right subranges...
        root.right = self.sortedArrayToBST(nums[mid+1:])
        # Return the root node...
        return root",PratikSen07
109,https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/discuss/2767308/Python-beats-86-(recursive-solution),"class Solution:
    l = 'left'
    r = 'right'
    
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        if not head: return None
        
        nums = []
        while head:
            nums.append(head.val)
            head = head.next
        
        mid = len(nums) // 2
        treeNode = TreeNode(nums[mid])
        
        self.binarySearchTree(nums[:mid], self.l, treeNode)
        self.binarySearchTree(nums[(mid + 1):], self.r, treeNode)
        
        return treeNode
            
            
    def binarySearchTree(self, nums, direction, treeNode):
        if len(nums) <= 0: return
        
        mid = len(nums) // 2
        left, right = nums[:mid], nums[(mid + 1):]
        
        if direction == self.l:
            treeNode.left = TreeNode(nums[mid])
            self.binarySearchTree(left, self.l, treeNode.left)
            self.binarySearchTree(right, self.r, treeNode.left)
        else:
            treeNode.right = TreeNode(nums[mid])
            self.binarySearchTree(left, self.l, treeNode.right)
            self.binarySearchTree(right, self.r, treeNode.right)",farruhzokirov00
110,https://leetcode.com/problems/balanced-binary-tree/discuss/2428871/Very-Easy-oror-100-oror-Fully-Explained-(C%2B%2B-Java-Python-JavaScript-Python3),"class Solution(object):
    def isBalanced(self, root):
        return (self.Height(root) >= 0)
    def Height(self, root):
        if root is None:  return 0
        leftheight, rightheight = self.Height(root.left), self.Height(root.right)
        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1
        return max(leftheight, rightheight) + 1",PratikSen07
111,https://leetcode.com/problems/minimum-depth-of-binary-tree/discuss/2429057/Very-Easy-oror-100-oror-Fully-Explained-(C%2B%2B-Java-Python-JS-C-Python3),"class Solution(object):
    def minDepth(self, root):
        # Base case...
        # If the subtree is empty i.e. root is NULL, return depth as 0...
        if root is None:  return 0
        # Initialize the depth of two subtrees...
        leftDepth = self.minDepth(root.left)
        rightDepth = self.minDepth(root.right)
        # If the both subtrees are empty...
        if root.left is None and root.right is None:
            return 1
        # If the left subtree is empty, return the depth of right subtree after adding 1 to it...
        if root.left is None:
            return 1 + rightDepth
        # If the right subtree is empty, return the depth of left subtree after adding 1 to it...
        if root.right is None:
            return 1 + leftDepth
        # When the two child function return its depth...
        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...
        return min(leftDepth, rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees...",PratikSen07
112,https://leetcode.com/problems/path-sum/discuss/2658792/Python-Elegant-and-Short-or-DFS,"class Solution:
    """"""
    Time:   O(n)
    Memory: O(n)
    """"""

    def hasPathSum(self, root: Optional[TreeNode], target: int) -> bool:
        if root is None:
            return False
        if root.left is None and root.right is None:
            return target == root.val
        return self.hasPathSum( root.left, target - root.val) or \
               self.hasPathSum(root.right, target - root.val)",Kyrylo-Ktl
113,https://leetcode.com/problems/path-sum-ii/discuss/484120/Python-3-(beats-~100)-(nine-lines)-(DFS),"class Solution:
    def pathSum(self, R: TreeNode, S: int) -> List[List[int]]:
        A, P = [], []
        def dfs(N):
            if N == None: return
            P.append(N.val)
            if (N.left,N.right) == (None,None) and sum(P) == S: A.append(list(P))
            else: dfs(N.left), dfs(N.right)
            P.pop()
        dfs(R)
        return A
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
114,https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/2340445/Python-or-intuitive-explained-or-O(1)-space-ignoring-recursion-stack-or-O(n)-time,"class Solution:
    def __init__(self):
        self.prev = None
        
    def flatten(self, root: Optional[TreeNode]) -> None:
        
        if not root: return 
        self.flatten(root.right)
        self.flatten(root.left)
        root.right = self.prev
        root.left = None
        self.prev = root",mync
115,https://leetcode.com/problems/distinct-subsequences/discuss/1472969/Python-Bottom-up-DP-Explained,"class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m = len(s)
        n = len(t)
        dp = [[0] * (n+1) for _ in range(m+1)]
        
        for i in range(m+1):
            dp[i][0] = 1
        
        """"""redundant, as we have initialised dp table with full of zeros""""""
#         for i in range(1, n+1): 
#             dp[0][i] = 0
        
        for i in range(1, m+1):
            for j in range(1, n+1):
                dp[i][j] += dp[i-1][j] 			#if current character is skipped
                if s[i-1] == t[j-1]:
                    dp[i][j] += dp[i-1][j-1]	#if current character is used
        
        return dp[-1][-1]",ajith6198
116,https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/719347/Python-Solution-O(1)-and-O(n)-memory.,"class Solution:
    def connect(self, root: 'Node') -> 'Node':
        # edge case check
        if not root:
            return None
        
        # initialize the queue with root node (for level order traversal)
        queue = collections.deque([root])
        
        # start the traversal
        while queue:
            size = len(queue) # get number of nodes on the current level
            for i in range(size):
                node = queue.popleft() # pop the node
                
                # An important check so that we do not wire the node to the node on the next level.
                if i < size-1:
                    node.next = queue[0] # because the right node of the popped node would be the next in the queue. 
                    
                if node.left:
                    queue.append(node.left) 
                if node.right:
                    queue.append(node.right)           
                
        return root",darshan_22
117,https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/discuss/2033286/Python-Easy%3A-BFS-and-O(1)-Space-with-Explanation,"class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None
        q = deque()
        q.append(root)
        dummy=Node(-999) # to initialize with a not null prev
        while q:
            length=len(q) # find level length
            
            prev=dummy
            for _ in range(length): # iterate through all nodes in the same level
                popped=q.popleft()
                if popped.left:
                    q.append(popped.left)
                    prev.next=popped.left
                    prev=prev.next
                if popped.right:
                    q.append(popped.right)
                    prev.next=popped.right
                    prev=prev.next                
                 
        return root",constantine786
118,https://leetcode.com/problems/pascals-triangle/discuss/1490520/Python3-easy-code-faster-than-96.67,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        l=[0]*numRows
        for i in range(numRows):
            l[i]=[0]*(i+1)
            l[i][0]=1
            l[i][i]=1
            for j in range(1,i):
                l[i][j]=l[i-1][j-1]+l[i-1][j]
        return l",Rosh_65
119,https://leetcode.com/problems/pascals-triangle-ii/discuss/467945/Pythonic-O(-k-)-space-sol.-based-on-math-formula-90%2B,"class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        
        if rowIndex == 0:
            # Base case
            return [1]
        
        elif rowIndex == 1:
            # Base case
            return [1, 1]
        
        else:
            # General case:
            last_row = self.getRow( rowIndex-1 )
            size = len(last_row)
            return [ last_row[0] ] + [ last_row[idx] + last_row[idx+1] for idx in range( size-1) ] + [ last_row[-1] ]",brianchiang_tw
120,https://leetcode.com/problems/triangle/discuss/2144882/Python-In-place-DP-with-Explanation,"class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for i in range(1, len(triangle)):  # for each row in triangle (skipping the first),
            for j in range(i+1):           # loop through each element in the row
                triangle[i][j] += min(triangle[i-1][j-(j==i)],  # minimum sum from coordinate (x-1, y)
                                      triangle[i-1][j-(j>0)])   # minimum sum from coordinate (x-1, y-1)
        return min(triangle[-1])  # obtain minimum sum from last row",zayne-siew
121,https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/1545423/Python-easy-to-understand-solution-with-explanation-%3A-Tracking-and-Dynamic-programming,"class Solution(object):
    def maxProfit(self, prices):
        n = len(prices)
        dp = [0]*n # initializing the dp table
        dp[0] = [prices[0],0] # filling the the first dp table --> low_price = prices[0] max_profit=0
        min_price = max_profit = 0
        # Note that ---> indixing the dp table --> dp[i-1][0] stores minimum price and dp[i-1][1] stores maximum profit
        for i in range(1,n):
            min_price = min(dp[i-1][0], prices[i]) # min(previous_min_price, cur_min_price)
            max_profit = max(dp[i-1][1], prices[i]-dp[i-1][0]) # max(previoius_max_profit, current_profit)
            dp[i] =[min_price,max_profit]
                
        return dp[n-1][1]
		#Runtime: 1220 ms, 
		#Memory Usage: 32.4 MB,",Abeni
122,https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/2040292/O(n)timeBEATS-99.97-MEMORYSPEED-0ms-MAY-2022,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        @cache
        def trade(day_d):
            
            if day_d == 0:
                
                # Hold on day_#0 = buy stock at the price of day_#0
                # Not-hold on day_#0 = doing nothing on day_#0
                return -prices[day_d], 0
            
            prev_hold, prev_not_hold = trade(day_d-1)
            
            hold = max(prev_hold, prev_not_hold - prices[day_d] )
            not_hold = max(prev_not_hold, prev_hold + prices[day_d] )
            
            return hold, not_hold
        
        # --------------------------------------------------
        last_day= len(prices)-1
        
        # Max profit must come from not_hold state (i.e., no stock position) on last day
        return trade(last_day)[1]",cucerdariancatalin
123,https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/2040316/O(n)timeBEATS-99.97-MEMORYSPEED-0ms-MAY-2022,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy, sell = [inf]*2, [0]*2
        for x in prices:
            for i in range(2): 
                if i: buy[i] = min(buy[i], x - sell[i-1])
                else: buy[i] = min(buy[i], x)
                sell[i] = max(sell[i], x - buy[i])
        return sell[1]",cucerdariancatalin
124,https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/2040330/O(n)timeBEATS-99.97-MEMORYSPEED-0ms-MAY-2022,"class Solution:
    def __init__(self):
        self.maxSum = float('-inf')
    def maxPathSum(self, root: TreeNode) -> int:
        def traverse(root):
            if root:
                left = traverse(root.left)
                right = traverse(root.right)
                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)
                return max(root.val,root.val + left,root.val + right)
            else:
                return 0
        traverse(root)
        return self.maxSum",cucerdariancatalin
125,https://leetcode.com/problems/valid-palindrome/discuss/350929/Solution-in-Python-3-(beats-~100)-(two-lines)-(-O(1)-solution-as-well-),"class Solution:
    def isPalindrome(self, s: str) -> bool:
    	s = [i for i in s.lower() if i.isalnum()]
    	return s == s[::-1]",junaidmansuri
126,https://leetcode.com/problems/word-ladder-ii/discuss/2422401/46ms-Python-97-Faster-Working-Multiple-solutions-95-memory-efficient-solution,"class Solution:
		def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
			d = defaultdict(list)
			for word in wordList:
				for i in range(len(word)):
					d[word[:i]+""*""+word[i+1:]].append(word)

			if endWord not in wordList:
				return []

			visited1 = defaultdict(list)
			q1 = deque([beginWord])
			visited1[beginWord] = []

			visited2 = defaultdict(list)
			q2 = deque([endWord])
			visited2[endWord] = []

			ans = []
			def dfs(v, visited, path, paths):
				path.append(v)
				if not visited[v]:
					if visited is visited1:
						paths.append(path[::-1])
					else:
						paths.append(path[:])
				for u in visited[v]:
					dfs(u, visited, path, paths)
				path.pop()

			def bfs(q, visited1, visited2, frombegin):
				level_visited = defaultdict(list)
				for _ in range(len(q)):
					u = q.popleft()

					for i in range(len(u)):
						for v in d[u[:i]+""*""+u[i+1:]]:
							if v in visited2:
								paths1 = []
								paths2 = []
								dfs(u, visited1, [], paths1)
								dfs(v, visited2, [], paths2)
								if not frombegin:
									paths1, paths2 = paths2, paths1
								for a in paths1:
									for b in paths2:
										ans.append(a+b)
							elif v not in visited1:
								if v not in level_visited:
									q.append(v)
								level_visited[v].append(u)
				visited1.update(level_visited)

			while q1 and q2 and not ans:
				if len(q1) <= len(q2):
					bfs(q1, visited1, visited2, True)
				else:
					bfs(q2, visited2, visited1, False)

			return ans",anuvabtest
127,https://leetcode.com/problems/word-ladder/discuss/1332551/Elegant-Python-Iterative-BFS,"class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):

        graph = defaultdict(list)
        for word in wordList:
            for index in range(len(beginWord)):
                graph[word[:index] + ""_"" + word[index+1:]].append(word)

        queue = deque()
        queue.append((beginWord, 1))
        visited = set()
        while queue:
            current_node, current_level = queue.popleft()
            if current_node == endWord: return current_level
            for index in range(len(beginWord)):
                node = current_node[:index] + ""_"" + current_node[index+1:]
                for neighbour in graph[node]:
                    if neighbour not in visited:
                        queue.append((neighbour, current_level + 1))
                        visited.add(neighbour)
                graph[node] = []
                
        return 0",soma28
128,https://leetcode.com/problems/longest-consecutive-sequence/discuss/1109808/Python-Clean-Union-Find-with-explanation,"class Node:
    def __init__(self, val):
        self.val = val
        self.parent = self
        self.size = 1
    
class UnionFind:
        
    def find(self, node):
        if node.parent != node:
            node.parent = self.find(node.parent)
        return node.parent
    
    def union(self, node1, node2):
        parent_1 = self.find(node1)
        parent_2 = self.find(node2)
        if parent_1 != parent_2:
            parent_2.parent = parent_1
            parent_1.size += parent_2.size
        return parent_1.size
                
        
        
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        uf = UnionFind()
        nodes = {}
        max_size = 0
        for num in nums:
            if num not in nodes:
                node = Node(num)
                nodes[num] = node
                size = 1
                if num + 1 in nodes:
                    size = uf.union(node, nodes[num+1])
                if num - 1 in nodes:
                    size = uf.union(node, nodes[num-1])
                max_size = max(max_size, size)
                
        return max_size
		```",l3arner
129,https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/1557540/Python-99-speed-99-memory,"class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        def helper(node, num):
            if node is None:
                return 0
            num = num * 10 + node.val
            if node.left is None and node.right is None:
                return num
            return helper(node.left, num) + helper(node.right, num)
        
        return helper(root, 0)",dereky4
130,https://leetcode.com/problems/surrounded-regions/discuss/558746/Python-DFS-Easy-solution-with-comments,"class Solution:
    
    def dfs(self,board,i,j):
            
        if i<0 or j<0 or i>=len(board) or j>=len(board[0]) or board[i][j]!='O':
            return
        board[i][j]='$'  # converting to  a dollar sign 
            
        self.dfs(board,i+1,j)
        self.dfs(board,i-1,j)
        self.dfs(board,i,j+1)
        self.dfs(board,i,j-1)
        
    def solve(self, board: List[List[str]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        if len(board)==0:
            return None
        
        m=len(board)
        n=len(board[0])
        
        
        for i in range(m):  # call dfs on all border 'O's and turn them to '$'
            for j in range(n):
                if i==0 or i==m-1:
                    self.dfs(board,i,j)
                        
                if j==0 or j==n-1:
                    self.dfs(board,i,j)
                    
        
   
#all border O and others connected them were already converted to $ sign 
#so left out zeros are surely surrounded by 'X' . Turn all of them to 'X'
        for i in range(m):   
            for j in range(n):
                if board[i][j]=='O':
                    board[i][j]='X'
        
# turn the border zeros and their adjacents to their initial form. ie $ -> O 
        for i in range(m):
            for j in range(n):
                if board[i][j]=='$':
                    board[i][j]='O'",JoyRafatAshraf
131,https://leetcode.com/problems/palindrome-partitioning/discuss/1667786/Python-Simple-Recursion-oror-Detailed-Explanation-oror-Easy-to-Understand,"class Solution(object):
    @cache  # the memory trick can save some time
    def partition(self, s):
        if not s: return [[]]
        ans = []
        for i in range(1, len(s) + 1):
            if s[:i] == s[:i][::-1]:  # prefix is a palindrome
                for suf in self.partition(s[i:]):  # process suffix recursively
                    ans.append([s[:i]] + suf)
        return ans",linfq
132,https://leetcode.com/problems/palindrome-partitioning-ii/discuss/713271/Python3-dp-(top-down-and-bottom-up),"class Solution:
    def minCut(self, s: str) -> int:
        #pre-processing
        palin = dict()
        for k in range(len(s)):
            for i, j in (k, k), (k, k+1):
                while 0 <= i and j < len(s) and s[i] == s[j]: 
                    palin.setdefault(i, []).append(j)
                    i, j = i-1, j+1
                
        #dp 
        @lru_cache(None)
        def fn(i):
            """"""Return minimum palindrome partitioning of s[i:]""""""
            if i == len(s): return 0
            return min(1 + fn(ii+1) for ii in palin[i])
        
        return fn(0)-1",ye15
133,https://leetcode.com/problems/clone-graph/discuss/1792858/Python3-ITERATIVE-BFS-(beats-98)-'less()greater''-Explained,"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node: return node
        
        q, clones = deque([node]), {node.val: Node(node.val, [])}
        while q:
            cur = q.popleft() 
            cur_clone = clones[cur.val]            

            for ngbr in cur.neighbors:
                if ngbr.val not in clones:
                    clones[ngbr.val] = Node(ngbr.val, [])
                    q.append(ngbr)
                    
                cur_clone.neighbors.append(clones[ngbr.val])
                
        return clones[node.val]",artod
134,https://leetcode.com/problems/gas-station/discuss/1276287/Simple-one-pass-python-solution,"class Solution:
	def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
		
		# base case
		if sum(gas) - sum(cost) < 0:
			return -1

		gas_tank = 0  # gas available in car till now
		start_index = 0  # Consider first gas station as starting point

		for i in range(len(gas)):

			gas_tank += gas[i] - cost[i]

			if gas_tank < 0:  # the car has deficit of petrol
				start_index = i+1  # change the starting point
				gas_tank = 0  # make the current gas to 0, as we will be starting again from next station

		return start_index",nandanabhishek
135,https://leetcode.com/problems/candy/discuss/2234828/Python-oror-Two-pass-oror-explanation-oror-intuition-oror-greedy,"class Solution:
    def candy(self, ratings: List[int]) -> int:
        n=len(ratings)
        temp = [1]*n
        
        for i in range(1,n):
            if(ratings[i]>ratings[i-1]):
                temp[i]=temp[i-1]+1
        if(n>1):
            if(ratings[0]>ratings[1]):
                temp[0]=2
                
            
        for i in range(n-2,-1,-1):
            if(ratings[i]>ratings[i+1] and temp[i]<=temp[i+1]):
                temp[i]=temp[i+1]+1

                
        return sum(temp)",palashbajpai214
136,https://leetcode.com/problems/single-number/discuss/2438883/Very-Easy-oror-0-ms-oror100oror-Fully-Explained-(Java-C%2B%2B-Python-JS-C-Python3),"class Solution(object):
    def singleNumber(self, nums):
        # Initialize the unique number...
        uniqNum = 0;
        # TRaverse all elements through the loop...
        for idx in nums:
            # Concept of XOR...
            uniqNum ^= idx;
        return uniqNum;       # Return the unique number...",PratikSen07
137,https://leetcode.com/problems/single-number-ii/discuss/1110333/3-python-solutions-with-different-approaches,"class Solution(object):
    def singleNumber(self, nums):
        a, b = 0, 0
        for x in nums:
            a, b = (~x&amp;a&amp;~b)|(x&amp;~a&amp;b), ~a&amp;(x^b)
        return b",mritunjoyhalder79
138,https://leetcode.com/problems/copy-list-with-random-pointer/discuss/1841010/Python3-JUST-TWO-STEPS-()-Explained,"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        hm, zero = dict(), Node(0)
        
        cur, copy = head, zero
        while cur:
            copy.next = Node(cur.val)
            hm[cur] = copy.next
            cur, copy = cur.next, copy.next
            
        cur, copy = head, zero.next
        while cur:
            copy.random = hm[cur.random] if cur.random else None
            cur, copy = cur.next, copy.next
                
        return zero.next",artod
139,https://leetcode.com/problems/word-break/discuss/748479/Python3-Solution-with-a-Detailed-Explanation-Word-Break,"class Solution:
    def wordBreak(self, s, wordDict):
		dp = [False]*(len(s)+1)
        dp[0] = True
        
        for i in range(1, len(s)+1):
            for j in range(i):
                if dp[j] and s[j:i] in wordDict:
					dp[i] = True
                    break
                    
        return dp[-1]",peyman_np
140,https://leetcode.com/problems/word-break-ii/discuss/744674/Diagrammatic-Python-Intuitive-Solution-with-Example,"class Solution(object):
    def wordBreak(self, s, wordDict):
        """"""
        :type s: str
        :type wordDict: List[str]
        :rtype: List[str]
        """"""
        def wordsEndingIn(i):
            if i == len(s):
                return [""""]
            ans = []
            for j in range(i+1, len(s)+1):
                if s[i:j] in wordDict:
                    for tail in wordsEndingIn(j):
                        if tail != '':
                            ans.append(s[i:j] + "" "" + tail) 
                        else:
                            ans.append(s[i:j])
            return ans
        return wordsEndingIn(0)",ivankatrump
141,https://leetcode.com/problems/linked-list-cycle/discuss/1047819/Easy-in-Pythonor-O(1)-or-Beats-91,"class Solution(object):
    def hasCycle(self, head):
        """"""
        :type head: ListNode
        :rtype: bool
        """"""
		if head is None or head.next is None return False
        slow_ref = head
        fast_ref = head
        while fast_ref and fast_ref.next:
            slow_ref = slow_ref.next
            fast_ref = fast_ref.next.next
            if slow_ref == fast_ref:
                return True
        return False
		
	If you get it please Upvote.",vsahoo
142,https://leetcode.com/problems/linked-list-cycle-ii/discuss/2184711/O(1)-Space-Python-solution-with-clear-explanation-faster-than-90-solutions,"class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast, slow = head, head
        while(fast and fast.next):
            fast = fast.next.next
            slow = slow.next
            if(fast == slow):
                slow = head
                while(slow is not fast):
                    fast = fast.next
                    slow = slow.next
                return slow
        return None",saiamrit
143,https://leetcode.com/problems/reorder-list/discuss/1640529/Python3-ONE-PASS-L(o)-Explained,"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        if not head.next or not head.next.next:
            return
        
        # search for the middle
        slow, fast = head, head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next

        tail, cur = None, slow.next
        slow.next = None # detach list on the middle
        
        # reverse right part
        while cur:
            cur.next, tail, cur = tail, cur, cur.next
        
		# rearrange nodes as asked
        headCur, headNext = head, head.next
        tailCur, tailNext = tail, tail.next
        while True:
            headCur.next, tailCur.next = tailCur, headNext
             
            if not tailNext:
                return
            
            tailCur, headCur = tailNext, headNext
            tailNext, headNext = tailNext.next, headNext.next",artod
144,https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/1403244/3-Simple-Python-solutions,"class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        stack = [root]
        
        while stack:
            temp = stack.pop()
            
            if temp:
                ans.append(temp.val)
                stack.append(temp.right) #as we are using stack which works on LIFO, we need to push right tree first so that left will be popped out
                stack.append(temp.left)
                
        return ans",shraddhapp
145,https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/2443702/Easy-oror-Recursive-and-Iterative-oror-100-oror-Explained-(Java-C%2B%2B-Python-Python3),"class Solution(object):
    def postorderTraversal(self, root):
        # Base case...
        if not root: return []
        # Create an array list to store the solution result...
        sol = []
        # Create an empty stack and push the root node...
        bag = [root]
        # Loop till stack is empty...
        while bag:
            # Pop a node from the stack...
            node = bag.pop()
            sol.append(node.val)
            # Push the left child of the popped node into the stack...
            if node.left:
                bag.append(node.left)
            # Append the right child of the popped node into the stack...
            if node.right:
                bag.append(node.right)
        return sol[::-1]       # Return the solution list...",PratikSen07
146,https://leetcode.com/problems/lru-cache/discuss/442751/Python3-hashmap-and-doubly-linked-list,"class ListNode:
    def __init__(self, key=0, val=0, prev=None, next=None):
        self.key = key
        self.val = val
        self.prev = prev
        self.next = next
        

class LRUCache:

    def __init__(self, capacity: int):
        """"""Initialize hash table &amp; dll""""""
        self.cpty = capacity
        self.htab = dict() #hash table 
        self.head = ListNode() #doubly linked list
        self.tail = ListNode()
        self.head.next = self.tail
        self.tail.prev = self.head 
        
    def _del(self, key: int) -> int: 
        """"""Delete given key from hash table &amp; dll""""""
        node = self.htab.pop(key)
        node.prev.next = node.next
        node.next.prev = node.prev
        return node.val

    def _ins(self, key: int, value: int) -> None: 
        """"""Insert at tail""""""
        node = ListNode(key, value, self.tail.prev, self.tail)
        self.tail.prev.next = self.tail.prev = node
        self.htab[key] = node
        
    def get(self, key: int) -> int:
        if key not in self.htab: return -1
        value = self._del(key)
        self._ins(key, value)
        return value

    def put(self, key: int, value: int) -> None:
        if key in self.htab: self._del(key)
        self._ins(key, value)
        if len(self.htab) > self.cpty: 
            self._del(self.head.next.key)


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)",ye15
147,https://leetcode.com/problems/insertion-sort-list/discuss/1176552/Python3-188ms-Solution-(explanation-with-visualization),"class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        
        # No need to sort for empty list or list of size 1
        if not head or not head.next:
            return head
        
        # Use dummy_head will help us to handle insertion before head easily
        dummy_head = ListNode(val=-5000, next=head)
        last_sorted = head # last node of the sorted part
        cur = head.next # cur is always the next node of last_sorted
        while cur:
            if cur.val >= last_sorted.val:
                last_sorted = last_sorted.next
            else:
                # Search for the position to insert
                prev = dummy_head
                while prev.next.val <= cur.val:
                    prev = prev.next
                    
                # Insert
                last_sorted.next = cur.next
                cur.next = prev.next
                prev.next = cur
                
            cur = last_sorted.next
            
        return dummy_head.next",EckoTan0804
148,https://leetcode.com/problems/sort-list/discuss/1796085/Sort-List-or-Python-O(nlogn)-Solution-or-95-Faster,"class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        # Split the list into two halfs
        left = head
        right = self.getMid(head)
        tmp = right.next
        right.next = None
        right = tmp
        
        left = self.sortList(left)
        right = self.sortList(right)
        
        return self.merge(left, right)
    
    def getMid(self, head):
        slow = head
        fast = head.next
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
    
    # Merge the list
    def merge(self, list1, list2):
        newHead = tail = ListNode()
        while list1 and list2:
            if list1.val > list2.val:
                tail.next = list2
                list2 = list2.next
            else:
                tail.next = list1
                list1 = list1.next
            tail = tail.next
        
        if list1:
            tail.next = list1
        if list2:
            tail.next = list2
        
        return newHead.next",pniraj657
149,https://leetcode.com/problems/max-points-on-a-line/discuss/1983010/Python-3-Using-Slopes-and-Hash-Tables-or-Clean-Python-solution,"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        if len(points) <= 2:
            return len(points)
        
        def find_slope(p1, p2):
            x1, y1 = p1
            x2, y2 = p2
            if x1-x2 == 0:
                return inf
            return (y1-y2)/(x1-x2)
        
        ans = 1
        for i, p1 in enumerate(points):
            slopes = defaultdict(int)
            for j, p2 in enumerate(points[i+1:]):
                slope = find_slope(p1, p2)
                slopes[slope] += 1
                ans = max(slopes[slope], ans)
        return ans+1",hari19041
150,https://leetcode.com/problems/evaluate-reverse-polish-notation/discuss/1732651/Super-Simple-Python-stack-solution,"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        
        def update(sign):
            n2,n1=stack.pop(),stack.pop()
            if sign==""+"": return n1+n2
            if sign==""-"": return n1-n2
            if sign==""*"": return n1*n2
            if sign==""/"": return int(n1/n2)
			
        stack=[]
        
        for n in tokens:
            if n.isdigit() or len(n)>1:
                stack.append(int(n))
            else:
                stack.append(update(n))
        return stack.pop()",InjySarhan
151,https://leetcode.com/problems/reverse-words-in-a-string/discuss/1632928/Intuitive-Two-Pointers-in-Python-without-strip()-or-split(),"class Solution:
    def reverseWords(self, s: str) -> str:
        #Time: O(n) since we scan through the input, where n = len(s)
        #Space: O(n)
        words = []
        slow, fast = 0, 0
        
        #Use the first char to determine if we're starting on a "" "" or a word
        mode = 'blank' if s[0] == ' ' else 'word'
        
        while fast < len(s):
            #If we start on a word and our fast ptr lands on a white space
            #means that we have singled out a word
            if mode == 'word' and s[fast] == ' ':
                words.append(s[slow:fast])
                slow = fast #Make the slow ptr catch up
                mode = 'blank'
                
            #If we start on a white space and our fast ptr runs into a character
            #means we are at the start of a word   
            elif mode == 'blank' and s[fast] != ' ':
                slow = fast #Make the slow ptr catch up
                mode = 'word'
        
            fast += 1 #Increment the fast pointer
        
        #Append the last word
        #Edge cases where the last chunk of string are white spaces
        if (lastWord := s[slow:fast]).isalnum():
            words.append(lastWord)
        
        return ' '.join(words[::-1])",surin_lovejoy
152,https://leetcode.com/problems/maximum-product-subarray/discuss/1608907/Python3-DYNAMIC-PROGRAMMING-Explained,"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        curMax, curMin = 1, 1
        res = nums[0]
        
        for n in nums:
            vals = (n, n * curMax, n * curMin)
            curMax, curMin = max(vals), min(vals)
			
            res = max(res, curMax)
            
        return res",artod
153,https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/2211586/Python3-simple-naive-solution-with-binary-search,"class Solution:
    def findMin(self, nums: List[int]) -> int:
        start = 0
        end = len(nums) - 1
        
        if(nums[start] <= nums[end]):
            return nums[0]
        
        while start <= end:
            mid = (start + end) // 2
            
            if(nums[mid] > nums[mid+1]):
                return nums[mid+1]
            
            if(nums[mid-1] > nums[mid]):
                return nums[mid]
            
            if(nums[mid] > nums[0]):
                start = mid + 1
            else:
                end = mid - 1
                
        return nums[start]",Dark_wolf_jss
154,https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/2087295/Binary-Search-oror-Explained-oror-PYTHON,"class Solution:
    def findMin(self, a: List[int]) -> int:
        
        def solve(l,h):
            while l<h:
                m=(l+h)//2
                
                if a[m]<a[m-1]:
                    return a[m]
                
                elif a[m]>a[h-1]:
                    l=m+1
                
                elif a[m]<a[h-1]:
                    h=m
                
                else:
                
                    if len(set(a[l:m+1]))==1:
                        return min(a[m],solve(m+1,h))
                    
                    else:
                        return min(a[m],solve(l,m))
            
            return a[min(l,len(a)-1)]
        
        return solve(0,len(a))",karan_8082
155,https://leetcode.com/problems/min-stack/discuss/825972/Python-3-greater-91-faster-using-namedtuple,"class MinStack:

    stackWithMinElements = collections.namedtuple(""stackWithMinElements"", (""element"", ""minimum""))
    
    def __init__(self):        
        self.stack : List[self.stackWithMinElements] = []

    def push(self, x: int) -> None:
        self.stack.append(self.stackWithMinElements(
                        x, min(x, self.getMin()) if len(self.stack)>0 else x))

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1].element

    def getMin(self) -> int:
        return self.stack[-1].minimum",mybuddy29
160,https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/2116127/Python-oror-Easy-2-approaches-oror-O(1)-space,"class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        first_set=set()
        curr=headA
        
        while curr:
            first_set.add(curr)
            curr=curr.next
        
        curr = headB
        while curr:
            if curr in first_set:
                return curr
            curr=curr.next

        return None",constantine786
162,https://leetcode.com/problems/find-peak-element/discuss/1440424/Python-oror-Easy-Solution,"class Solution:
	def findPeakElement(self, lst: List[int]) -> int:
		start, end = 0, len(lst) - 1

		while start < end:

			mid = start + (end - start) // 2

			if lst[mid] > lst[mid + 1]:
				end = mid
			else:
				start = mid + 1

		return start",naveenrathore
164,https://leetcode.com/problems/maximum-gap/discuss/727709/Python3-group-data-into-buckets,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0 #edge case 
        mn, mx = min(nums), max(nums)
        step = max(1, (mx - mn)//(len(nums)-1)) #n-1 holes 
        size = (mx - mn)//step + 1
        buckets = [[inf, -inf] for _ in range(size)]
        
        for num in nums: 
            i = (num - mn)//step
            x, xx = buckets[i]
            buckets[i] = min(x, num), max(xx, num)
        
        ans = 0
        prev = mn
        for i in range(size):
            x, xx = buckets[i]
            if x < inf:
                ans = max(ans, x - prev)
                prev = xx 
        return ans",ye15
165,https://leetcode.com/problems/compare-version-numbers/discuss/1797594/Python3-SOLUTION-Explained,"class Solution:
    def compareVersion(self, v1: str, v2: str) -> int:
        v1, v2 = list(map(int, v1.split('.'))), list(map(int, v2.split('.')))  
        for rev1, rev2 in zip_longest(v1, v2, fillvalue=0):
            if rev1 == rev2:
                continue

            return -1 if rev1 < rev2 else 1 

        return 0",artod
166,https://leetcode.com/problems/fraction-to-recurring-decimal/discuss/998707/Python-solution-with-detail-explanation,"class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        
        if numerator % denominator == 0: 
			return str(numerator // denominator)
        
        prefix = ''
        if (numerator > 0) != (denominator > 0):
            prefix = '-'
        
        # Operation must be on positive values
        if numerator < 0:
            numerator = - numerator
        if denominator < 0:
            denominator = - denominator

        digit, remainder = divmod(numerator, denominator)
            
        res = prefix + str(digit) + '.' # EVERYTHING BEFORE DECIMAL
        
        table = {}
        suffix = ''
        
        while remainder not in table.keys():
            
            # Store index of the reminder in the table
            table[remainder] = len(suffix)
            
            val, remainder = divmod(remainder*10, denominator)
            
            suffix += str(val)
            
            # No repeating
            if remainder == 0:
                return res + suffix
        
        indexOfRepeatingPart = table[remainder]
        
        decimalTillRepeatingPart = suffix[:indexOfRepeatingPart]
        
        repeatingPart = suffix[indexOfRepeatingPart:]

        return res + decimalTillRepeatingPart + '(' + repeatingPart + ')'

s = Solution()

print(s.fractionToDecimal(2, 3))",imasterleet
167,https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/discuss/2128459/Python-Easy-O(1)-Space,"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        i = 0
        j = len(numbers) -1
        
        while i<j:
            s = numbers[i] + numbers[j]
            if s == target:
                return [i + 1 , j + 1]
            
            if s > target:
                j-=1
            else:
               i+=1 
        
        return []",constantine786
168,https://leetcode.com/problems/excel-sheet-column-title/discuss/2448578/Easy-oror-0-ms-oror-100-oror-Fully-Explained-(Java-C%2B%2B-Python-Python3),"class Solution(object):
    def convertToTitle(self, columnNumber):
        # Create an empty string for storing the characters...
        output = """"
        # Run a while loop while columnNumber is positive...
        while columnNumber > 0:
            # Subtract 1 from columnNumber and get current character by doing modulo of columnNumber by 26...
            output = chr(ord('A') + (columnNumber - 1) % 26) + output
            # Divide columnNumber by 26...
            columnNumber = (columnNumber - 1) // 26
        # Return the output string.
        return output",PratikSen07
169,https://leetcode.com/problems/majority-element/discuss/1788112/Python-easy-solution-O(n)-or-O(1)-or-explained,"class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        curr, count = nums[0], 1              # curr will store the current majority element, count will store the count of the majority
        for i in range(1,len(nums)):
            count += (1 if curr == nums[i] else -1)    # if i is equal to current majority, they're in same team, hence added, else one current majority and i both will be dead
            if not count:                   # if count is 0 means King is de-throwned
                curr = nums[i+1] if i + 1 < len(nums) else None        # the next element is the new King
                count = 0         # starting it with 0 because we can't increment the i of the for loop, the count will be 1 in next iteration, and again the battle continues after next iteration
        return curr",dhananjay79
171,https://leetcode.com/problems/excel-sheet-column-number/discuss/1790567/Python3-CLEAN-SOLUTION-()-Explained,"class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        ans, pos = 0, 0
        for letter in reversed(columnTitle):
            digit = ord(letter)-64
            ans += digit * 26**pos
            pos += 1
            
        return ans",artod
172,https://leetcode.com/problems/factorial-trailing-zeroes/discuss/1152167/Python3-O(log(n))-time-O(1)-space.-Explanation,"class Solution:
    def trailingZeroes(self, n: int) -> int:
        quotient = n // 5
        return quotient + self.trailingZeroes(quotient) if quotient >= 5 else quotient",ryancodrai
173,https://leetcode.com/problems/binary-search-tree-iterator/discuss/1965156/Python-TC-O(1)-SC-O(h)-Generator-Solution,"class BSTIterator:
    def __init__(self, root: Optional[TreeNode]):
        self.iter = self._inorder(root)
        self.nxt = next(self.iter, None)
    
    def _inorder(self, node: Optional[TreeNode]) -> Generator[int, None, None]:
        if node:
            yield from self._inorder(node.left)
            yield node.val
            yield from self._inorder(node.right)

    def next(self) -> int:
        res, self.nxt = self.nxt, next(self.iter, None)
        return res

    def hasNext(self) -> bool:
        return self.nxt is not None",zayne-siew
174,https://leetcode.com/problems/dungeon-game/discuss/699433/Python3-dp,"class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        
        @cache
        def fn(i, j):
            """"""Return min health at (i,j).""""""
            if i == m or j == n: return inf
            if i == m-1 and j == n-1: return max(1, 1 - dungeon[i][j])
            return max(1, min(fn(i+1, j), fn(i, j+1)) - dungeon[i][j])
        
        return fn(0, 0)",ye15
179,https://leetcode.com/problems/largest-number/discuss/1391073/python-easy-custom-sort-solution!!!!!!!,"class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        nums = sorted(nums,key=lambda x:x / (10 ** len(str(x)) - 1 ), reverse=True)
        str_nums = [str(num) for num in nums]
        res = ''.join(str_nums)
        res = str(int(res))
        return res",user0665m
187,https://leetcode.com/problems/repeated-dna-sequences/discuss/2223482/Simple-Python-Solution-oror-O(n)-Time-oror-O(n)-Space-oror-Sliding-Window,"class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        
        res, d = [], {}
        for i in range(len(s)):
            
            if s[i:i+10] not in d: d[s[i:i+10]] = 0
            elif s[i:i+10] not in res: res.append(s[i:i+10])
                
        return res
		
		# An Upvote will be encouraging",rajkumarerrakutti
188,https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/2555699/LeetCode-The-Hard-Way-7-Lines-or-Line-By-Line-Explanation,"class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        # no transaction, no profit
        if k == 0: return 0
        # dp[k][0] = min cost you need to spend at most k transactions
        # dp[k][1] = max profit you can achieve at most k transactions
        dp = [[1000, 0] for _ in range(k + 1)]
        for price in prices:
            for i in range(1, k + 1):
                # price - dp[i - 1][1] is how much you need to spend
                # i.e use the profit you earned from previous transaction to buy the stock
                # we want to minimize it
                dp[i][0] = min(dp[i][0], price - dp[i - 1][1])
                # price - dp[i][0] is how much you can achieve from previous min cost
                # we want to maximize it
                dp[i][1] = max(dp[i][1], price - dp[i][0])
        # return max profit at most k transactions
		# or you can write `return dp[-1][1]`
        return dp[k][1]",wingkwong
189,https://leetcode.com/problems/rotate-array/discuss/1419527/Python-or-Two-Pointers-solution,"class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
            
        def twopt(arr, i, j):
            while (i < j):
                arr[i], arr[j] = arr[j], arr[i]
                i += 1
                j -= 1
            return arr
        
        if k > len(nums):
            k %= len(nums)
            
        if (k > 0):
            twopt(nums, 0, len(nums) - 1)  # rotate entire array
            twopt(nums, 0, k - 1)          # rotate array upto k elements
            twopt(nums, k, len(nums) - 1)  # rotate array from k to end of array",Shreya19595
190,https://leetcode.com/problems/reverse-bits/discuss/1791099/Python-3-(40ms)-or-Real-BIT-Manipulation-Solution,"class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for _ in range(32):
            res = (res<<1) + (n&amp;1)
            n>>=1
        return res",MrShobhit
191,https://leetcode.com/problems/number-of-1-bits/discuss/2074152/Easy-O(1)-Space-PythonC%2B%2B,"class Solution:
    def hammingWeight(self, n: int) -> int: 
        return sum((n &amp; (1<<i))!=0 for i in range(32))",constantine786
198,https://leetcode.com/problems/house-robber/discuss/378700/Python-multiple-solutions,"class Solution:
    def __init__(self):
        self.cache = {}
        
    def rob_rec(self, nums, start):
        if start >= len(nums):
            return 0
        
        if start in self.cache:
            return self.cache[start]
        
        self.cache[start] = nums[start] + max(self.rob_rec(nums, start+2), self.rob_rec(nums, start+3))
        return self.cache[start]
        
    def rob(self, nums: List[int]) -> int:
        return max(self.rob_rec(nums, 0), self.rob_rec(nums, 1))",amchoukir
199,https://leetcode.com/problems/binary-tree-right-side-view/discuss/2266055/C%2B%2B-oror-PYTHON-oror-EXPLAINED-oror,"class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        
        def solve(root, lvl):
        	if root:
        		if len(res)==lvl:
        			res.append(root.val)
        		solve(root.right, lvl + 1)
        		solve(root.left, lvl + 1)
        	return 

        res = []
        solve(root,0)
        return res",karan_8082
200,https://leetcode.com/problems/number-of-islands/discuss/863366/Python-3-or-DFS-BFS-Union-Find-All-3-methods-or-Explanation,"class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid: return 0
        m, n = len(grid), len(grid[0])
        ans = 0
        def dfs(i, j):
            grid[i][j] = '2'
            for di, dj in (0, 1), (0, -1), (1, 0), (-1, 0):
                ii, jj = i+di, j+dj
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == '1':
                    dfs(ii, jj)
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    dfs(i, j)
                    ans += 1
        return ans",idontknoooo
201,https://leetcode.com/problems/bitwise-and-of-numbers-range/discuss/469130/Python-iterative-sol.-based-on-bit-manipulation,"class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        
        shift = 0
        
        # find the common MSB bits.
        while m != n:
            
            m = m >> 1
            n = n >> 1
        
            shift += 1
        
        
        return m << shift",brianchiang_tw
202,https://leetcode.com/problems/happy-number/discuss/2383810/Very-Easy-0-ms-100(Fully-Explained)(C%2B%2B-Java-Python-JS-C-Python3),"class Solution(object):
    def isHappy(self, n):
        hset = set()
        while n != 1:
            if n in hset: return False
            hset.add(n)
            n = sum([int(i) ** 2 for i in str(n)])
        else:
            return True",PratikSen07
203,https://leetcode.com/problems/remove-linked-list-elements/discuss/158651/Simple-Python-solution-with-explanation-(single-pointer-dummy-head).,"class Solution:
    def removeElements(self, head, val):
        """"""
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        """"""
        
        dummy_head = ListNode(-1)
        dummy_head.next = head
        
        current_node = dummy_head
        while current_node.next != None:
            if current_node.next.val == val:
                current_node.next = current_node.next.next
            else:
                current_node = current_node.next
                
        return dummy_head.next",Hai_dee
204,https://leetcode.com/problems/count-primes/discuss/1267254/Python-3-solution-97.7-faster,"class Solution:
    def countPrimes(self, n: int) -> int:
        
        if n<2:
            return 0
        
        #initialize a list of length n
        prime=[1]*n
		#mark 0th  and 1st index as 0
        prime[0]=prime[1]=0
        
		#we will check for multiple from range 2 to sqrt(n)
        for i in range(2,int(sqrt(n))+1):
            if prime[i] == 1:
			#mark all multiple of prime number as  0
                prime[i*i:n:i] = [0] * ((n-1-i*i)//i + 1)
    #return total count of prime 
        return sum(prime)",ritesh98
205,https://leetcode.com/problems/isomorphic-strings/discuss/2472118/Very-Easy-oror-100-oror-Fully-Explained-oror-Java-C%2B%2B-Python-Javascript-Python3-(Using-HashMap),"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return [*map(s.index, s)] == [*map(t.index, t)]",PratikSen07
206,https://leetcode.com/problems/reverse-linked-list/discuss/2458632/Easy-oror-0-ms-oror-100-oror-Fully-Explained-oror-Java-C%2B%2B-Python-JS-C-Python3-(Recursive-and-Iterative),"class Solution(object):
    def reverseList(self, head):
        # Initialize prev pointer as NULL...
        prev = None
        # Initialize the curr pointer as the head...
        curr = head
        # Run a loop till curr points to NULL...
        while curr:
            # Initialize next pointer as the next pointer of curr...
            next = curr.next
            # Now assign the prev pointer to currs next pointer.
            curr.next = prev
            # Assign curr to prev, next to curr...
            prev = curr
            curr = next
        return prev       # Return the prev pointer to get the reverse linked list...",PratikSen07
207,https://leetcode.com/problems/course-schedule/discuss/1627381/Simple-and-Easy-Topological-Sorting-code-beats-97.63-python-submissions,"class Solution:
	def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
		graph=defaultdict(list)
		indegree={}

		#initialising dictionary
		for i in range(numCourses):
			indegree[i]=0	

		#filling graph and indegree dictionaries
		for child,parent in prerequisites:
			graph[parent].append(child)
			indegree[child]+=1

		queue=deque()
		for key,value in indegree.items():
			if value==0:
				queue.append(key)

		courseSequence=[]
		while queue:
			course=queue.popleft()
			courseSequence.append(course)
			for neighbour in graph[course]:
				indegree[neighbour]-=1
				if indegree[neighbour]==0:
					queue.append(neighbour)

		return len(courseSequence)==numCourses:",RaghavGupta22
209,https://leetcode.com/problems/minimum-size-subarray-sum/discuss/1774062/Python-Explanation-of-sliding-window-using-comments,"class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        
        left = 0 # keep track of left pointer
        rsum = 0 # keep the running sum
        res = None # Answer we will return
        
        # Iterate through the array, the index will be your right pointer
        for right in range(len(nums)):
            
            # Add the current value to the running sum
            rsum += nums[right]
            
            # Once you reach a value at or equal to the target you
            # can use a while loop to start subtracting the values from left
            # to right so that you can produce the minimum size subarray
            while rsum >= target:
                
                # The result is either the current result you have, 
                # or the count of numbers from the current left position 
                # to the rightmost position. You need it to be right + 1 
                # because index starts at 0 (if you based the right as the 
                # last index it would be 4 or len(nums) - 1)
                
                # If res is None we compare it against the max float, 
                # saves us from having an if/else
                res = min(res or float('inf'), right + 1 - left)
                
                # Subtract the number to see if we can continue subtracting based
                # on the while loop case and increment the left pointer
                rsum -= nums[left]
                left += 1

        return res or 0",iamricks
210,https://leetcode.com/problems/course-schedule-ii/discuss/1327646/Elegant-Python-DFS,"class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        
        # Handle edge case.
        if not prerequisites: return [course for course in range(numCourses)]
        
        # 'parents' maps each course to a list of its pre
		# -requisites.
        parents = {course: [] for course in range(numCourses)}
        for course, prerequisite in prerequisites:
            parents[course].append(prerequisite)
            
        topological_order = []
        visited, current_path = [False]*numCourses, [False]*numCourses
        
        # Returns False if the digraph rooted at 'course'
		# is acyclic, else, appends courses to 'topological
        # _order' in topological order and returns True.
        def dfs(course):
            if current_path[course]: return False
            if visited[course]: return True
            visited[course], current_path[course] = True, True
            if parents[course]:
                for parent in parents[course]:
                    if not dfs(parent): return False
            topological_order.append(course)
            current_path[course] = False
            return True
        
        for course in range(numCourses):
            if not dfs(course): return []
            
        return topological_order",soma28
212,https://leetcode.com/problems/word-search-ii/discuss/2351408/python3-solution-oror-99-more-faster-oror-39-ms,"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        m = len(board)
        n = len(board[0])
        res = []

        d = [[0, 1], [0, -1], [1, 0], [-1, 0]]

        ref = set()
        for i in range(m):
            for j in range(n-1):
                ref.add(board[i][j] + board[i][j+1])
        for j in range(n):
            for i in range(m-1):
                ref.add(board[i][j] + board[i+1][j])

        for word in words:
            f = True
            for i in range(len(word)-1):
                if word[i:i+2] not in ref and word[i+1] + word[i] not in ref:
                    f = False
                    break
            if not f:
                continue
            if self.findWord(word, m, n, board, d):
                res.append(word)
        return res
    
    def findWord(self, word, m, n, board, d) -> bool:
        if word[:4] == word[0] * 4:
            word = ''.join([c for c in reversed(word)])
        starts = []
        stack = []
        visited = set()
        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0]:
                    if len(word) == 1:
                        return True
                    starts.append((i, j))
        for start in starts:
            stack.append(start)
            visited.add((start, ))
            l = 1
            while stack != [] and l < len(word):
                x, y = stack[-1]
                for dxy in d:
                    nx, ny = x + dxy[0], y + dxy[1]
                    if 0 <= nx < m and 0 <= ny < n:
                        if board[nx][ny] == word[l]:
                            if (nx, ny) not in stack and tuple(stack) + ((nx, ny),) not in visited:
                                stack.append((nx, ny))
                                visited.add(tuple(stack))
                                l += 1
                                if l == len(word):
                                    return True
                                break
                else:
                    stack.pop()
                    l -= 1
        else:
            return False",vimla_kushwaha
213,https://leetcode.com/problems/house-robber-ii/discuss/2158878/Do-house-robber-twice,"class Solution:
    def rob(self, nums: List[int]) -> int:
        
        if len(nums) == 1:
            return nums[0]
        
        dp = {}
        def getResult(a,i):
            if i>=len(a):
                return 0
            if i in dp:
                return dp[i]
            
            sum = 0
            if i<len(a)-1:
                sum+= max(a[i]+getResult(a,i+2),a[i+1]+getResult(a,i+3))
            else:
                sum+=a[i]+getResult(a,i+2)
            dp[i] = sum
            return sum
            
        x = getResult(nums[:len(nums)-1],0)
        dp = {}
        y = getResult(nums[1:],0)
            
        return max(x, y)",Dark_wolf_jss
214,https://leetcode.com/problems/shortest-palindrome/discuss/2157861/No-DP-No-DS-Intuitive-with-comments-oror-Python,"class Solution:
    def shortestPalindrome(self, s: str) -> str:
        
        end = 0
        
        # if the string itself is a palindrome return it
        if(s == s[::-1]):
            return s
        
        # Otherwise find the end index of the longest palindrome that starts
        # from the first character of the string
        
        for i in range(len(s)+1):
            if(s[:i]==s[:i][::-1]):
                end=i-1
        
        # return the string with the remaining characters other than
        # the palindrome reversed and added at the beginning
        
        return (s[end+1:][::-1])+s",a-myth
215,https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/2180509/Python-Easy-O(logn)-Space-approach-or-One-liner,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:                    
        n = len(nums)
        
        def partition(l, r, pivot):
            pivot_elem=nums[pivot]
            nums[r],nums[pivot]=nums[pivot],nums[r]
            
            index=l
            for i in range(l, r):
                if nums[i]<pivot_elem:
                    nums[i],nums[index]=nums[index],nums[i]
                    index+=1
            
            nums[index],nums[r]=nums[r],nums[index]
            return index
        
        def quick_select(l,r,kth_index):
            if l==r:
                return nums[l]
            
            pivot_index=partition(l,r,l)
            
            if pivot_index==kth_index:
                return nums[pivot_index]
            
            if kth_index>pivot_index:
                return quick_select(pivot_index+1, r, kth_index)
            else:
                return quick_select(l,pivot_index-1, kth_index)
        
        return quick_select(0, n - 1, n - k)",constantine786
216,https://leetcode.com/problems/combination-sum-iii/discuss/1312030/Elegant-Python-Iterative-or-Recursive,"class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        
        current_combination, combinations = [], []
        integer, combination_sum = 1, 0
        queue = [(integer, current_combination, combination_sum)]
        while queue:
            integer, current_combination, combination_sum = queue.pop()
            if combination_sum == n and len(current_combination) == k: combinations.append(current_combination)
            else:
                for i in range(integer, 10):
                    if combination_sum + i > n: break
                    queue.append((i+1, current_combination + [i], combination_sum + i))
        
        return combinations",soma28
217,https://leetcode.com/problems/contains-duplicate/discuss/1496268/Python-98-speed-faster,"class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) != len(nums)",fabioo29
218,https://leetcode.com/problems/the-skyline-problem/discuss/2640697/Python-oror-Easily-Understood-oror-Faster-oror-with-maximum-heap-explained,"class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        # for the same x, (x, -H) should be in front of (x, 0)
        # For Example 2, we should process (2, -3) then (2, 0), as there's no height change
        x_height_right_tuples = sorted([(L, -H, R) for L, R, H in buildings] + [(R, 0, ""doesn't matter"") for _, R, _ in buildings])   
        # (0, float('inf')) is always in max_heap, so max_heap[0] is always valid
        result, max_heap = [[0, 0]], [(0, float('inf'))]
        for x, negative_height, R in x_height_right_tuples:
            while x >= max_heap[0][1]:
                # reduce max height up to date, i.e. only consider max height in the right side of line x
                heapq.heappop(max_heap)
            if negative_height:
                # Consider each height, as it may be the potential max height
                heapq.heappush(max_heap, (negative_height, R))
            curr_max_height = -max_heap[0][0]
            if result[-1][1] != curr_max_height:
                result.append([x, curr_max_height])
        return result[1:]",rajukommula
219,https://leetcode.com/problems/contains-duplicate-ii/discuss/2463150/Very-Easy-oror-100-oror-Fully-Explained-oror-Java-C%2B%2B-Python-Javascript-Python3-(Using-HashSet),"class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        # Create hset for storing previous of k elements...
        hset = {}
        # Traverse for all elements of the given array in a for loop...
        for idx in range(len(nums)):
            # If duplicate element is present at distance less than equal to k, return true...
            if nums[idx] in hset and abs(idx - hset[nums[idx]]) <= k:
                return True
            hset[nums[idx]] = idx
        # If no duplicate element is found then return false...
        return False",PratikSen07
220,https://leetcode.com/problems/contains-duplicate-iii/discuss/825267/Python3-summarizing-Contain-Duplicates-I-II-III,"class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for x in nums:
            if x in seen: return True 
            seen.add(x)
        return False",ye15
221,https://leetcode.com/problems/maximal-square/discuss/1632285/Python-1D-Array-DP-Optimisation-Process-Explained,"class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        result = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                curr = 0  # current length of the square at (i, j)
                flag = True  # indicates if there still exists a valid square
                while flag:
                    for k in range(curr+1):
                        # check outer border of elements for '1's.
                        """"""
                        eg curr = 2, ie a valid 2x2 square exists
                        'O' is valid, check 'X':
                        X X X
                        X O O
                        X O O
                        """"""
                        if i < curr or j < curr or \
                                matrix[i-curr][j-k] == '0' or \
                                matrix[i-k][j-curr] == '0':
                            flag = False
                            break
                    curr += flag
                if curr > result:  # new maximum length of square obtained
                    result = curr
        return result*result  # area = length x length",zayne-siew
222,https://leetcode.com/problems/count-complete-tree-nodes/discuss/701577/PythonPython3-Count-Complete-Tree-Nodes,"class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root: return 0
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)",newborncoder
223,https://leetcode.com/problems/rectangle-area/discuss/2822409/Fastest-python-solution,"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        coxl=max(ax1,bx1)
        coxr=min(ax2,bx2)
        coyl=max(ay1,by1)
        coyr=min(ay2,by2)
        dx=coxr-coxl
        dy=coyr-coyl
        comm=0
        if dx>0 and dy>0:
            comm=dx*dy
        a=abs(ax2-ax1)*abs(ay2-ay1)
        b=abs(bx2-bx1)*abs(by2-by1)
        area=a+b-comm
        return area",shubham_1307
224,https://leetcode.com/problems/basic-calculator/discuss/2832718/Python-(Faster-than-98)-or-O(N)-stack-solution,"class Solution:
    def calculate(self, s: str) -> int:
        output, curr, sign, stack = 0, 0, 1, []
        for c in s:
            if c.isdigit():
                curr = (curr * 10) + int(c)
            
            elif c in '+-':
                output += curr * sign
                curr = 0
                if c == '+':
                    sign = 1

                else:
                    sign = -1
            
            elif c == '(':
                stack.append(output)
                stack.append(sign)
                sign = 1
                output = 0
            
            elif c == ')':
                output += curr * sign
                output *= stack.pop()    #sign
                output += stack.pop()    #last output
                curr = 0

        return output + (curr * sign)",KevinJM17
226,https://leetcode.com/problems/invert-binary-tree/discuss/2463600/Easy-oror-100-oror-Fully-Explained-oror-Java-C%2B%2B-Python-JS-C-Python3-oror-Recursive-and-Iterative,"class Solution(object):
    def invertTree(self, root):
        # Base case...
        if root == None:
            return root
        # swapping process...
        root.left, root.right = root.right, root.left
        # Call the function recursively for the left subtree...
        self.invertTree(root.left)
        # Call the function recursively for the right subtree...
        self.invertTree(root.right)
        return root     # Return the root...",PratikSen07
227,https://leetcode.com/problems/basic-calculator-ii/discuss/1209116/python-without-any-stack-and-beat-99,"class Solution:
    def calculate(self, s: str) -> int:
        curr_res = 0
        res = 0
        num = 0
        op = ""+""  # keep the last operator we have seen
        
		# append a ""+"" sign at the end because we can catch the very last item
        for ch in s + ""+"":
            if ch.isdigit():
                num = 10 * num + int(ch)

            # if we have a symbol, we would start to calculate the previous part.
            # note that we have to catch the last chracter since there will no sign afterwards to trigger calculation
            if ch in (""+"", ""-"", ""*"", ""/""):
                if op == ""+"":
                    curr_res += num
                elif op == ""-"":
                    curr_res -= num
                elif op == ""*"":
                    curr_res *= num
                elif op == ""/"":
                    # in python if there is a negative number, we should alway use int() instead of //
                    curr_res = int(curr_res / num)
                
                # if the chracter is ""+"" or ""-"", we do not need to worry about
                # the priority so that we can add the curr_res to the eventual res
                if ch in (""+"", ""-""):
                    res += curr_res
                    curr_res = 0
                
                op = ch
                num = 0
        
        return res",ZAbird
228,https://leetcode.com/problems/summary-ranges/discuss/1805476/Python-Simple-Python-Solution-Using-Iterative-Approach-oror-O(n),"class Solution:
	def summaryRanges(self, nums: List[int]) -> List[str]:

		start = 0
		end = 0

		result = []

		while start < len(nums) and end<len(nums):

			if end+1 < len(nums) and nums[end]+1 == nums[end+1]:
				end=end+1

			else:
				if start == end:
					result.append(str(nums[start]))
					start = start + 1
					end = end + 1
				else:
					result.append(str(nums[start])+'->'+str(nums[end]))
					start = end + 1
					end = end + 1

		return result",ASHOK_KUMAR_MEGHVANSHI
229,https://leetcode.com/problems/majority-element-ii/discuss/1483430/Python-95-faster-in-speed,"class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        return [x for x in set(nums) if nums.count(x) > len(nums)/3]",fabioo29
230,https://leetcode.com/problems/kth-smallest-element-in-a-bst/discuss/1960632/Inorder-%2B-Heap-In-Python,"class Solution:
    import heapq
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        
        heap = []
        def inorder(r):
            if r:
                inorder(r.left)
                heapq.heappush(heap,-(r.val))
                if len(heap) > k:
                    heapq.heappop(heap)
                inorder(r.right)
        inorder(root)
        
        return -heapq.heappop(heap)",gamitejpratapsingh998
231,https://leetcode.com/problems/power-of-two/discuss/948641/Python-O(1)-Solution,"class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n>0 and n&amp;(n-1)==0",lokeshsenthilkumar
233,https://leetcode.com/problems/number-of-digit-one/discuss/1655517/Python3-O(9)-Straight-Math-Solution,"class Solution:
    def countDigitOne(self, n: int) -> int:
        
        #O(logn) mathematical solution
        #intervals of new 1s: 0-9, 10-99, 100-999, 1000,9999... 
            #each interval yields 1,10,100,etc. new '1's respectively
		#first and foremost, we want to check how many of each interval repeats 
        #conditions for FULL yield when curr%upper bound+1: 1 <=, 19 <=, 199 <=...
        #conditions for PARTIAL yielf when curr%upper bound+1: None, 10 <= < 19,  100 <= < 199, 1000 <= < 1999 ... 
        
        ans = 0
        for i in range(len(str(n))):
            curr = 10**(i+1)
            hi,lo = int('1'+'9'*i), int('1'+'0'*i)
            ans += (n//curr) * 10**i
            if (pot:=n%curr) >= hi: ans += 10**i
            elif lo <= pot < hi: 
                ans += pot - lo + 1
        return ans",terrysu64
234,https://leetcode.com/problems/palindrome-linked-list/discuss/2466200/Python-O(N)O(1),"class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        def reverse(node):
            prev = None
            while node:
                next_node = node.next
                node.next = prev 
                prev, node = node, next_node
                
            return prev
        
        slow = head
        fast = head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        n1 = head
        n2 = reverse(slow.next)
        while n2:
            if n1.val != n2.val:
                return False
            
            n1 = n1.next
            n2 = n2.next
            
        return True",blue_sky5
235,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/discuss/1394823/Explained-Easy-Iterative-Python-Solution,"class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        
        while True:
            if root.val > p.val and root.val > q.val:
                root = root.left
            elif root.val < p.val and root.val < q.val:
                root = root.right
            else:
                return root",sevdariklejdi
236,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/2539410/python3-simple-Solution,"class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root==None or root.val==p.val or root.val==q.val:
            return root
        left=self.lowestCommonAncestor(root.left,p,q)
        right=self.lowestCommonAncestor(root.right,p,q)
        if left!=None and right!=None:
            return root
        elif left!=None:
            return left
        else:
            return right",pranjalmishra334
237,https://leetcode.com/problems/delete-node-in-a-linked-list/discuss/1454184/95.96-faster-and-Simpler-solution-with-Explanation.,"class Solution:
    def deleteNode(self, node):

        nextNode = node.next
        node.val = nextNode.val
        node.next = nextNode.next",AmrinderKaur1
238,https://leetcode.com/problems/product-of-array-except-self/discuss/744951/Product-of-array-except-self-Python3-Solution-with-a-Detailed-Explanation,"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        leftProducts = [0]*len(nums) # initialize left array 
        rightProducts = [0]*len(nums) # initialize right array
        
        leftProducts[0] = 1 # the left most is 1
        rightProducts[-1] = 1 # the right most is 1
        res = [] # output
        
        for i in range(1, len(nums)):
            leftProducts[i] = leftProducts[i-1]*nums[i-1]
            rightProducts[len(nums) - i - 1] = rightProducts[len(nums) - i]*nums[len(nums) - i]
            
        for i in range(len(nums)):
            res.append(leftProducts[i]*rightProducts[i])
        
        return res",peyman_np
239,https://leetcode.com/problems/sliding-window-maximum/discuss/1624633/Python-3-O(n),"class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        res = []
        window = collections.deque()
        for i, num in enumerate(nums):
            while window and num >= nums[window[-1]]:
                window.pop()
            window.append(i)
            
            if i + 1 >= k:
                res.append(nums[window[0]])
            
            if i - window[0] + 1 == k:
                window.popleft()
        
        return res",dereky4
240,https://leetcode.com/problems/search-a-2d-matrix-ii/discuss/2324351/PYTHON-oror-EXPLAINED-oror,"class Solution:
    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:
        
        m=len(mat)
        n=len(mat[0])
        
        i=m-1
        j=0
        
        while i>=0 and j<n:
            if mat[i][j]==target:
                return True
            elif mat[i][j]<target:
                j+=1
            else:
                i-=1
                
        return False",karan_8082
241,https://leetcode.com/problems/different-ways-to-add-parentheses/discuss/2392799/Python3-Divide-and-Conquer%3A-Recursion-%2B-Memoization,"class Solution(object):
    def diffWaysToCompute(self, s, memo=dict()):
        if s in memo:
            return memo[s]
        if s.isdigit(): # base case
            return [int(s)]
        calculate = {'*': lambda x, y: x * y,
                     '+': lambda x, y: x + y,
                     '-': lambda x, y: x - y
                    }
        result = []
        for i, c in enumerate(s):
            if c in '+-*':
                left = self.diffWaysToCompute(s[:i], memo)
                right = self.diffWaysToCompute(s[i+1:], memo)
                for l in left:
                    for r in right:
                        result.append(calculate[c](l, r))
        memo[s] = result
        return result",mhpd
242,https://leetcode.com/problems/valid-anagram/discuss/433680/Python-3-O(n)-Faster-than-98.39-Memory-usage-less-than-100,"class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        tracker = collections.defaultdict(int)
        for x in s: tracker[x] += 1
        for x in t: tracker[x] -= 1
        return all(x == 0 for x in tracker.values())",mmbhatk
257,https://leetcode.com/problems/binary-tree-paths/discuss/484118/Python-3-(beats-~100)-(nine-lines)-(DFS),"class Solution:
    def binaryTreePaths(self, R: TreeNode) -> List[str]:
        A, P = [], []
        def dfs(N):
            if N == None: return
            P.append(N.val)
            if (N.left,N.right) == (None,None): A.append('->'.join(map(str,P)))
            else: dfs(N.left), dfs(N.right)
            P.pop()
        dfs(R)
        return A
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
258,https://leetcode.com/problems/add-digits/discuss/2368005/Very-Easy-100-(Fully-Explained)(Java-C%2B%2B-Python-JS-C-Python3),"class Solution(object):
    def addDigits(self, num):
        while num > 9:
            num = num % 10 + num // 10
        return num",PratikSen07
260,https://leetcode.com/problems/single-number-iii/discuss/2828366/brute-force-with-dictnory,"class Solution:

    def singleNumber(self, nums: List[int]) -> List[int]:
        dc=defaultdict(lambda:0)
        for a in(nums):
            dc[a]+=1
        ans=[]
        for a in dc:
            if(dc[a]==1):
                ans.append(a)
        return ans",droj
263,https://leetcode.com/problems/ugly-number/discuss/336227/Solution-in-Python-3-(beats-~99)-(five-lines),"class Solution:
    def isUgly(self, num: int) -> bool:
        if num == 0: return False
        while num % 5 == 0: num /= 5
        while num % 3 == 0: num /= 3
        while num % 2 == 0: num /= 2
        return num == 1
		

- Junaid Mansuri",junaidmansuri
264,https://leetcode.com/problems/ugly-number-ii/discuss/556314/Python-Simple-DP-9-Lines,"class Solution:
    def nthUglyNumber(self, n: int) -> int:
        k = [0] * n
        t1 = t2 = t3 = 0
        k[0] = 1
        for i in range(1,n):
            k[i] = min(k[t1]*2,k[t2]*3,k[t3]*5)
            if(k[i] == k[t1]*2): t1 += 1
            if(k[i] == k[t2]*3): t2 += 1
            if(k[i] == k[t3]*5): t3 += 1
        return k[n-1]",mazz272727
268,https://leetcode.com/problems/missing-number/discuss/2081185/Python-Easy-One-liners-with-Explanation,"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        return (len(nums) * (len(nums) + 1))//2 - sum(nums)",constantine786
273,https://leetcode.com/problems/integer-to-english-words/discuss/1990823/JavaC%2B%2BPythonJavaScriptKotlinSwiftO(n)timeBEATS-99.97-MEMORYSPEED-0ms-APRIL-2022,"class Solution:
    def numberToWords(self, num: int) -> str:
        mp = {1: ""One"",   11: ""Eleven"",    10: ""Ten"", 
              2: ""Two"",   12: ""Twelve"",    20: ""Twenty"", 
              3: ""Three"", 13: ""Thirteen"",  30: ""Thirty"", 
              4: ""Four"",  14: ""Fourteen"",  40: ""Forty"",
              5: ""Five"",  15: ""Fifteen"",   50: ""Fifty"", 
              6: ""Six"",   16: ""Sixteen"",   60: ""Sixty"", 
              7: ""Seven"", 17: ""Seventeen"", 70: ""Seventy"", 
              8: ""Eight"", 18: ""Eighteen"",  80: ""Eighty"",
              9: ""Nine"",  19: ""Nineteen"",  90: ""Ninety""}
        
        def fn(n):
            """"""Return English words of n (0-999) in array.""""""
            if not n: return []
            elif n < 20: return [mp[n]]
            elif n < 100: return [mp[n//10*10]] + fn(n%10)
            else: return [mp[n//100], ""Hundred""] + fn(n%100)
        
        ans = []
        for i, unit in zip((9, 6, 3, 0), (""Billion"", ""Million"", ""Thousand"", """")): 
            n, num = divmod(num, 10**i)
            ans.extend(fn(n))
            if n and unit: ans.append(unit)
        return "" "".join(ans) or ""Zero""",cucerdariancatalin
274,https://leetcode.com/problems/h-index/discuss/785586/Python3-O(n)-without-sorting!,"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        tmp = [0] * (len(citations) + 1)
		
        for i in range(len(citations)):
            if citations[i] > len(citations):
                tmp[len(citations)] += 1
            else:
                tmp[citations[i]] += 1

        sum_ = 0
        for i in range(len(tmp) - 1, -1, -1):
            sum_ += tmp[i]
            if sum_ >= i:
                return i",DebbieAlter
275,https://leetcode.com/problems/h-index-ii/discuss/2729382/Python3-Solution-or-Binary-Search-or-O(logn),"class Solution:
    def hIndex(self, A):
        n = len(A)
        l, r = 0, n - 1
        while l < r:
            m = (l + r + 1) // 2
            if A[m] > n - m: r = m - 1
            else: l = m
        return n - l - (A[l] < n - l)",satyam2001
278,https://leetcode.com/problems/first-bad-version/discuss/2700688/Simple-Python-Solution-Using-Binary-Search,"class Solution:
    def firstBadVersion(self, n: int) -> int:
        left = 1
        right = n
        result = 1
        
        while left<=right:
            mid = (left+right)//2
            if isBadVersion(mid) == False:
                left = mid+1
            else:
                right = mid-1
                result = mid
                
        return result",pniraj657
279,https://leetcode.com/problems/perfect-squares/discuss/376795/100-O(log-n)-Python3-Solution-Lagrange's-four-square-theorem,"class Solution:
    def isSquare(self, n: int) -> bool:
        sq = int(math.sqrt(n))
        return sq*sq == n
        
    def numSquares(self, n: int) -> int:
        # Lagrange's four-square theorem
        if self.isSquare(n):
            return 1
        while (n &amp; 3) == 0:
            n >>= 2
        if (n &amp; 7) == 7:
            return 4
        sq = int(math.sqrt(n)) + 1
        for i in range(1,sq):
            if self.isSquare(n - i*i):
                return 2
        return 3",TCarmic
282,https://leetcode.com/problems/expression-add-operators/discuss/1031229/Python-Simple-heavily-commented-and-accepted-Recursive-Solution,"class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        exprs = []
        
        def recurse(idx, value, delta, exp):
            # base case here
            if idx == len(num):
                if value == target:
                    exprs.append("""".join(exp))
            
            # the loop will create the current operand and recursively call
            # the next set of actions to be executed
            for i in range(idx, len(num)):
                # this is to avoid cases where the operand starts with a 0
                # we need to have a case with just the 0 but not something like
                # 05, so the condition will return early if we find such cases
                if num[idx] == '0' and i > idx:
                    return
                
                curr = int(num[idx:i+1])
                curr_str = num[idx:i+1]
                
                # when we start the problem we dont have a preceding operator or operand
                if idx == 0:
                    recurse(i+1, curr, curr, exp + [curr_str])
                else:
                    # We need to do 3 different recursions for each operator
                    # value stores the running value of the expression evaluated so far
                    # the crux of the logic lies in how we use and pass delta
                    # when the operation is '+' or '-' we don't care much about it and can just
                    # add or subtract it from the value 
                    # when '*' is involved, we need to follow the precedence relation,
                    # but we have already evaluated the previous operator. We know the
                    # previous operation that was performed and how much it contributed to the value i.e., delta
                    # so, we can revert that operation by subtracting delta from value and reapplying the multiplication
                    recurse(i+1, value+curr, curr, exp + ['+', curr_str])
                    recurse(i+1, value-curr, -curr, exp + ['-', curr_str])
                    recurse(i+1, (value-delta)+curr*delta, curr*delta, exp + ['*', curr_str])
                            
        recurse(0, 0, 0, [])
        return exprs",gokivego
283,https://leetcode.com/problems/move-zeroes/discuss/404010/Python-easy-solution,"class Solution(object):
	def moveZeroes(self, nums):
		i=0
		n = len(nums)
		while i <n:
			if nums[i]==0:
				nums.pop(i)
				nums.append(0)
				n-=1
			else:
				i+=1",saffi
287,https://leetcode.com/problems/find-the-duplicate-number/discuss/650942/Proof-of-Floyd's-cycle-detection-algorithm-Find-the-Duplicate-Number,"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = fast = ans = 0
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        while ans != slow:
            ans = nums[ans]
            slow = nums[slow]
        return ans",r0bertz
289,https://leetcode.com/problems/game-of-life/discuss/468108/Use-the-tens-digit-as-a-counter-Python-O(1)-Space-O(mn)-Time,"class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        
        def is_neighbor(board, i, j):
            return (0 <= i < len(board)) and (0 <= j < len(board[0])) and board[i][j] % 10 == 1
        
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                for d in directions:
                    board[i][j] += 10 if is_neighbor(board, i + d[0], j + d[1]) else 0 # if adj cell is neighbor, add 10
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                neighbors = board[i][j] // 10 # count of neighbors
                is_live = board[i][j] % 10 == 1 # state is live or not
                if is_live: # live(1)
                    if neighbors < 2:   # Rule 1
                        board[i][j] = 0
                    elif neighbors > 3: # Rule 3
                        board[i][j] = 0
                    else:               # Rule 2
                        board[i][j] = 1
                else: # dead(0)
                    if neighbors == 3:  # Rule 4
                        board[i][j] = 1
                    else:
                        board[i][j] = 0",Moooooon
290,https://leetcode.com/problems/word-pattern/discuss/1696590/Simple-Python-Solution-oror-Faster-than-99.34,"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        li = s.split(' ')
        di = {}
        if len(li) != len(pattern):
            return False
        
        for i, val in enumerate(pattern):
            if val in di and di[val] != li[i]:
                return False
            elif val not in di and li[i] in di.values():
                return False
            elif val not in di:
                di[val] = li[i]
                    
        return True",KiranUpase
292,https://leetcode.com/problems/nim-game/discuss/1141120/Bottom-up-DP-python,"class Solution:
    def canWinNim(self, n: int) -> bool:        
        if n <= 3:
            return True
        new_size = n + 1
        memo = [False] * (new_size)
        
        for i in range(4): 
            memo[i] = True
        
        for i in range(4,new_size):
            for j in range(1,4):
                if memo[i] == True:
                    break
                if memo[i-j] == True:
                    memo[i] = False
                else:
                    memo[i] = True
        
        return memo[n]",lywc
299,https://leetcode.com/problems/bulls-and-cows/discuss/563661/Fast-and-easy-to-understand-Python-solution-O(n),"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        
		# The main idea is to understand that cow cases contain the bull cases
		
		# This loop will take care of ""bull"" cases
        bull=0
        for i in range(len(secret)):
            bull += int(secret[i] == guess[i])
        
		# This loop will take care of ""cow"" cases
        cows=0
        for c in set(secret):
            cows += min(secret.count(c), guess.count(c))
        
        return f""{bull}A{cows-bull}B""",mista2311
300,https://leetcode.com/problems/longest-increasing-subsequence/discuss/2395570/Python3-oror-7-lines-binSearch-cheating-wexplanation-oror-TM%3A-9482,"class Solution:     # Suppose, for example:
                    #           nums = [1,8,4,5,3,7],
                    # for which the longest strictly increasing subsequence is arr = [1,4,5,7],
                    # giving len(arr) = 4 as the answer
                    #
                    # Here's the plan:
                    #   1) Initiate arr = [num[0]], which in this example means arr = [1]
                    #     
                    #   2) Iterate through nums. 2a) If n in nums is greater than arr[-1], append n to arr. 2b) If 
                    #      not, determine the furthest position in arr at which n could be placed so that arr
                    #      remains strictly increasing, and overwrite the element at that position in arr with n.

                    #   3) Once completed, return the length of arr.

                    # Here's the iteration for the example:

                    #       nums = [ _1_, 8,4,5,3,7]     arr = [1]              (initial step)
                    #       nums = [1, _8_, 4,5,3,7]     arr = [1, 8]           (8 > 1, so    append 8)
                    #       nums = [1,8, _4_, 5,3,7]     arr = [1, 4]           (4 < 8, so overwrite 8)
                    #       nums = [1_8,4, _5_, 3,7]     arr = [1, 4, 5]        (5 > 4, so    append 5)
                    #       nums = [1_8,4,5, _3_, 7]     arr = [1, 3, 5]        (3 < 5, so overwrite 4)
                    #       nums = [1_8,4,5,3, _7_ ]     arr = [1, 3, 5, 7]     (7 > 5, so    append 7)    

                    # Notice that arr is not the sequence given above as the correct seq. The ordering for [1,3,5,7]
                    # breaks the ""no changing the order"" rule. Cheating? Maybe... However len(arr) = 4 is the 
                    # correct answer. Overwriting 4 with 3 did not alter the sequence's length.
                                
    def lengthOfLIS(self, nums: list[int]) -> int:

        arr = [nums.pop(0)]                  # <-- 1) initial step
 
        for n in nums:                       # <-- 2) iterate through nums
            
            if n > arr[-1]:                  # <--    2a)
                arr.append(n)

            else:                            # <--    2b)
                arr[bisect_left(arr, n)] = n 

        return len(arr)                      # <-- 3) return the length of arr",warrenruud
301,https://leetcode.com/problems/remove-invalid-parentheses/discuss/1555755/Easy-to-understand-Python-solution,"class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        
        def valid(s):
            l,r=0,0
            for c in s:
                if c=='(':
                    l+=1
                elif c==')':
                    if  l<=0:
                        r+=1
                    else:
                        l-=1
            return not l and not r
        
        res=[]
        seen=set()
        level={s}
        while True:
            newLevel=set()
            for word in level:
                if valid(word):
                    res.append(word)
            if res: return res
            
            for word in level:
                for i in range(len(word)):
                    if word[i] in '()':
                        newWord=word[:i]+word[i+1:]
                        if newWord not in seen:
                            seen.add(newWord)
                            newLevel.add(newWord)
                  
            level=newLevel
                
        return [""""]",InjySarhan
306,https://leetcode.com/problems/additive-number/discuss/2764371/Python-solution-with-complete-explanation-and-code,"class Solution:
    def isAdditiveNumber(self, s: str) -> bool:
        n = len(s)
        for i in range(1, n): # Choose the length of first number
            # If length of 1st number is > 1 and starts with 0 -- skip
            if i != 1 and s[0] == '0':
                continue
            for j in range(1, n): # Choose the length of second number
                # If length of 2nd number is > 1 and starts with 0 -- skip
                if j != 1 and s[i] == '0':
                    continue

                # If the total length of 1st and 2nd number >= n -- skip
                if i + j >= n:
                    break

                # Just use the brute force approach
                a = int(s[0: i])
                b = int(s[i: i+j])
                d = i+j
                while d < n:
                    c = a + b
                    t = str(c)
                    if s[d: d + len(t)] != t:
                        break
                    d += len(t)
                    a = b
                    b = c
                if d == n:
                    return True
        return False",smit5300
309,https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/2132119/Python-or-Easy-DP-or,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0 for i in range(2)] for i in range(n+2)]
        
        dp[n][0] = dp[n][1] = 0
            
        ind = n-1
        while(ind>=0):
		
            for buy in range(2):
                if(buy):
                    profit = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])
					
                else:
                    profit = max(prices[ind] + dp[ind+2][1], 0 + dp[ind+1][0])
                    
                dp[ind][buy] = profit
				
            ind -= 1    
			
        return dp[0][1]",LittleMonster23
310,https://leetcode.com/problems/minimum-height-trees/discuss/1753794/Python-easy-to-read-and-understand-or-reverse-topological-sort,"class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1:
            return [0]
        graph = {i:[] for i in range(n)}
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        leaves = []
        for node in graph:
            if len(graph[node]) == 1:
                leaves.append(node)
        
        while len(graph) > 2:
            new_leaves = []
            for leaf in leaves:
                nei = graph[leaf].pop()
                del graph[leaf]
                graph[nei].remove(leaf)
                if len(graph[nei]) == 1:
                    new_leaves.append(nei)
            leaves = new_leaves
        
        return leaves",sanial2001
312,https://leetcode.com/problems/burst-balloons/discuss/1477014/Python3-or-Top-down-Approach,"class Solution(object):
    def maxCoins(self, nums):
        n=len(nums)
        nums.insert(n,1)
        nums.insert(0,1)
        self.dp={}
        return self.dfs(1,nums,n)
    def dfs(self,strt,nums,end):
        ans=0
        if strt>end:
            return 0
        if (strt,end) in self.dp:
            return self.dp[(strt,end)]
        for i in range(strt,end+1):
            lmax=self.dfs(strt,nums,i-1)
            rmax=self.dfs(i+1,nums,end)
            curr_coins=nums[strt-1]*nums[i]*nums[end+1]+lmax+rmax
            ans=max(ans,curr_coins)
        self.dp[(strt,end)]=ans
        return self.dp[(strt,end)]",swapnilsingh421
313,https://leetcode.com/problems/super-ugly-number/discuss/2828266/heapq-did-the-job,"class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        hp=[1]
        dc={1}
        i=1
        while(n):
            mn=heapq.heappop(hp)
            if(n==1):
                return mn
            for p in primes:
                newno=mn*p
                if(newno in dc):
                    continue
                heapq.heappush(hp,newno)
                dc.add(newno)
            n-=1",droj
315,https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/2320000/Python3.-oror-binSearch-6-lines-w-explanation-oror-TM%3A-9784,"class Solution:     # Here's the plan:
                    #   1) Make arr, a sorted copy of the list nums.
                    #   2) iterate through nums. For each element num in nums:
                    #       2a) use a binary search to determine the count of elements
                    #         in the arr that are less than num.
                    #       2b) append that count to the answer list
                    #       2c) delete num from arr
                    #   3) return the ans list 
                    #   
                    #   For example, suppose nums = [5,2,6,1] Then arr = [1,2,5,6].
                    #       num = 5 => binsearch: arr = [1,2,/\5,6], i = 2 => ans = [2,_,_,_], del 5
                    #       num = 2 => binsearch: arr = [1,/\2,6],   i = 1 => ans = [2,1,_,_], del 2
                    #       num = 6 => binsearch: arr = [1,/\6],     i = 1 => ans = [2,1,1,_], del 6
                    #       num = 1 => binsearch: arr = [/\1],       i = 0 => ans = [2,1,1,0], del 1

    def countSmaller(self, nums: List[int]) -> List[int]:
        arr, ans = sorted(nums), []     #   <-- 1)
        
        for num in nums:
            i = bisect_left(arr,num)    #   <-- 2a)
            ans.append(i)               #   <-- 2b)
            del arr[i]                  #   <-- 2c)
            
        return ans                      #   <-- 3)",warrenruud
316,https://leetcode.com/problems/remove-duplicate-letters/discuss/1687144/Python-3-Simple-solution-using-a-stack-and-greedy-approach-(32ms-14.4MB),"class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = []
        
        for idx, character in enumerate(s):
            if not stack:
                stack.append(character)
            elif character in stack:
                continue
            else:
                while stack and (character < stack[-1]):
                    if stack[-1] in s[idx + 1:]:
                        _ = stack.pop()
                    else:
                        break
                        
                stack.append(character)
                
        return ''.join(stack)",seankala
318,https://leetcode.com/problems/maximum-product-of-word-lengths/discuss/2085316/Python-or-or-Easy-3-Approaches-explained,"class Solution:
    def maxProduct(self, words: List[str]) -> int:
        n=len(words)                        
        char_set = [set(words[i]) for i in range(n)] # precompute hashset for each word                                                  
        max_val = 0
        for i in range(n):
            for j in range(i+1, n):
                if not (char_set[i] &amp; char_set[j]): # if nothing common
                    max_val=max(max_val, len(words[i]) * len(words[j]))
        
        return max_val",constantine786
319,https://leetcode.com/problems/bulb-switcher/discuss/535399/PythonJSJavaC%2B%2B-sol-by-perfect-square.-w-Visualization,"class Solution:
    def bulbSwitch(self, n: int) -> int:
        
        # Only those bulds with perferct square number index will keep ""ON"" at last.
        
        return int(n**0.5)",brianchiang_tw
321,https://leetcode.com/problems/create-maximum-number/discuss/2167532/O(k(m%2Bn)).-Python-Solution-with-monotonically-decreasing-stack.-Commented-for-clarity.,"class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        def maximum_num_each_list(nums: List[int], k_i: int) -> List[int]:
            # monotonically decreasing stack
            s = []
            m = len(nums) - k_i
            for n in nums:
                while s and s[-1] < n and m > 0:
                    s.pop()
                    m -= 1
                s.append(n)
            s = s[:len(s)-m] # very important
            return s
        def greater(a, b, i , j): # get the number which is lexiographically greater
            while i< len(a) or j < len(b): 
                if i == len(a): return False
                if j == len(b): return True
                if a[i] > b[j]: return True
                if a[i] < b[j]: return False
                i += 1 # we increment until each of their elements are same
                j += 1
        
        def merge(x_num, y_num):
            n = len(x_num)
            m = len(y_num)
            i = 0
            j = 0
            s = []
            while i < n or j < m:
                a = x_num[i] if i < n else float(""-inf"") 
                b = y_num[j] if j < m else float(""-inf"") 

                if a > b or greater(x_num, y_num, i , j):
# greater(x_num, y_num, i , j): this function is meant for check which list has element lexicographically greater means it will iterate through both arrays incrementing both at the same time until one of them is greater than other.
                    chosen = a
                    i += 1
                else:
                    chosen = b
                    j += 1
                s.append(chosen)
            return s

        max_num_arr = []
        for i in range(k+1): # we check for all values of k and find the maximum number we can create for that value of k and we repeat this for all values of k and then at eacch time merge the numbers to check if arrive at optimal solution
            first = maximum_num_each_list(nums1, i)
            second = maximum_num_each_list(nums2, k-i)
            merged = merge(first, second)
            # these two conditions are required because list comparison in python only compares the elements even if one of their lengths is greater, so I had to add these conditions to compare elements only if length is equal.
			# Alternatively you can avoid this and convert them both to int and then compare, but I wanted to this as  it is somewhat more efficient.
            if len(merged) == len(max_num_arr) and  merged > max_num_arr:
                max_num_arr = merged
            elif len(merged) > len(max_num_arr):
                max_num_arr = merged
        return max_num_arr",saqibmubarak
322,https://leetcode.com/problems/coin-change/discuss/2058537/Python-Easy-2-DP-approaches,"class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:        
        dp=[math.inf] * (amount+1)
        dp[0]=0
        
        for coin in coins:
            for i in range(coin, amount+1):
                if i-coin>=0:
                    dp[i]=min(dp[i], dp[i-coin]+1)
        
        return -1 if dp[-1]==math.inf else dp[-1]",constantine786
324,https://leetcode.com/problems/wiggle-sort-ii/discuss/1322709/Definitely-not-O(n)-but-did-it-iteratively-in-O(nlog(N))-time,"class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        sortedList = sorted(nums)
        n = len(nums)
        if n%2==0:
            small = sortedList[:((n//2))][::-1]
            large = (sortedList[(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]
        else:
            small = sortedList[:1+((n//2))][::-1]
            large = (sortedList[1+(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]",prajwalPonnana004
326,https://leetcode.com/problems/power-of-three/discuss/1179790/Simple-Python-Recursive-Solution-with-Explanation,"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n == 1:
            return True
        if n == 0:
            return False
        else:
            return n % 3 == 0 and self.isPowerOfThree(n // 3)",stevenbooke
327,https://leetcode.com/problems/count-of-range-sum/discuss/1195369/Python3-4-solutions,"class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        def fn(lo, hi): 
            """"""Return count of range sum between prefix[lo:hi].""""""
            if lo+1 >= hi: return 0 
            mid = lo + hi >> 1
            ans = fn(lo, mid) + fn(mid, hi)
            k = kk = mid 
            for i in range(lo, mid): 
                while k < hi and prefix[k] - prefix[i] < lower: k += 1
                while kk < hi and prefix[kk] - prefix[i] <= upper: kk += 1
                ans += kk - k 
            prefix[lo:hi] = sorted(prefix[lo:hi])
            return ans 
        
        return fn(0, len(prefix))",ye15
328,https://leetcode.com/problems/odd-even-linked-list/discuss/2458296/easy-approach-using-two-pointer-in-python-With-Comments-TC-%3A-O(N)-SC-%3A-O(1),"class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if(head is None or  head.next is None):
            return head
        # assign odd = head(starting node of ODD)
        # assign even = head.next(starting node of EVEN)
        odd  , even  =  head , head.next
        
        Even = even # keep starting point of Even Node so later we will connect with Odd Node
        while(odd.next and even.next):
            odd.next = odd.next.next # Connect odd.next to odd Node
            even.next = even.next.next # Connect even,next to Even Node
            
            odd = odd.next # move odd 
            even = even.next # move even
        
        odd.next = Even # now connect odd.next to starting point to Even list
        
        return head",rajitkumarchauhan99
329,https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/2052380/Python-DFS-with-Memoization-Beats-~90,"class Solution:
    def longestIncreasingPath(self, grid: List[List[int]]) -> int:
        m,n=len(grid),len(grid[0])
        directions = [0, 1, 0, -1, 0] # four directions 
        
        @lru_cache(maxsize=None) # using python cache lib for memoization
        def dfs(r,c):
            ans=1                  
			# iterating through all 4 directions
            for i in range(4): 
                new_row,new_col=r+directions[i], c+directions[i+1] # calculating the new cell
				# check if new cell is within the grid bounds and is an increasing sequence
                if 0<=new_row<m and 0<=new_col<n and grid[new_row][new_col]>grid[r][c]: 
                    ans = max(ans, dfs(new_row, new_col) + 1 )  # finding the max length of valid path from the current cell                                      
            return ans
        
        return max(dfs(r,c) for r in range(m) for c in range(n))",constantine786
330,https://leetcode.com/problems/patching-array/discuss/1432390/Python-3-easy-solution,"class Solution:
	def minPatches(self, nums: List[int], n: int) -> int:
		ans, total = 0, 0
		num_idx = 0
		while total < n:
			if num_idx < len(nums):
				if total < nums[num_idx] - 1:
					total = total * 2 + 1
					ans += 1
				else:
					total += nums[num_idx]
					num_idx += 1
			else:
				total = total * 2 + 1
				ans += 1
		return ans",Andy_Feng97
331,https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/discuss/1459342/Python3-or-O(n)-Time-and-O(n)-space,"class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        stack = []
        items = preorder.split("","")
        for i, val in enumerate(items):
            if i>0 and not stack:
                return False
            if stack:
                stack[-1][1] -= 1
                if stack[-1][1] == 0:
                    stack.pop()
            if val != ""#"":
                stack.append([val, 2])
        return not stack",Sanjaychandak95
332,https://leetcode.com/problems/reconstruct-itinerary/discuss/1475876/Python-LC-but-better-explained,"class Solution:
    def __init__(self):
        self.path = []
    
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        flights = {}
        
        # as graph is directed
        # => no bi-directional paths
        for t1, t2 in tickets:
            if t1 not in flights:
                flights[t1] = []
                
            flights[t1].append(t2)

        visited = {}
        for k, v in flights.items():
            v.sort()
            visited[k] = [False for _ in range(len(v))]
        
        base_check = len(tickets) + 1
        routes = ['JFK']
        self.dfs('JFK', routes, base_check, flights, visited)
        
        return self.path
        
        
    def dfs(self, curr, routes, base_check, flights, visited):
        if len(routes) == base_check:
            self.path = routes
            return True
        
        # deadlock
        if curr not in flights:
            return False
        
        for idx in range(len(flights[curr])):
            if not visited[curr][idx]:
                visited[curr][idx] = True
                
                next_airport = flights[curr][idx]
                routes += [next_airport]
                result = self.dfs(next_airport, routes, base_check,
                                    flights, visited)
                
                if result:
                    return True
                routes.pop()
                visited[curr][idx] = False

        return False",SleeplessChallenger
334,https://leetcode.com/problems/increasing-triplet-subsequence/discuss/270884/Python-2-solutions%3A-Right-So-Far-One-pass-O(1)-Space-Clean-and-Concise,"class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        n = len(nums)
        maxRight = [0] * n  # maxRight[i] is the maximum element among nums[i+1...n-1]
        maxRight[-1] = nums[-1]
        for i in range(n-2, -1, -1):
            maxRight[i] = max(maxRight[i+1], nums[i+1])
            
        minLeft = nums[0]
        for i in range(1, n-1):
            if minLeft < nums[i] < maxRight[i]:
                return True
            minLeft = min(minLeft, nums[i])
        return False",hiepit
335,https://leetcode.com/problems/self-crossing/discuss/710582/Python3-complex-number-solution-Self-Crossing,"class Solution:
    def isSelfCrossing(self, x: List[int]) -> bool:
        def intersect(p1, p2, p3, p4):
            v1 = p2 - p1
            if v1.real == 0:
                return p1.imag <= p3.imag <= p2.imag and p3.real <= p1.real <= p4.real
            return p3.imag <= p1.imag <= p4.imag and p1.real <= p3.real <= p2.real
        
        def overlap(p1, p2, p3, p4):
            v1 = p2 - p1
            if v1.real == 0:
                return min(p2.imag, p4.imag) >= max(p1.imag, p3.imag) and p1.real == p3.real
            return min(p2.real, p4.real) >= max(p1.real, p3.real) and p1.imag == p3.imag
                
        uv = complex(0, 1)
        p = complex(0, 0)
        segments = deque()
        for s in x:
            segments.append(sorted([p, (np := p + uv * s)], key=lambda x:(x.real, x.imag)))
            if len(segments) > 5 and intersect(*segments[-1], *segments[-6]):
                    return True
            if len(segments) > 4 and overlap(*segments[-1], *segments[-5]):
                    return True
            if len(segments) > 3 and intersect(*segments[-1], *segments[-4]):
                    return True
            if len(segments) == 6:
                segments.popleft()
            p = np
            uv *= complex(0, 1)
        return False",r0bertz
336,https://leetcode.com/problems/palindrome-pairs/discuss/2585442/Intuitive-Python3-or-HashMap-or-95-Time-and-Space-or-O(N*W2),"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])
                
            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])
                res.append([backward[""""], i])
                
            for j in range(len(word)):
                if word[j:] in backward and word[:j] == word[j-1::-1]:
                    res.append([backward[word[j:]], i])
                if word[:j] in backward and word[j:] == word[:j-1:-1]:
                    res.append([i, backward[word[:j]]])
                    
        return res",ryangrayson
337,https://leetcode.com/problems/house-robber-iii/discuss/872676/Python-3-or-DFS-Backtracking-or-Explanation,"class Solution:
    def rob(self, root: TreeNode) -> int:
        def dfs(node):
            if not node: return 0, 0
            left, right = dfs(node.left), dfs(node.right)
            v_take = node.val + left[1] + right[1]
            v_not_take = max(left) + max(right)
            return v_take, v_not_take
        return max(dfs(root))",idontknoooo
338,https://leetcode.com/problems/counting-bits/discuss/466438/Python-clean-no-cheat-easy-to-understand.-Based-on-pattern.-Beats-90.,"class Solution:
    def countBits(self, N: int) -> List[int]:
        stem = [0]
        while len(stem) < N+1:
            stem.extend([s + 1 for s in stem])
            
        return stem[:N+1]",kimonode
342,https://leetcode.com/problems/power-of-four/discuss/772261/Python3-1-liner-99.95-O(1)-explained,"class Solution:
    def isPowerOfFour(self, num: int) -> bool:
        return num > 0 and not num &amp; (num - 1)  and len(bin(num)) % 2",dangtrangiabao
343,https://leetcode.com/problems/integer-break/discuss/2830343/O(1)-oror-TC1-10-line-code,"class Solution:
    def integerBreak(self, n: int) -> int:
        if(n<=3):
            return n-1
        n3=n//3
        r3=n%3
        if(r3==0):
            return 3**n3
        if(r3==1):
            r3=4
            n3-=1
        return r3*(3**n3)",droj
344,https://leetcode.com/problems/reverse-string/discuss/670137/Python-3-~actually~-easiest-solution,"class Solution:
    def reverseString(self, s: List[str]) -> None:
        s[:] = s[::-1]",drblessing
345,https://leetcode.com/problems/reverse-vowels-of-a-string/discuss/1164745/Python-Solution-oror-99.58-faster-oror-86.96-less-memory,"class Solution:
    def reverseVowels(self, s: str) -> str:
        s = list(s)
        left = 0
        right = len(s) - 1
        m = 'aeiouAEIOU'
        while left < right:
            if s[left] in m and s[right] in m:
                
                s[left], s[right] = s[right], s[left]
                
                left += 1; right -= 1
            
            elif s[left] not in m:
                left += 1
            
            elif s[right] not in m:
                right -= 1
            
        return ''.join(s)",KiranUpase
347,https://leetcode.com/problems/top-k-frequent-elements/discuss/1928198/Python-Simple-Python-Solution-Using-Dictionary-(-HashMap-),"class Solution:
	def topKFrequent(self, nums: List[int], k: int) -> List[int]:

		frequency = {}

		for num in nums:

			if num not in frequency:

				frequency[num] = 1

			else:

				frequency[num] = frequency[num] + 1

		frequency = dict(sorted(frequency.items(), key=lambda x: x[1], reverse=True))

		result = list(frequency.keys())[:k]

		return result",ASHOK_KUMAR_MEGHVANSHI
349,https://leetcode.com/problems/intersection-of-two-arrays/discuss/2270388/PYTHON-3-SIMPLE-or-EASY-TO-UNDERSTAND,"class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        a = []
        for i in nums1:
            if i not in a and i in nums2:
                a.append(i)
        return a",omkarxpatel
350,https://leetcode.com/problems/intersection-of-two-arrays-ii/discuss/1231807/easy-or-two-pointer-method-or-python,"class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        
        nums1.sort()
        nums2.sort()
        
        
        one=0
        two=0
        
        ans=[]
        
        while one < len(nums1) and two < len(nums2):
            
            if nums1[one] < nums2[two]:
                one+=1
            elif nums2[two] < nums1[one]:
                two+=1
            else:
                
                ans.append(nums1[one])
                one+=1
                two+=1
        return ans",chikushen99
354,https://leetcode.com/problems/russian-doll-envelopes/discuss/2071626/Python-LIS-based-approach,"class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        envelopes.sort(key=lambda x: (x[0], -x[1]))
        
        res = []		
		# Perform LIS
        for _, h in envelopes:
            l,r=0,len(res)-1
			# find the insertion point in the Sort order
            while l <= r:
                mid=(l+r)>>1
                if res[mid]>=h:
                    r=mid-1
                else:
                    l=mid+1        
            idx = l
            if idx == len(res):
                res.append(h)
            else:
                res[idx]=h
        return len(res)",constantine786
357,https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/2828071/Python3-Mathematics-approach.-Explained-in-details.-Step-by-step,"class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
        if n == 0: return 1
        if n == 1: return 10

        res = 91
        mult = 8
        comb = 81
        for i in range(n - 2):
            comb *=  mult
            mult -= 1
            res += comb

        return res",Alex_Gr
363,https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/2488882/Solution-In-Python,"class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        ans = float(""-inf"")
        m, n = len(matrix), len(matrix[0])
        for i in range(n):
            lstSum = [0] * m
            for j in range(i, n):
                currSum = 0
                curlstSum = [0]
                for t in range(m):
                    lstSum[t] += matrix[t][j]
                    currSum += lstSum[t]
                    pos = bisect_left(curlstSum, currSum - k)
                    if pos < len(curlstSum):
                        if curlstSum[pos] == currSum - k:
                            return k
                        else:
                            ans = max(ans, currSum - curlstSum[pos])
                    insort(curlstSum, currSum)
        return ans",AY_
365,https://leetcode.com/problems/water-and-jug-problem/discuss/393886/Solution-in-Python-3-(beats-~100)-(one-line)-(Math-Solution),"class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        return False if x + y < z else True if x + y == 0 else not z % math.gcd(x,y)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
367,https://leetcode.com/problems/valid-perfect-square/discuss/1063963/100-Python-One-Liner-UPVOTE-PLEASE,"class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return int(num**0.5) == num**0.5",1coder
368,https://leetcode.com/problems/largest-divisible-subset/discuss/1127633/Python-Dynamic-Programming-with-comments,"class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        if not nums or len(nums) == 0:
            return []

        # since we are doing a ""subset"" question
        # sorting does not make any differences
        nums.sort()
        n = len(nums)

        # initilization
        # f[i] represents the size of LDS ended with nums[i]
        f = [1 for _ in range(n)]
        for i in range(1, n):
            for j in range(i):
                # since we have already sorted,
                # then nums[j] % nums[i] will never equals zero
                # unless nums[i] == nums[j]
                if nums[i] % nums[j] == 0:
                    f[i] = max(f[i], f[j] + 1)

        # extract result from dp array
        max_size = max(f)
        max_idx = f.index(max_size) # since we can return one of the largest
        prev_num, prev_size = nums[max_idx], f[max_idx]
        res = [prev_num]
        for curr_idx in range(max_idx, -1, -1):
            if prev_num % nums[curr_idx] == 0 and f[curr_idx] == prev_size - 1:
                # update
                res.append(nums[curr_idx])
                prev_num = nums[curr_idx]
                prev_size = f[curr_idx]

        return res[::-1]",zna2
371,https://leetcode.com/problems/sum-of-two-integers/discuss/1876632/Python-one-line-solution-using-the-logic-of-logs-and-powers,"class Solution:
    def getSum(self, a: int, b: int) -> int:
        return int(math.log2(2**a * 2**b))",alishak1999
372,https://leetcode.com/problems/super-pow/discuss/400893/Python-3-(With-Explanation)-(Handles-All-Test-Cases)-(one-line)-(beats-~97),"class Solution:
    def superPow(self, a: int, b: List[int]) -> int:
        return (a % 1337)**(1140 + int(''.join(map(str, b))) % 1140) % 1337
		
		
- Junaid Mansuri",junaidmansuri
373,https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/1701122/Python-Simple-heap-solution-explained,"class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        hq = []
        heapq.heapify(hq)
        
        # add all the pairs that we can form with
        # all the (first k) items in nums1 with the first
        # item in nums2
        for i in range(min(len(nums1), k)):
            heapq.heappush(hq, (nums1[i]+nums2[0], nums1[i], nums2[0], 0))

        # since the smallest pair will
        # be the first element from both nums1 and nums2. We'll
        # start with that and then subsequently, we'll pop it out
        # from the heap and also insert the pair of the current
        # element from nums1 with the next nums2 element
        out = []
        while k > 0 and hq:
            _, n1, n2, idx = heapq.heappop(hq)
            out.append((n1, n2))
            if idx + 1 < len(nums2):
                # the heap will ensure that the smallest element
                # based on the sum will remain on top and the
                # next iteration will give us the pair we require
                heapq.heappush(hq, (n1+nums2[idx+1], n1, nums2[idx+1], idx+1))
            k -= 1
                
        return out",buccatini
374,https://leetcode.com/problems/guess-number-higher-or-lower/discuss/2717871/DONT-TRY-THIS-CODE-or-ONE-LINE-PYTHON-CODE,"class Solution:
    def guessNumber(self, n: int) -> int:
        return __pick__",raghavdabra
375,https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/1510747/Python-DP-beat-97.52-in-time-99-in-memory-(with-explanation),"class Solution:
    def getMoneyAmount(self, n: int) -> int:
        if n == 1:
            return 1
        starting_index = 1 if n % 2 == 0 else 2
        selected_nums = [i for i in range(starting_index, n, 2)]
        selected_nums_length = len(selected_nums)
        dp = [[0] * selected_nums_length for _ in range(selected_nums_length)]

        for i in range(selected_nums_length):
            dp[i][i] = selected_nums[i]

        for length in range(2, selected_nums_length + 1):
            for i in range(selected_nums_length - length + 1):
                j = i + length - 1
                dp[i][j] = float(""inf"")
                for k in range(i, j + 1):
                    dp_left = dp[i][k - 1] if k != 0 else 0
                    dp_right = dp[k + 1][j] if k != j else 0
                    dp[i][j] = min(dp[i][j], selected_nums[k] + max(dp_left, dp_right))

        return dp[0][-1]",wingskh
376,https://leetcode.com/problems/wiggle-subsequence/discuss/2230152/Beats-73.3-Simple-Python-Solution-Greedy,"class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        length = 0
        curr = 0
        
        for i in range(len(nums) - 1):
            if curr == 0 and nums[i + 1] - nums[i] != 0:
                length += 1
                curr = nums[i + 1] - nums[i]
                
            if curr < 0 and nums[i + 1] - nums[i] > 0:
                length += 1
                curr = nums[i + 1] - nums[i]
                
            elif curr > 0 and nums[i + 1] - nums[i] < 0:
                length += 1
                curr = nums[i + 1] - nums[i]
                
            else:
                continue
                
        return length + 1",7yler
377,https://leetcode.com/problems/combination-sum-iv/discuss/1272869/Python-3-Faster-than-96-(Super-Simple!),"class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        waysToAdd = [0 for x in range(target+1)]
        waysToAdd[0] = 1
        
        for i in range(min(nums), target+1):
            waysToAdd[i] = sum(waysToAdd[i-num] for num in nums if i-num >= 0)
        
        return waysToAdd[-1]",jodoko
378,https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/2233868/Simple-yet-best-Interview-Code-or-Python-Code-beats-90,"class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        
        m = len(matrix)
        n = len(matrix[0])
        
        def count(m):
            c = 0                   # count of element less than equals to 'm'
            i = n-1
            j = 0
            
            while i >= 0 and j < n:
                if matrix[i][j] > m:
                    i -= 1
                else:
                    c += i+1
                    j += 1
            return c
           
        
        low = matrix[0][0]
        high = matrix[n-1][n-1]
        
        while low <= high:
            m = (low+high)//2
            cnt = count(m)
            if cnt < k:
                low = m + 1
            else:
                cnt1 = count(m-1)
                if cnt1 < k:
                    return m
                high = m-1
        return 0",reinkarnation
382,https://leetcode.com/problems/linked-list-random-node/discuss/811617/Python3-reservoir-sampling,"class Solution:

    def __init__(self, head: ListNode):
        """"""
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        """"""
        self.head = head # store head of linked list 

    def getRandom(self) -> int:
        """"""
        Returns a random node's value.
        """"""
        cnt = 0
        node = self.head 
        while node: 
            cnt += 1
            if randint(1, cnt) == cnt: ans = node.val # reservoir sampling 
            node = node.next 
        return ans",ye15
383,https://leetcode.com/problems/ransom-note/discuss/1346131/Easiest-python-solution-faster-than-95,"class Solution:
    def canConstruct(self, ransomNote, magazine):
        for i in set(ransomNote):
            if magazine.count(i) < ransomNote.count(i):
                return False
        return True",mqueue
384,https://leetcode.com/problems/shuffle-an-array/discuss/1673643/Python-or-Best-Optimal-Approach,"class Solution:
	def __init__(self, nums: List[int]):
		self.arr = nums[:]  # Deep Copy, Can also use Shallow Copy concept!
		# self.arr = nums  # Shallow Copy would be something like this!

	def reset(self) -> List[int]:
		return self.arr

	def shuffle(self) -> List[int]:
		ans = self.arr[:]
		for i in range(len(ans)):
			swp_num = random.randrange(i, len(ans))  # Fisher-Yates Algorithm
			ans[i], ans[swp_num] = ans[swp_num], ans[i]
		return ans",leet_satyam
385,https://leetcode.com/problems/mini-parser/discuss/875743/Python3-a-concise-recursive-solution,"class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        if not s: return NestedInteger()
        if not s.startswith(""[""): return NestedInteger(int(s)) # integer 
        ans = NestedInteger()
        s = s[1:-1] # strip outer ""["" and ""]""
        if s: 
            ii = op = 0 
            for i in range(len(s)): 
                if s[i] == ""["": op += 1
                if s[i] == ""]"": op -= 1
                if s[i] == "","" and op == 0: 
                    ans.add(self.deserialize(s[ii:i]))
                    ii = i+1
            ans.add(self.deserialize(s[ii:i+1]))
        return ans",ye15
386,https://leetcode.com/problems/lexicographical-numbers/discuss/2053392/Python-oneliner,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        return sorted([x for x in range(1,n+1)],key=lambda x: str(x))",StikS32
387,https://leetcode.com/problems/first-unique-character-in-a-string/discuss/1793386/Python-Simple-Python-Solution-With-Two-Approach,"class Solution:
	def firstUniqChar(self, s: str) -> int:

		for i in range(len(s)):

			if s[i] not in s[:i] and s[i] not in s[i+1:]:

				return i

		return -1",ASHOK_KUMAR_MEGHVANSHI
388,https://leetcode.com/problems/longest-absolute-file-path/discuss/812407/Python-3-or-Stack-or-Explanation,"class Solution:
    def lengthLongestPath(self, s: str) -> int:
        paths, stack, ans = s.split('\n'), [], 0
        for path in paths:
            p = path.split('\t')
            depth, name = len(p) - 1, p[-1]
            l = len(name)
            while stack and stack[-1][1] >= depth: stack.pop()
            if not stack: stack.append((l, depth))
            else: stack.append((l+stack[-1][0], depth))
            if '.' in name: ans = max(ans, stack[-1][0] + stack[-1][1])   
        return ans",idontknoooo
389,https://leetcode.com/problems/find-the-difference/discuss/379846/Three-Solutions-in-Python-3,"class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
    	s, t = sorted(s), sorted(t)
    	for i,j in enumerate(s):
    		if j != t[i]: return t[i]
    	return t[-1]",junaidmansuri
390,https://leetcode.com/problems/elimination-game/discuss/824126/Python3-3-line-O(logN),"class Solution:
    def lastRemaining(self, n: int) -> int:
        if n == 1: return 1
        if n&amp;1: n -= 1
        return n + 2 - 2*self.lastRemaining(n//2)",ye15
391,https://leetcode.com/problems/perfect-rectangle/discuss/968076/Python-Fast-and-clear-solution-with-explanation,"class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        
        area = 0
        corners = set()
        a = lambda: (Y-y) * (X-x)
        
        for x, y, X, Y in rectangles:
            area += a()
            corners ^= {(x,y), (x,Y), (X,y), (X,Y)}

        if len(corners) != 4: return False
        x, y = min(corners, key=lambda x: x[0] + x[1])
        X, Y = max(corners, key=lambda x: x[0] + x[1])
        return a() == area",modusV
392,https://leetcode.com/problems/is-subsequence/discuss/2473010/Very-Easy-oror-100-oror-Fully-Explained-oror-Java-C%2B%2B-Python-JS-C-Python3-(Two-Pointers-Approach),"class Solution(object):
    def isSubsequence(self, s, t):
        # Base case
        if not s:
            return True
        i = 0
        # Traverse elements of t string
        for j in t:
            # If this index matches to the index of s string, increment i pointer...
            if j == s[i]:
                i += 1
            # If the pointer is equal to the size of s...
            if i == len(s):
                break
        return i == len(s)",PratikSen07
393,https://leetcode.com/problems/utf-8-validation/discuss/2568848/Python3-or-DP-or-Memoization-or-Neat-Solution-or-O(n),"class Solution:
    def validUtf8(self, data: List[int]) -> bool:
        n = len(data)
        l = [2**i for i in range(7, -1, -1)]
        
        def isXByteSeq(pos, X):
            f = data[pos]
            rem = data[pos+1:pos+X]
            ret = (f&amp;l[X]) == 0
            for i in range(X):
                ret &amp;= (f&amp;l[i]) != 0
            for num in rem:
                ret &amp;= (num&amp;l[0]) != 0
                ret &amp;= (num&amp;l[1]) == 0
            return ret
            
        @cache
        def res(pos = 0):
            ret = False
            if pos == n:
                ret = True
            if pos + 3 < n:
                ret |= isXByteSeq(pos, 4) and res(pos + 4)
            if pos + 2 < n:
                ret |= isXByteSeq(pos, 3) and res(pos + 3)
            if pos + 1 < n:
                ret |= isXByteSeq(pos, 2) and res(pos + 2)
            if pos < n:
                ret |= isXByteSeq(pos, 0) and res(pos + 1)
            return ret
        
        return res()",DheerajGadwala
394,https://leetcode.com/problems/decode-string/discuss/1400105/98-faster-oror-With-and-without-Stack-oror-Cleane-and-Concise,"class Solution:
def decodeString(self, s: str) -> str:
    
    res,num = """",0
    st = []
    for c in s:
        if c.isdigit():
            num = num*10+int(c)    
        elif c==""["":
            st.append(res)
            st.append(num)
            res=""""
            num=0
        elif c==""]"":
            pnum = st.pop()
            pstr = st.pop()
            res = pstr + pnum*res
        else:
            res+=c
    
    return res",abhi9Rai
395,https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/discuss/1721267/Faster-than-97.6.-Recursion,"class Solution:
    def rec(self, s, k):
        c = Counter(s)

        if pattern := ""|"".join(filter(lambda x: c[x] < k, c)):
            if arr := list(filter(lambda x: len(x) >= k, re.split(pattern, s))):
            
                return max(map(lambda x: self.rec(x, k), arr))
            
            return 0
        
        return len(s)
    
    def longestSubstring(self, s: str, k: int) -> int:
        return self.rec(s, k)",mygurbanov
396,https://leetcode.com/problems/rotate-function/discuss/857056/Python-3-(Py3.8)-or-Math-O(n)-or-Explanation,"class Solution:
    def maxRotateFunction(self, A: List[int]) -> int:
        s, n = sum(A), len(A)
        cur_sum = sum([i*j for i, j in enumerate(A)])
        ans = cur_sum
        for i in range(n): ans = max(ans, cur_sum := cur_sum + s-A[n-1-i]*n)
        return ans",idontknoooo
397,https://leetcode.com/problems/integer-replacement/discuss/663134/Two-solution-in-Python,"class Solution:
    def integerReplacement(self, n: int) -> int:
        cnt = 0
        while n != 1:
            if n%2 == 0:
                n//=2
            elif n%4 == 1 or n == 3:
                n -= 1
            else:
                n += 1
            cnt += 1
        return cnt",realslimshady
398,https://leetcode.com/problems/random-pick-index/discuss/1671979/Python-3-Reservoir-Sampling-O(n)-Time-and-O(1)-Space,"class Solution:

    def __init__(self, nums: List[int]):
        # Reservoir Sampling (which can handle the linked list with unknown size), time complexity O(n) (init: O(1), pick: O(n)), space complextiy O(1)
        self.nums = nums

    def pick(self, target: int) -> int:
        # https://docs.python.org/3/library/random.html
        count = 0
        chosen_index = None
        for i in range(len(self.nums)):
            if self.nums[i] != target:
                continue
            count += 1
            if count == 1:
                chosen_index = i
            elif random.random() < 1 / count:
                chosen_index = i
        return chosen_index",xil899
399,https://leetcode.com/problems/evaluate-division/discuss/827506/Python3-dfs-and-union-find,"class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        graph = {}
        for (u, v), w in zip(equations, values): 
            graph.setdefault(u, []).append((v, 1/w))
            graph.setdefault(v, []).append((u, w))

        def dfs(n, g, val=1):
            """"""Depth-first traverse the graph.""""""
            if n in vals: return 
            vals[n] = val, g
            for nn, w in graph.get(n, []): dfs(nn, g, w*val)
    
        vals = dict()
        for i, n in enumerate(graph): dfs(n, i)
        
        ans = []
        for u, v in queries: 
            if u in vals and v in vals and vals[u][1] == vals[v][1]: ans.append(vals[u][0]/vals[v][0])
            else: ans.append(-1)
        return ans",ye15
400,https://leetcode.com/problems/nth-digit/discuss/828924/Python3-O(logN)-solution,"class Solution:
    def findNthDigit(self, n: int) -> int:
        digit = base = 1 # starting from 1 digit
        while n > 9*base*digit: # upper limit of d digits 
            n -= 9*base*digit
            digit += 1
            base *= 10 
        q, r = divmod(n-1, digit)
        return int(str(base + q)[r])",ye15
401,https://leetcode.com/problems/binary-watch/discuss/371775/Solution-in-Python-3-(beats-~98)-(one-line),"class Solution:
    def readBinaryWatch(self, n: int) -> List[str]:
    	return [str(h)+':'+'0'*(m<10)+str(m) for h in range(12) for m in range(60) if (bin(m)+bin(h)).count('1') == n]",junaidmansuri
402,https://leetcode.com/problems/remove-k-digits/discuss/1779520/Python3-MONOTONIC-STACK-(oo)-Explained,"class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        st = list()
        for n in num:
            while st and k and st[-1] > n:
                st.pop()
                k -= 1
            
            if st or n is not '0': # prevent leading zeros
                st.append(n)
                
        if k: # not fully spent
			st = st[0:-k]
            
        return ''.join(st) or '0'",artod
403,https://leetcode.com/problems/frog-jump/discuss/418003/11-line-DFS-solution,"class Solution(object):
    def canCross(self, stones):
        n = len(stones)
        stoneSet = set(stones)
        visited = set()
        def goFurther(value,units):
            if (value+units not in stoneSet) or ((value,units) in visited):
                return False
            if value+units == stones[n-1]:
                return True
            visited.add((value,units))
            return goFurther(value+units,units) or goFurther(value+units,units-1) or goFurther(value+units,units+1)
        return goFurther(stones[0],1)",nirajmotiani
404,https://leetcode.com/problems/sum-of-left-leaves/discuss/1558223/Python-DFSRecursion-Easy-%2B-Intuitive,"class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        # does this node have a left child which is a leaf?
        if root.left and not root.left.left and not root.left.right:
			# gotcha
            return root.left.val + self.sumOfLeftLeaves(root.right)

        # no it does not have a left child or it's not a leaf
        else:
			# bummer
            return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)",aayushisingh1703
405,https://leetcode.com/problems/convert-a-number-to-hexadecimal/discuss/1235709/easy-solution-with-explanation,"class Solution:
    def toHex(self, num: int) -> str:
        hex=""0123456789abcdef"" #created string for reference
        ot="""" # created a string variable to store and update output string
        if num==0:
            return ""0""
        elif num<0:
            num+=2**32
        while num:
            ot=hex[num%16]+ot # we update the output string with the reminder of num/16 , 16 because we are dealing with hex.
            num//=16 # now we are updating num by dividing it by 16 ***// operator used for floor division , means division will be always integer not float.
        return ot # then we simply return ot",souravsingpardeshi
406,https://leetcode.com/problems/queue-reconstruction-by-height/discuss/2211602/Python-Easy-Greedy-O(1)-Space-approach,"class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        output=[] 
        
        # sort the array in decreasing order of height 
        # within the same height group, you would sort it in increasing order of k
        # eg: Input : [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
        # after sorting: [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]
        people.sort(key=lambda x: (-x[0], x[1]))                
        for a in people:
            # Now let's start the greedy here
            # We insert the entry in the output array based on the k value
            # k will act as a position within the array
            output.insert(a[1], a)
        
        return output",constantine786
407,https://leetcode.com/problems/trapping-rain-water-ii/discuss/1138028/Python3Visualization-BFS-Solution-With-Explanation,"class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        if not heightMap or not heightMap[0]:
            return 0
			
			
		# Initial
		# Board cells cannot trap the water
        m, n = len(heightMap), len(heightMap[0])
        if m < 3 or n < 3:
            return 0
			
			
		# Add Board cells first
        heap = []
        for i in range(m):
            for j in range(n):
                if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
                    heightMap[i][j] = -1
					
					
		# Start from level 0
        level, res = 0, 0
        
		while heap:
            height, x, y = heapq.heappop(heap)
            level = max(height, level)

            for i, j in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                if 0 <= i < m and 0 <= j < n and heightMap[i][j] != -1:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
					
					# If cell's height smaller than the level, then it can trap the rain water
                    if heightMap[i][j] < level:
                        res += level - heightMap[i][j]
						
					# Set the height to -1 if the cell is visited
                    heightMap[i][j] = -1

        return res",Picassos_Shoes
409,https://leetcode.com/problems/longest-palindrome/discuss/2221045/Python-oror-counter-oror-explanation,"class Solution:
    def longestPalindrome(self, s: str) -> int:
        oddFlag=0
        
        count=collections.Counter(s)

        ans=0
        for k,v in count.items():
            if v%2==1:
                ans+=v-1
                oddFlag= 1
            else:
                ans+=v
                
        if oddFlag == 1:
            return ans+1
        return ans",palashbajpai214
410,https://leetcode.com/problems/split-array-largest-sum/discuss/1901138/Python-Short-and-Simple-NLogSum,"class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:
        def isPossible(maxSum):
            curr = count = 0
            for i in nums:
                count += (i + curr > maxSum)
                curr = curr + i if i + curr <= maxSum else i
            return count + 1 <= m
        
        lo, hi = max(nums), sum(nums)
        while lo <= hi:
            mid = (lo + hi) // 2
            if isPossible(mid): hi = mid - 1
            else: lo = mid + 1
        return lo",dhananjay79
412,https://leetcode.com/problems/fizz-buzz/discuss/380065/Solution-in-Python-3-(beats-~98)-(one-line),"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
    	return ['FizzBuzz' if i%15 == 0 else 'Buzz' if i%5 == 0 else 'Fizz' if i%3 == 0 else str(i) for i in range(1,n+1)]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
413,https://leetcode.com/problems/arithmetic-slices/discuss/1816132/beginners-solution-Easy-to-understand,"class Solution:
       def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums)-2):
            j = i+1
            while(j<len(nums)-1):
                if nums[j]-nums[j-1] == nums[j+1]-nums[j]:
                    count += 1
                    j += 1
                else:
                    break
        return count",harshsatpute16201
414,https://leetcode.com/problems/third-maximum-number/discuss/352011/Solution-in-Python-3-(beats-~99)-(-O(n)-),"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
    	n, T = list(set(nums)), [float('-inf')]*3
    	for i in n:
    		if i > T[0]:
    			T = [i,T[0],T[1]]
    			continue
    		if i > T[1]:
    			T = [T[0],i,T[1]]
    			continue
    		if i > T[2]:
    			T = [T[0],T[1],i]
    	return T[2] if T[2] != float('-inf') else T[0]
		
		
- Junaid Mansuri",junaidmansuri
415,https://leetcode.com/problems/add-strings/discuss/1591891/Python-Straightforward-Solution-or-Easy-to-Understand,"class Solution:
	def addStrings(self, num1: str, num2: str) -> str:
		num1 = list(num1)
		num2 = list(num2)
		car = 0
		res = """"
		while num1 or num2 or car:
			if num1:
				car += int(num1.pop())
			if num2:
				car += int(num2.pop())
			res += str((car % 10))
			car //= 10
		return res[::-1]",leet_satyam
416,https://leetcode.com/problems/partition-equal-subset-sum/discuss/1624391/Python-DP-and-DFS-Solutions-Easy-to-understand-with-Explanation,"class Solution:
    def canPartition(self, nums: List[int]) -> bool:
	    if sum(nums)%2:  # or if sum(nums)&amp;1
		    return False
		# main logic here",zayne-siew
417,https://leetcode.com/problems/pacific-atlantic-water-flow/discuss/2507252/PYTHON-oror-EXPLAINED-oror,"class Solution:
    def pacificAtlantic(self, ht: List[List[int]]) -> List[List[int]]:
        
        def pac(i,j):
            if rp[i][j]:
                return True
            k=False
            h=ht[i][j]
            ht[i][j]=100001
            if ht[i-1][j]<=h:
                k=k or pac(i-1,j)
                
            if ht[i][j-1]<=h:
                k=k or pac(i,j-1)
                
            if i<m-1 and ht[i+1][j]<=h:
                k=k or pac(i+1,j)
                
            if j<n-1 and ht[i][j+1]<=h:
                k=k or pac(i,j+1)
                
            ht[i][j]=h
            rp[i][j]=k
            return k
        
        def ant(i,j):
            if ra[i][j]:
                return True
            k=False
            h=ht[i][j]
            ht[i][j]=100001
            if i>0 and ht[i-1][j]<=h:
                k=k or ant(i-1,j)
                
            if j>0 and ht[i][j-1]<=h:
                k=k or ant(i,j-1)
                
            if ht[i+1][j]<=h:
                k=k or ant(i+1,j)
                
            if ht[i][j+1]<=h:
                k=k or ant(i,j+1)
                
            ht[i][j]=h
            ra[i][j]=k
            return k
        
        m=len(ht)
        n=len(ht[0])
        rp=[[False for i in range(n)] for j in range(m)]
        ra=[[False for i in range(n)] for j in range(m)]
        
        for i in range(m):
            rp[i][0]=True
            ra[i][-1]=True
        for i in range(n):
            rp[0][i]=True
            ra[-1][i]=True
        
        for i in range(m):
            for j in range(n):
                pac(i,j)
                ant(i,j)
        res=[]
        for i in range(m):
            for j in range(n):
                if rp[i][j] and ra[i][j]:
                    res.append([i,j])
        return res",karan_8082
419,https://leetcode.com/problems/battleships-in-a-board/discuss/1523048/Simple-Easy-to-Understand-Python-O(1)-extra-memory,"class Solution:
    def countBattleships(self, board: List[List[str]]) -> int:
        count = 0
        for r in range(len(board)):
            for c in range(len(board[0])):
                if board[r][c] == 'X':
                    var = 1
                    if (r > 0 and board[r-1][c] == 'X') or (c > 0 and board[r][c-1] == 'X'):
                        var = 0
                    count += var
        return count",bshien
420,https://leetcode.com/problems/strong-password-checker/discuss/2345991/Runtime%3A-23-ms-or-Memory-Usage%3A-13.9-MB-or-python3,"class Solution:
    def strongPasswordChecker(self, password: str) -> int:
        #vimla_kushwaha
        s = password
        missing_type = 3
        if any('a' <= c <= 'z' for c in s): missing_type -= 1
        if any('A' <= c <= 'Z' for c in s): missing_type -= 1
        if any(c.isdigit() for c in s): missing_type -= 1

        change = 0
        one = two = 0
        p = 2
        while p < len(s):
            if s[p] == s[p-1] == s[p-2]:
                length = 2
                while p < len(s) and s[p] == s[p-1]:
                    length += 1
                    p += 1
                    
                change += length // 3
                if length % 3 == 0: one += 1
                elif length % 3 == 1: two += 1
            else:
                p += 1
        
        if len(s) < 6:
            return max(missing_type, 6 - len(s))
        elif len(s) <= 20:
            return max(missing_type, change)
        else:
            delete = len(s) - 20
            
            change -= min(delete, one)
            change -= min(max(delete - one, 0), two * 2) // 2
            change -= max(delete - one - 2 * two, 0) // 3
                
            return int(delete + max(missing_type, change))",vimla_kushwaha
421,https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/404504/Python-O(N)-Trie-Solution-wcomments-and-explanations,"class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        # need to know the largest binary representation
		# bin prepends '0b', ignore
		L = len(bin(max(nums))) - 2

		# preprocess step - left-pad zeros to ensure each number has L bits
		# (x >> i) &amp; 1 produces the bit at position i for number x
		# x's value is moved right by i bits, we &amp; 1 to produce 0 or 1
		# e.g., if L = 5, then 3 = [0, 0, 0, 1, 1], so the steps to get there are:
		# (3 >> 4) &amp; 1 = 0
		# (3 >> 3) &amp; 1 = 0
		# (3 >> 2) &amp; 1 = 0
		# (3 >> 1) &amp; 1 = 1
		# (3 >> 0) &amp; 1 = 1
		nums_bits = [[(x >> i) &amp; 1 for i in reversed(range(L))] for x in nums]
		root = {}
		# build the trie
		for num, bits in zip(nums, nums_bits):
			node = root
			for bit in bits:
				node = node.setdefault(bit, {})
			node[""#""] = num

		max_xor = 0
		for num, bits in zip(nums, nums_bits):
			node = root
			# we want to find the node that will produce the largest XOR with num
			for bit in bits:
				# our goal is to find the opposite bit, e.g. bit = 0, we want 1
				# this is our goal because we want as many 1's as possible
				toggled_bit = 1 - bit
				if toggled_bit in node:
					node = node[toggled_bit]
				else:
					node = node[bit]
			# we're at a leaf node, now we can do the XOR computation
			max_xor = max(max_xor, node[""#""] ^ num)


        return max_xor",crippled_baby
423,https://leetcode.com/problems/reconstruct-original-digits-from-english/discuss/1556493/Python3-One-pass-solution,"class Solution:
    def originalDigits(self, s: str) -> str:
        c = collections.Counter(s)
        
        digit_count = [0] * 10
        digit_count[0] = c['z']
        digit_count[2] = c['w']
        digit_count[4] = c['u']
        digit_count[6] = c['x']
        digit_count[8] = c['g']
        
        digit_count[3] = c['h'] - digit_count[8]
        digit_count[5] = c['f'] - digit_count[4]
        digit_count[7] = c['s'] - digit_count[6]
        
        digit_count[9] = c['i'] - digit_count[5] - digit_count[6] - digit_count[8]
        digit_count[1] = c['n'] - digit_count[9] * 2 - digit_count[7]
        
        return """".join([str(idx) * cnt for idx, cnt in enumerate(digit_count) if cnt > 0])",maosipov11
424,https://leetcode.com/problems/longest-repeating-character-replacement/discuss/900524/Simple-Python-solution-moving-window-O(n)-time-O(1)-space,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        
        # Maintain a dictionary that keeps track of last 'window' characters
        # See if 'window' size minus occurrences of the most common char is <= k, if so it's valid
        # Run time is O(length of string * size of alphabet)
		# Space is O(size of alphabet)
        
        d = {}
        window = 0
        
        for i, char in enumerate(s):
            d[char] = d.get(char, 0) + 1
            if window+1 - max(d.values()) <= k:
                window += 1
            else:
                d[s[i-window]] -= 1
        
        return window",wesleyliao3
433,https://leetcode.com/problems/minimum-genetic-mutation/discuss/2769493/SIMPLE-PYTHON-SOLUTION-USING-BFS,"class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        dic=defaultdict(lambda :0)
        lst=[[start,0]]
        dic[start]=1
        while lst:
            x,d=lst.pop(0)
            if x==end:
                return d
            for i in range(len(bank)):
                ct=0
                for j in range(8):
                    if x[j]!=bank[i][j]:
                        ct+=1
                if ct==1:
                    if dic[bank[i]]==0:
                        lst.append([bank[i],d+1])
                        dic[bank[i]]=1
        return -1",beneath_ocean
434,https://leetcode.com/problems/number-of-segments-in-a-string/discuss/1015806/One-Line-python-Solution,"class Solution:
    def countSegments(self, s: str) -> int:
        return len([i for i in s.split("" "") if i!=""""])",moazmar
435,https://leetcode.com/problems/non-overlapping-intervals/discuss/1896849/Python-easy-to-read-and-understand-or-sorting,"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[1])
        n = len(intervals)
        ans, curr = 1, intervals[0]

        for i in range(n):
            if intervals[i][0] >= curr[1]:
                ans += 1
                curr = intervals[i]

        return n - ans",sanial2001
436,https://leetcode.com/problems/find-right-interval/discuss/2812012/Python-Sort-and-Two-Pointers-(Same-approach-as-826.-Most-Profit-Assigning-Work),"class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:
        start = sorted([[intervals[i][0], i] for i in range(len(intervals))])
        end = sorted([[intervals[i][1], i] for i in range(len(intervals))])
        i = 0
        res = []
        for endVal, endIdx in end:
            while i < len(start) and (endVal > start[i][0]):
                i += 1
            if i < len(start):
                res.append(start[i][1])
            else:
                while len(res) < len(start):
                    res.append(-1)
        ans = []
        for i in range(len(end)):
            ans.append((end[i][1], res[i]))
        ans.sort()
        return [ele[1] for ele in sorted([[a[1], b] for a, b in zip(end, res)])]",low_key_low_key
437,https://leetcode.com/problems/path-sum-iii/discuss/1049652/Python-Solution,"class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        
        global result
        result = 0
        
        def dfs(node, target):
            if node is None: return
            find_path_from_node(node, target)
            dfs(node.left, target)
            dfs(node.right, target)
                
        def find_path_from_node(node, target):
            global result
            if node is None: return
            if node.val == target: result += 1
            find_path_from_node(node.left, target-node.val)
            find_path_from_node(node.right, target-node.val)
            
        dfs(root, sum)
        
        return result",dev-josh
438,https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/1738367/Python-Sliding-Window(-)-algorithm-Detailed-Explanation-Concise-Soln-or-Faster-than-80,"class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]: 
        # take counter of first n elements in s_dict with n = len(p) - 1
        s_dict = collections.Counter(s[:len(p)-1]) 
        # counter of p, this should not be changed
        p_dict = collections.Counter(p)
        start = 0
        # final result list
        res = []
        # We iterate over the string s, and in each step we check if s_dict and p_dict match
        for i in range(len(p)-1, len(s)):
            # updating the counter &amp; adding the character
            s_dict[s[i]] += 1
            # checking if counters match
            if s_dict == p_dict:
                res.append(start)
            # remove the first element from counter
            s_dict[s[start]] -= 1
            #if element count = 0, pop it from the counter
            if s_dict[s[start]] == 0:
                del s_dict[s[start]]
            start += 1
            
        return res",mystic_sd2001
440,https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/discuss/1608540/Python3-traverse-denary-trie,"class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        
        def fn(x): 
            """"""Return node counts in denary trie.""""""
            ans, diff = 0, 1
            while x <= n: 
                ans += min(n - x + 1, diff)
                x *= 10 
                diff *= 10 
            return ans 
        
        x = 1
        while k > 1: 
            cnt = fn(x)
            if k > cnt: k -= cnt; x += 1
            else: k -= 1; x *= 10 
        return x",ye15
441,https://leetcode.com/problems/arranging-coins/discuss/2801813/Python-Simple-Binary-Search,"class Solution:
    def arrangeCoins(self, n: int) -> int:

        first = 1
        last = n
        if n==1:
            return 1
        while first <= last:
            mid = (first+last)//2

            if mid*(mid+1) == 2*n:
                return mid
            elif mid*(mid+1) > 2*n:
                last = mid-1
            else:
                first = mid+1
        return last",BhavyaBusireddy
442,https://leetcode.com/problems/find-all-duplicates-in-an-array/discuss/396890/Two-Solutions-in-Python-3-(-O(n)-time-)-(-O(1)-space-),"class Solution:
    def findDuplicates(self, N: List[int]) -> List[int]:
        S, A = set(), []
        for n in N:
            if n in S: A.append(n)
            else: S.add(n)
        return A",junaidmansuri
443,https://leetcode.com/problems/string-compression/discuss/1025555/Python3-Simple-and-Intuitive,"class Solution:
    def compress(self, chars: List[str]) -> int:
        if not chars:
            return 0
        mychar = chars[0]
        count = 0
        length = len(chars)
        chars.append("" "") # Append a space so last char group is not left out in loop
        for i in range(length+1): #+1 for extra space char we added
            char = chars.pop(0)
            if char == mychar: #if same character then just increase the count
                count += 1
            else:
                if count == 1: #if not same then append the char to chars
                    chars.append(mychar) #if count is 1 don't append count
                elif count > 1:
                    chars.append(mychar)
                    chars += (list(str(count))) #if count > 1 append count as a string
                mychar = char #update mychar as the new different char in chars
                count = 1 #reset count to 1 as we have already read the new char
        return len(chars) #since all previous are popped, only the answer remains in chars now",upenj
445,https://leetcode.com/problems/add-two-numbers-ii/discuss/486730/Python-Using-One-Stack-Memory-Usage%3A-Less-than-100,"class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
	
        n1 = n2 = 0
        ptr1, ptr2 = l1, l2
        stack = []
        
        while ptr1: n1 += 1; ptr1 = ptr1.next
        while ptr2: n2 += 1; ptr2 = ptr2.next
        max_len = max(n1, n2)
        
        while max_len:
            a = b = 0
            if max_len <= n1: a = l1.val; l1 = l1.next
            if max_len <= n2: b = l2.val; l2 = l2.next
            stack.append(a + b)
            max_len -= 1
        
        sumval, head = 0, None
        while stack or sumval:
            if stack: sumval += stack.pop()
            node = ListNode(sumval % 10)
            node.next = head
            head = node
            sumval //= 10
        return head",mmbhatk
446,https://leetcode.com/problems/arithmetic-slices-ii-subsequence/discuss/1292744/Python3-freq-tables,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        ans = 0 
        freq = [defaultdict(int) for _ in range(len(nums))] # arithmetic sub-seqs
        for i, x in enumerate(nums): 
            for ii in range(i): 
                diff = x - nums[ii]
                ans += freq[ii].get(diff, 0)
                freq[i][diff] += 1 + freq[ii][diff]
        return ans",ye15
447,https://leetcode.com/problems/number-of-boomerangs/discuss/355205/Solution-in-Python-3,"class Solution:
    def numberOfBoomerangs(self, p: List[List[int]]) -> int:
        L, t = len(p), 0
        D = [[0]*L for i in range(L)]
        for i in range(L):
        	E = {}
        	for j in range(L):
        		if j > i: D[i][j] = D[j][i] = (p[j][0]-p[i][0])**2 + (p[j][1]-p[i][1])**2
        		E[D[i][j]] = E[D[i][j]] + 1 if D[i][j] in E else 1
        	t += sum(r*(r-1) for r in E.values())
        return t
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
448,https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/313703/Python-3,"class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for n in nums:
            a = abs(n) - 1
            if nums[a] > 0: nums[a] *= -1
        return [i+1 for i in range(len(nums)) if nums[i] > 0]",slight_edge
450,https://leetcode.com/problems/delete-node-in-a-bst/discuss/543124/Python-O(-h-)-with-BST-property.-85%2B-w-Comment,"class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        
        if not root:
            return None
            
        if root.val > key:
		    # Target node is smaller than currnet node, search left subtree
			
            root.left = self.deleteNode( root.left, key )

        elif root.val < key:
		    # Target node is larger than currnet node, search right subtree
			
            root.right = self.deleteNode( root.right, key )

        else:
            # Current node is target node
			
            if (not root.left) or (not root.right):
                # At least one child is empty
                # Target node is replaced by either non-empty child or None
                root = root.left if root.left else root.right

            else:
                # Both two childs exist
                # Target node is replaced by smallest element of right subtree
                cur = root.right

                while cur.left:
                    cur = cur.left

                root.val = cur.val
                root.right = self.deleteNode( root.right, cur.val )
                    
        return root",brianchiang_tw
451,https://leetcode.com/problems/sort-characters-by-frequency/discuss/1024318/Python3-Solution-or-24-MS-Runtime-or-15.2-MB-Memoryor-Easy-to-understand-solution,"class Solution:
    def frequencySort(self, s: str) -> str:
        
        ans_str = ''
        # Find unique characters
        characters = set(s)
        
        counts = []
        # Count their frequency
        for i in characters:
            counts.append([i,s.count(i)])
        
		# Sort characters according to their frequency
        counts = sorted(counts, key= lambda x: x[1], reverse = True)
        
		# Generate answer string by multiplying frequency count with the character
        for i,j in counts:
            ans_str += i*j
        
        return ans_str",dakshal33
452,https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/discuss/1686588/Python3-COMBO-Explained,"class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        pts = sorted(points, key=lambda el: el[1])
        
        res, combo = 0, (float(""-inf""), float(""-inf""))
        for start, end in pts:
            if start <= combo[1]: # overlaps?
                combo = (max(combo[0], start), min(combo[1], end))
            else:
                combo = (start, end)
                res += 1
                
        return res",artod
453,https://leetcode.com/problems/minimum-moves-to-equal-array-elements/discuss/1909521/1-line-solution-beats-98-O(N)-time-and-96-O(1)-space-easy-to-understand,"class Solution:
    def minMoves(self, nums: List[int]) -> int:
        return sum(nums) - (len(nums) * min(nums))",sahajamatya
454,https://leetcode.com/problems/4sum-ii/discuss/1741072/Python-Clean-and-concise-or-Detail-explanation-or-One-linear,"class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        
        # hashmap and final result count
        nums12, res = defaultdict(int), 0
        
        # storing all possible combinations of sum
        for i in nums1:
            for j in nums2:
                nums12[i+j] += 1
        
        # iterating the left out two array to find negation of same value
        for k in nums3:
            for l in nums4:
                res += nums12[-(k+l)]
        
        return res",sidheshwar_s
455,https://leetcode.com/problems/assign-cookies/discuss/1334075/Python-Solution-or-Two-Pointers-or-O(nlogn),"class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()  # O(nlogn)
        s.sort()  # O(nlogn)
        
        child_point = 0
        cookie_point = 0
        counter = 0
        
        # O(n)
        while child_point < len(g) and cookie_point < len(s):
            if g[child_point] <= s[cookie_point]:
                counter += 1
                child_point += 1
                cookie_point += 1
            else:
                cookie_point += 1
            
        return counter",peatear-anthony
456,https://leetcode.com/problems/132-pattern/discuss/2015125/Python-Solution-using-Stack,"class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        if len(nums)<3:
            return False
      
        second_num = -math.inf
        stck = []
        # Try to find nums[i] < second_num < stck[-1]
        for i in range(len(nums) - 1, -1, -1):
            if nums[i] < second_num:
                return True
            # always ensure stack can be popped in increasing order
            while stck and stck[-1] < nums[i]:
				second_num = stck.pop()  # this will ensure  second_num < stck[-1] for next iteration

            stck.append(nums[i])
        return False",constantine786
457,https://leetcode.com/problems/circular-array-loop/discuss/1317119/Python-3-or-Short-Python-Set-or-Explanation,"class Solution:
    def circularArrayLoop(self, nums: List[int]) -> bool:
        n, visited = len(nums), set()
        for i in range(n):
            if i not in visited:
                local_s = set()
                while True:
                    if i in local_s: return True
                    if i in visited: break          # credit to @crazyhyz, add this condition to avoid revisited
                    visited.add(i)
                    local_s.add(i)
                    prev, i = i, (i + nums[i]) % n
                    if prev == i or (nums[i] > 0) != (nums[prev] > 0): break
        return False",idontknoooo
458,https://leetcode.com/problems/poor-pigs/discuss/935581/C%2B%2BPythonPicture-1-line-greedy-solution-with-N-dimension-puzzle-cube-scan,"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));",codedayday
459,https://leetcode.com/problems/repeated-substring-pattern/discuss/2304034/Python-93.74-fasters-or-Python-Simplest-Solution-With-Explanation-or-Beg-to-adv-or-Slicing,"class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        return s in s[1:] + s[:-1]",rlakshay14
461,https://leetcode.com/problems/hamming-distance/discuss/1585601/Handmade-binary-function-(time%3A-O(L)),"class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        def get_bin(num):
            res = []
            while num > 0:
                res.append(num % 2)
                num //= 2
            return ''.join(str(num) for num in res[::-1])
        
        if x < y:
            x, y = y, x
        
        bin_x, bin_y = get_bin(x), get_bin(y)
        res = 0
        s1, s2 = len(bin_x), len(bin_y)
        bin_y = '0' * (s1 - s2) + bin_y
        
        return sum(bin_x[i] != bin_y[i] for i in range(s1))",kryuki
462,https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/discuss/2218363/Python3-simple-solution%3A-Get-the-mid-element-from-the-sorted-array,"class Solution:
    def minMoves2(self, nums: List[int]) -> int:
        nums.sort()
        mid = nums[len(nums)//2]
        result = 0
        for i in nums:
            result+=abs(mid-i)
        return result",Dark_wolf_jss
463,https://leetcode.com/problems/island-perimeter/discuss/343154/Solution-in-Python-3,"class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int: 
    	M, N, p = len(grid), len(grid[0]), 0
    	for m in range(M):
    		for n in range(N):
    			if grid[m][n] == 1:
    				if m == 0   or grid[m-1][n] == 0: p += 1
    				if n == 0   or grid[m][n-1] == 0: p += 1
    				if n == N-1 or grid[m][n+1] == 0: p += 1
    				if m == M-1 or grid[m+1][n] == 0: p += 1
    	return p
		
			
- Junaid Mansuri
- Chicago, IL",junaidmansuri
464,https://leetcode.com/problems/can-i-win/discuss/850051/Python3-top-down-dp,"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        if desiredTotal == 0: return True # edge case 1
        if maxChoosableInteger * (maxChoosableInteger+1)//2 < desiredTotal: return False # edge case 2
        
        @lru_cache(None)
        def fn(mask, total): 
            """"""Return True if there is a winning strategy given mask &amp; total.""""""
            if total <= 0: return False # already lost 
            for i in range(maxChoosableInteger): 
                if mask &amp; (1 << i): # integer i+1 is not used yet 
                    if not fn(mask ^ (1 << i), total - (i + 1)): return True 
            return False 
        
        return fn(int(""1""*maxChoosableInteger, 2), desiredTotal)",ye15
466,https://leetcode.com/problems/count-the-repetitions/discuss/2521184/Python3-repeating-patterns,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
        cnt = idx = 0 
        count = []
        index = []
        for i in range(n1): 
            for ch in s1: 
                if ch == s2[idx]: 
                    idx += 1
                    if idx == len(s2): 
                        cnt += 1
                        idx = 0 
            count.append(cnt)
            index.append(idx)
            for ii in range(i): 
                if index[ii] == idx: 
                    prev = count[ii]
                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))
                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]
                    return (prev + repeat + post) // n2
        return count[-1]//n2",ye15
467,https://leetcode.com/problems/unique-substrings-in-wraparound-string/discuss/1705570/Python3-DP-O(N)-time-O(1)-space,"class Solution:
    def findSubstringInWraproundString(self, p: str) -> int:
        consecutive = 1
        
        # stores the maximum length of a substring ending at a character 
        maxSubstr = defaultdict(int)
        maxSubstr[p[0]] = 1
        
        ans = 0
        for x in range(1, len(p)):
            if ord(p[x]) - ord(p[x - 1]) == 1 or p[x] == 'a' and p[x - 1] == 'z':
                consecutive += 1
            else:
                consecutive = 1
            maxSubstr[p[x]] = max(maxSubstr[p[x]], consecutive)
        
        return sum(maxSubstr.values())",srihariv
468,https://leetcode.com/problems/validate-ip-address/discuss/2440773/Python-or-Easiest-solution-Faster-than-99-or-easy-if-and-else,"class Solution:
	def validIPAddress(self, query: str) -> str:
		dot = query.count(""."")
		colon = query.count("":"")
		if colon == 0 and dot == 3:
			arr = [i for i in query.split(""."")]
			print(arr)
			flag = True
			for i in arr:
				if i.isdigit() and int(i) <= 255:
					x = int(i)
					if str(x) != i:
						flag = False
						break
				else:
					flag = False
					break
			if flag:
				return ""IPv4""
			else:
				return ""Neither""
		elif colon == 7 and dot == 0:
			flag = True
			arr = [i for i in query.split("":"")]
			for parts in arr:
				l = 0
				for i in parts:
					l += 1
					if i not in ""0123456789abcdefABCDEF"":
						flag = False
						break
				if l > 4 or l < 1:flag = False;break
			if flag:
				return ""IPv6""
			else:
				return ""Neither""

		else:
			return ""Neither""",sami2002
472,https://leetcode.com/problems/concatenated-words/discuss/2189673/Python3-TRIE-WITH-RECURSION-(-)-Explained,"class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        ddic = lambda: defaultdict(ddic)
        trie = ddic()
        
        for word in words:
            cur = trie
            for char in word:
                cur = cur[char]

            cur['end'] = True
        
        def isConcat(word, start):
            cur = trie
            for i in range(start, len(word)):
                char = word[i]
                if char not in cur:
                    return False
                cur = cur[char]

                if 'end' in cur:
                    if i + 1 == len(word):
                        # tricky part that helps us distinguish simple word from concat word
                        return start != 0
                    
                    if isConcat(word, i + 1):
                        return True

            return False
            
        return [word for word in words if isConcat(word, 0)]",artod
473,https://leetcode.com/problems/matchsticks-to-square/discuss/2270373/Python-3DP-%2B-Bitmask,"class Solution:
    def makesquare(self, arr: List[int]) -> bool:
		# no way to make the square if total length not divisble by 4
        if sum(arr) % 4:
            return False
        
		# target side length
        side = sum(arr) // 4
        
        @lru_cache(None)
        def dp(k, mask, s):
			# finish all four sides
            if k == 4:
                return True
			# move on to next side if current one finished
            if not s:
                return dp(k+1, mask, side)
            
            for i in range(len(arr)):
				# if current matchstick used or longer than remaining side length to fill then skip
                if mask &amp; (1 << i) or s < arr[i]: continue
                if dp(k, mask ^ (1 << i), s - arr[i]):
                    return True
            return False
        
        return dp(0, 0, side)",chestnut890123
474,https://leetcode.com/problems/ones-and-zeroes/discuss/2065208/Python-Easy-DP-2-approaches,"class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        counter=[[s.count(""0""), s.count(""1"")] for s in strs]
        
        @cache
        def dp(i,j,idx):
            if i<0 or j<0:
                return -math.inf
            
            if idx==len(strs):
                return 0
            
            return max(dp(i,j,idx+1), 1 + dp(i-counter[idx][0], j-counter[idx][1], idx+1))
        return dp(m,n,0)",constantine786
475,https://leetcode.com/problems/heaters/discuss/2711430/python-99.84-speed-O(1)-memory,"class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()

        if len(heaters) == 1:
            return max(abs(houses[0] - heaters[0]), abs(houses[-1] - heaters[0]))

        m_value = -1
        f, s, ind_heat = heaters[0], heaters[1], 2
        for i in range(len(houses)):
            while houses[i] > s and ind_heat < len(heaters):
                f, s = s, heaters[ind_heat]
                ind_heat += 1
            m_value = max(m_value, min(abs(houses[i] - f), abs(houses[i] - s)))
        return m_value",Yaro1
476,https://leetcode.com/problems/number-complement/discuss/488055/Python-O(-lg-n-)-sol.-by-XOR-masking.-85%2B-With-explanation,"class Solution:
    def findComplement(self, num: int) -> int:
        
        bit_mask = 2**num.bit_length() -1 
        
        return ( num ^ bit_mask )",brianchiang_tw
477,https://leetcode.com/problems/total-hamming-distance/discuss/851194/Python-3-or-Bit-Manipulation-O(N)-or-Explanations,"class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32):
            zero = one = 0
            mask = 1 << i
            for num in nums:
                if mask &amp; num: one += 1
                else: zero += 1    
            ans += one * zero        
        return ans",idontknoooo
479,https://leetcode.com/problems/largest-palindrome-product/discuss/1521512/Python3-Solution-with-explanation,"class Solution:
    def largestPalindrome(self, n: int) -> int:
        
        # just to forget about 1-digit case
        if n == 1:
            return 9
        
        # minimal number with n digits (for ex. for n = 4, min_num = 1000)
        min_num = 10 ** (n - 1)
        
        # maximal number with n digits (for ex. 9999)
        max_num = 10 ** n - 1       
        
        max_pal = 0
        
        # step is equal to 2, because we have to get a number, the 1st digit of which is 9, so we have to   
		# iterate only over odd numbers
        for i in range(max_num, min_num - 1, -2): 
            
            # since we are looking for the maximum palindrome number, it makes no sense to iterate over the 
            # product less than the max_pal obtained from the last iteration
            if i * i < max_pal:
                break
                
            for j in range(max_num, i - 1, -2):
                product = i * j
                
                # since a palindrome with an even number of digits must be mod 11 == 0 and we have no reason to 
                # check the product which less or equal than max_pal
                if product % 11 != 0 and product >= max_pal:
                    continue
                    
                # check if product is a palindrome then update the max_pal
                if str(product) == str(product)[::-1]:
                    max_pal = product

        return max_pal % 1337",frolovdmn
480,https://leetcode.com/problems/sliding-window-median/discuss/1942580/Easiest-Python-O(n-log-k)-Two-Heaps-(Lazy-Removal)-96.23,"class Solution:
    # TC - O((n - k)*log(k))
    # SC - O(k)
	# 121 ms, faster than 96.23%

    def find_median(self, max_heap, min_heap, heap_size):
        if heap_size % 2 == 1:
            return -max_heap[0]
        else:
            return (-max_heap[0] + min_heap[0]) / 2

    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        max_heap = []
        min_heap = []
        heap_dict = defaultdict(int)
        result = []
        
        for i in range(k):
            heappush(max_heap, -nums[i])
            heappush(min_heap, -heappop(max_heap))
            if len(min_heap) > len(max_heap):
                heappush(max_heap, -heappop(min_heap))
        
        median = self.find_median(max_heap, min_heap, k)
        result.append(median)
        
        for i in range(k, len(nums)):
            prev_num = nums[i - k]
            heap_dict[prev_num] += 1

            balance = -1 if prev_num <= median else 1
            
            if nums[i] <= median:
                balance += 1
                heappush(max_heap, -nums[i])
            else:
                balance -= 1
                heappush(min_heap, nums[i])
            
            if balance < 0:
                heappush(max_heap, -heappop(min_heap))
            elif balance > 0:
                heappush(min_heap, -heappop(max_heap))

            while max_heap and heap_dict[-max_heap[0]] > 0:
                heap_dict[-max_heap[0]] -= 1
                heappop(max_heap)
            
            while min_heap and heap_dict[min_heap[0]] > 0:
                heap_dict[min_heap[0]] -= 1
                heappop(min_heap)

            median = self.find_median(max_heap, min_heap, k)
            result.append(median)
        
        return result",AntonBelski
481,https://leetcode.com/problems/magical-string/discuss/2558509/481.-Magical-String,"class Solution:
    def magicalString(self, n: int) -> int:
        arr, i = [1,2,2], 2
   
        while len(arr) < n:
            arr.extend([arr[-1]^3]*arr[i])
            i += 1
    
        return arr[:n].count(1)",warrenruud
482,https://leetcode.com/problems/license-key-formatting/discuss/540266/PythonJSC%2B%2B-O(n)-by-string-operation.-w-Explanation,"class Solution:
    def licenseKeyFormatting(self, S: str, K: int) -> str:
        
        # Eliminate all dashes
        S = S.replace('-', '')
        
        head = len(S) % K
        
        grouping = []
        
        # Special handle for first group
        if head:
            grouping.append( S[:head] )
        
        # General case:
        for index in range(head, len(S), K ):
            grouping.append( S[ index : index+K ] )
        
        
        # Link each group togetger and separated by dash '-'
        return '-'.join( grouping ).upper()",brianchiang_tw
483,https://leetcode.com/problems/smallest-good-base/discuss/2368982/faster-than-97.27-or-python,"class Solution:
    def smallestGoodBase(self, n: str) -> str:
        import math
        n = int(n)
        max_m = math.floor(math.log(n, 2))
        ans = 0
        for m in range(max_m, 0, -1):
            k = int(n ** (1 / m))
            if (k ** (m + 1)  - 1) // (k - 1) == n:
                return str(k)
        return str(n - 1)",vimla_kushwaha
485,https://leetcode.com/problems/max-consecutive-ones/discuss/1011637/Simple-and-easy-if-else-solution-faster-than-99.91,"class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        c1,c2=0,0
        for i in nums:
            if i==1:
                c1+=1
            elif i==0:
                c1=0
            if c1>c2:
                c2=c1
        return c2",thisisakshat
486,https://leetcode.com/problems/predict-the-winner/discuss/414803/Python-AC-98-Both-Recursion-and-DP-with-detailed-explanation.,"class Solution:
    def PredictTheWinner(self, nums: List[int]) -> bool:
        def helper(i, j):
            if i == j:
                return nums[i]
            
            if (i, j) in memo:
                return memo[(i, j)]
            
            score = max(nums[j] - helper(i, j-1), nums[i] - helper(i+1, j))
            memo[(i, j)] = score
            
            return score
            
        memo = {}            
        return helper(0, len(nums)-1) >= 0",bos
488,https://leetcode.com/problems/zuma-game/discuss/1568450/Python-Easy-BFS-solution-with-explain,"class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        
        # start from i and remove continues ball
        def remove_same(s, i):
            if i < 0:
                return s
            
            left = right = i
            while left > 0 and s[left-1] == s[i]:
                left -= 1
            while right+1 < len(s) and s[right+1] == s[i]:
                right += 1
            
            length = right - left + 1
            if length >= 3:
                new_s = s[:left] + s[right+1:]
                return remove_same(new_s, left-1)
            else:
                return s



        hand = """".join(sorted(hand))

        # board, hand and step
        q = collections.deque([(board, hand, 0)])
        visited = set([(board, hand)])

        while q:
            curr_board, curr_hand, step = q.popleft()
            for i in range(len(curr_board)+1):
                for j in range(len(curr_hand)):
                    # skip the continue balls in hand
                    if j > 0 and curr_hand[j] == curr_hand[j-1]:
                        continue
                    
                    # only insert at the begin of continue balls in board
                    if i > 0 and curr_board[i-1] == curr_hand[j]: # left side same color
                        continue
                    
                    pick = False
                    # 1. same color with right
                    # 2. left and right are same but pick is different
                    if i < len(curr_board) and curr_board[i] == curr_hand[j]:
                        pick = True
                    if 0<i<len(curr_board) and curr_board[i-1] == curr_board[i] and curr_board[i] != curr_hand[j]:
                        pick = True
                    
                    if pick:
                        new_board = remove_same(curr_board[:i] + curr_hand[j] + curr_board[i:], i)
                        new_hand = curr_hand[:j] + curr_hand[j+1:]
                        if not new_board:
                            return step + 1
                        if (new_board, new_hand) not in visited:
                            q.append((new_board, new_hand, step+1))
                            visited.add((new_board, new_hand))

        return -1",nightybear
491,https://leetcode.com/problems/increasing-subsequences/discuss/1577928/Python-DFS,"class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        def dfs(i, num, curr):
            if len(curr)>=2:
                ans.add(curr[:])
            if i>=len(nums):
                return
            for j in range(i, len(nums)):
                if nums[j]>=num:
                    dfs(j+1, nums[j], curr+(nums[j],))
                        
        ans = set()
        dfs(0, -float(""inf""), ())
        return ans",hX_
492,https://leetcode.com/problems/construct-the-rectangle/discuss/1990625/Python-Easy-Solution-or-Faster-Than-92-Submits,"class Solution:
    def constructRectangle(self, area: int) -> List[int]:
        
        for i in range(int(area**0.5),0,-1):
            if area % i == 0: return [area//i,i]",crazypuppy
493,https://leetcode.com/problems/reverse-pairs/discuss/1205560/Python3-summarizing-4-solutions,"class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        ans = 0
        seen = []
        for x in nums: 
            k = bisect_right(seen, 2*x)
            ans += len(seen) - k
            insort(seen, x)
        return ans",ye15
494,https://leetcode.com/problems/target-sum/discuss/1198338/Python-recursive-solution-with-memoization-(DFS),"class Solution:    
    def findTargetSumWays(self, nums: List[int], target: int) -> int:     
        dic = defaultdict(int)
        
        def dfs(index=0, total=0):          
            key = (index, total)
            
            if key not in dic:
                if index == len(nums):                    
                    return 1 if total == target else 0
                else:
                    dic[key] = dfs(index+1, total + nums[index]) + dfs(index+1, total - nums[index])                    
                        
            return dic[key]                                                             
                
        return dfs()",swissified
495,https://leetcode.com/problems/teemo-attacking/discuss/1602614/Python-6-lines-O(n)-concise-solution,"class Solution(object):
    def findPoisonedDuration(self, timeSeries, duration):
        repeat = 0
        for i in range(len(timeSeries)-1):
            diff = timeSeries[i+1] - timeSeries[i]
            if diff < duration:
                repeat += duration - diff
        return len(timeSeries)*duration - repeat",caitlinttl
496,https://leetcode.com/problems/next-greater-element-i/discuss/640416/Python-sol-by-monotonic-stack-and-dict-w-Comment,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        
        
        # a stack with monotonic decreasing
        monotonic_stack = []
        
        # dictionary:
        # key: number
        # value: next greater number of key
        dict_of_greater_number = {}

        # ----------------------------------------------
        
        # launch linear scan to build dict_of_greater_number
        for cur_number in nums2:
            
            # maintain a monotonic decreasing stack
            while monotonic_stack and cur_number > monotonic_stack[-1]:
                
                pop_out_number = monotonic_stack.pop()
                
                # next greater number of pop_out_number is cur_number
                dict_of_greater_number[pop_out_number] = cur_number
            
            monotonic_stack.append(cur_number)
        # ----------------------------------------------
        
        # solution output
        next_greater_element = []
        
        # get next greater element by dictionary
        for x in nums1:
            
            if x in dict_of_greater_number:
                next_greater_element.append( dict_of_greater_number[x] )
                
            else:
                next_greater_element.append(-1)
                
        return next_greater_element",brianchiang_tw
498,https://leetcode.com/problems/diagonal-traverse/discuss/272114/Simple-Python-Solution-(with-comments),"class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        if not matrix:
            return res

        # group values in matrix by the sum of their indices in a map
        map = {}
        for i in range(len(matrix) + len(matrix[0]) - 1):
            map[i] = []

        # populate the map
        for i, row in enumerate(matrix):
            for j, val in enumerate(row):
                map[i + j].append(val)

        # iterate through map and reverse values where key is divisible by two
        for k, v in map.items():
            if k % 2 == 0:
                map[k] = v[::-1]
        
        # populate output
        for v in map.values():
            for val in v:
                res.append(val)
                
        return res",AnthonyChao
500,https://leetcode.com/problems/keyboard-row/discuss/1525751/Easy-Python-Solution-or-Faster-than-97-(24-ms),"class Solution:
    def findWords(self, wds: List[str]) -> List[str]:
        st = {'q': 1, 'w': 1, 'e': 1, 'r': 1, 't': 1, 'y': 1, 'u': 1, 'i': 1, 'o': 1, 'p': 1, 'a': 2, 's': 2, 'd': 2, 'f': 2, 'g': 2, 'h': 2, 'j': 2, 'k': 2, 'l': 2, 'z': 3, 'x': 3, 'c': 3, 'v': 3, 'b': 3, 'n': 3, 'm': 3}

        ret = []

        for wd in wds:
            val = 0
            for i in range(len(wd)):
                if i == 0:
                    val = st.get(wd[i].lower())
                else:
                    if val != st.get(wd[i].lower()):
                        val = -1
                        break
            if val != -1:
                ret.append(wd)
        return ret",the_sky_high
501,https://leetcode.com/problems/find-mode-in-binary-search-tree/discuss/1722526/Python3-Inorder-traversal-beats-99,"class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        
        def traverse(root: TreeNode) -> None:
            
            if not root:
                return
            
            nonlocal maxcount, count, prevval, modes
            
            traverse(root.left)
            
            if root.val == prevval:
                count += 1
            else:                
                count = 1
                
            if count > maxcount:
                maxcount = count
                modes = [root.val]
            elif count == maxcount:
                modes.append(root.val)
                
            prevval = root.val
            traverse(root.right)
                
                
        modes = []
        maxcount = 0
        count = 0
        prevval = root.val
        traverse(root)
        
        return modes",cwkirby
502,https://leetcode.com/problems/ipo/discuss/1492025/Python3-greedy,"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        capital, profits = zip(*sorted(zip(capital, profits)))
        i = 0 
        pq = []
        for _ in range(k): 
            while i < len(capital) and capital[i] <= w: 
                heappush(pq, -profits[i])
                i += 1
            if pq: w -= heappop(pq)
        return w",ye15
503,https://leetcode.com/problems/next-greater-element-ii/discuss/2520585/Python-Stack-98.78-faster-or-Simplest-solution-with-explanation-or-Beg-to-Adv-or-Monotonic-Stack,"class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack, res = [], [-1] * len(nums) # taking an empty stack for storing index, a list with the lenght same as of nums so that we wont add unnecessary elements.
        # [-1] * len(nums) = this will produce a list with len of nums and all elems will be -1.
        for i in list(range(len(nums))) * 2: # see explanation below.
            while stack and (nums[stack[-1]] < nums[i]): # stack is not empty and nums previous elem is less then current, i.e 1<2. 
                res[stack.pop()] = nums[i] # then we`ll pop the index in stack and in the res on the same index will add the current num. 
            stack.append(i) # if stack is empty then we`ll add the index of num in it for comparision to the next element in the provided list. 
        return res # returing the next greater number for every element in nums.",rlakshay14
504,https://leetcode.com/problems/base-7/discuss/1014922/Simple-and-easy-faster-than-99.31,"class Solution:
    def convertToBase7(self, num: int) -> str:
        if not num:
            return ""0""
        l=[]
        x=num
        if num<0:
            num=-num
        while num>0:
            r=num%7
            l.append(str(r))
            num//=7
        return """".join(l[::-1]) if x>=0 else ""-""+ """".join(l[::-1])",thisisakshat
506,https://leetcode.com/problems/relative-ranks/discuss/1705542/Python-Simple-Solution-using-Max-Heap,"class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        rankings = []
        for i, val in enumerate(score):
            heappush(rankings, (-val, i))
        ans = [''] * len(score)
        r = 1
        rank = [""Gold Medal"", ""Silver Medal"", ""Bronze Medal""]
        while len(rankings) != 0:
            _, i = heappop(rankings)
            if r <= 3:
                ans[i] = rank[r-1]
            else:
                ans[i] = f'{r}'
            r += 1
        return ans",anCoderr
507,https://leetcode.com/problems/perfect-number/discuss/1268856/Python3-simple-solution,"class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        if num == 1:
            return False
        res = 1
        for i in range(2,int(num**0.5)+1):
            if num%i == 0:
                res += i + num//i
        return res == num",EklavyaJoshi
508,https://leetcode.com/problems/most-frequent-subtree-sum/discuss/1101640/A-Basic-Python,"class Solution:
    def findFrequentTreeSum(self, root: TreeNode) -> List[int]:
        
        counts = collections.Counter()
        
        def dfs(node):
            if not node: return 0            
            result = node.val + dfs(node.left) + dfs(node.right)
            counts[result] += 1        
            return result
        
        dfs(root)       
        
        # Try to return the most frequent elements
        # Return [] if we run into index errors
        try:
            freq = counts.most_common(1)[0][1]
            return [x[0] for x in counts.items() if x[1] == freq]
        except:
            return []",dev-josh
509,https://leetcode.com/problems/fibonacci-number/discuss/336501/Solution-in-Python-3-(beats-~100)-(three-lines),"class Solution:
    def fib(self, N: int) -> int:
    	a, b = 0, 1
    	for i in range(N): a, b = b, a + b
    	return a
		
		
- Python 3
- Junaid Mansuri",junaidmansuri
513,https://leetcode.com/problems/find-bottom-left-tree-value/discuss/2680305/Pyhton3-BFS-Solution-oror-BGG,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        q=[[root]]
        nodes=[]
        while q:
            nodes = q.pop(0)
            t=[]
            for n in nodes:
                if n.left:
                    t.append(n.left)
                if n.right:
                    t.append(n.right)
            if t:
                q.append(t)
        return nodes[0].val
# Please upvote if you understand the solution",hoo__mann
514,https://leetcode.com/problems/freedom-trail/discuss/1367426/Python3-top-down-dp,"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        locs = {}
        for i, ch in enumerate(ring): locs.setdefault(ch, []).append(i)
            
        @cache 
        def fn(i, j): 
            """"""Return turns to finish key[j:] startin from ith position on ring.""""""
            if j == len(key): return 0 
            loc = locs[key[j]]
            k = bisect_left(loc, i) % len(loc)
            ans = min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1)
            k = (k-1) % len(loc)
            ans = min(ans, min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1))
            return ans 
        
        return fn(0, 0) + len(key)",ye15
515,https://leetcode.com/problems/find-largest-value-in-each-tree-row/discuss/1620422/Python-3-easy-dfs-recursive-solution-faster-than-94,"class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        def helper(root, depth):
            if root is None:
                return
            
            if depth == len(res):
                res.append(root.val)
            else:
                res[depth] = max(res[depth], root.val)
            
            helper(root.left, depth + 1)
            helper(root.right, depth + 1)
        
        helper(root, 0)
        return res",dereky4
516,https://leetcode.com/problems/longest-palindromic-subsequence/discuss/1968323/Python-3-Approaches-(Recursion-%2B-Memoization-%2B-DP),"class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        return self.get_longest_subseq(0, len(s)-1, s)
    
    def get_longest_subseq(self, start, end, s):
        """"""
            method used to find the longest palindrome subsequence in a string
            start: start index of the string
            end: end index of the string
            s: string
            return: length of the longest palindrome subsequence
        """"""
        if start == end:
            return 1
			
        if start > end:
            return 0

        if s[start] == s[end]:
            return 2 + self.get_longest_subseq(start + 1, end - 1, s)
        
        return max(self.get_longest_subseq(start + 1, end, s), self.get_longest_subseq(start, end - 1, s))",superGloria
517,https://leetcode.com/problems/super-washing-machines/discuss/1494245/Python3-greedy,"class Solution:
    def findMinMoves(self, machines: List[int]) -> int:
        total = sum(machines)
        if total % len(machines): return -1 # impossible 
        avg = total // len(machines)
        
        ans = prefix = 0
        for i, x in enumerate(machines): 
            ans = max(ans, abs(prefix), x - avg)
            prefix += x - avg
        return ans",ye15
518,https://leetcode.com/problems/coin-change-ii/discuss/675186/Python3-DP-Solution-O(mn)-Time-and-Space,"class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [[1]+[0]*amount for _ in range(len(coins)+1)]
        for i in range(1, len(coins)+1):
            for j in range(1, amount+1):
                if coins[i-1] <= j:
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[len(coins)][amount]  # or dp[-1][-1]",schedutron
519,https://leetcode.com/problems/random-flip-matrix/discuss/2108517/Python3Three-solutions-with-detailed-explanation.,"class Solution:

    def __init__(self, m: int, n: int):
        self.nums = m * n - 1
        self.cols = n
        self.flipped = set()
        

    def flip(self) -> List[int]:
        rc = random.randint(0, self.nums)
        while rc in self.flipped:
            rc = random.randint(0, self.nums)
            
        self.flipped.add(rc)
        return [rc // self.cols, rc % self.cols]
    

    def reset(self) -> None:
        self.flipped = set()",AlainWong
520,https://leetcode.com/problems/detect-capital/discuss/336441/Solution-in-Python-3-(one-line),"class Solution:
    def detectCapitalUse(self, word: str) -> bool:
    	return word in [word.upper(), word.lower(), word.title()]
		

- Python 3
- Junaid Mansuri",junaidmansuri
521,https://leetcode.com/problems/longest-uncommon-subsequence-i/discuss/1277607/python-two-lines-or-easy,"class Solution:
    def findLUSlength(self, a: str, b: str) -> int:
        if a==b:return -1
        else:return max(len(a),len(b))",chikushen99
522,https://leetcode.com/problems/longest-uncommon-subsequence-ii/discuss/380412/Solution-in-Python-3-(beats-~100),"class Solution:
    def findLUSlength(self, S: List[str]) -> int:
    	C = collections.Counter(S)
    	S = sorted(C.keys(), key = len, reverse = True)
    	for i,s in enumerate(S):
    		if C[s] != 1: continue
    		b = True
    		for j in range(i):
    			I, c = -1, True
    			for i in s:
    				I = S[j].find(i,I+1)
    				if I == -1:
    					c = False
    					break
    			if c:
    				b = False
    				break
    		if b: return len(s)
    	return -1
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
523,https://leetcode.com/problems/continuous-subarray-sum/discuss/1582670/Python-Easy-Solution-or-Brute-Force-and-Optimal-Approach,"class Solution:
	def checkSubarraySum(self, nums: List[int], k: int) -> bool:
		# Brute Force: O(^2) - TLE
		count = 0
		for i in range(len(nums)):
			sum = 0
			for j in range(i, len(nums)):
				sum += nums[j]
				if sum % k == 0:
				   return True
		return False

class Solution:
	def checkSubarraySum(self, nums: List[int], k: int) -> bool:
		# Optimal Approach - Time and Space: O(n), O(n)
		res = {0: -1}
		prefSum = 0
		for i in range(len(nums)):
			prefSum += nums[i]
			rem = prefSum % k
			if rem in res:
				if i-res[rem] > 1:
					return True
			else:
				res[rem] = i
		return False",leet_satyam
524,https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/discuss/1077760/Python.-very-clear-and-simplistic-solution.,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        def is_subseq(main: str, sub: str) -> bool:
            i, j, m, n = 0, 0, len(main), len(sub)
            while i < m and j < n and n - j >= m - i:
                if main[i] == sub[j]:
                    i += 1
                j += 1
            return i == m
        
        res = ''
        helper = sorted(d, key = lambda x: len(x), reverse = True)
        for word in helper:
            if len(word) < len(res): return res
            if ( not res or word < res )  and is_subseq(word, s):
                res = word
        return res",m-d-f
525,https://leetcode.com/problems/contiguous-array/discuss/577489/Python-O(n)-by-partial-sum-and-dictionary.-90%2B-w-Visualization,"class Solution:
    def findMaxLength(self, nums: List[int]) -> int:

        partial_sum = 0
        
		# table is a dictionary
		# key : partial sum value
		# value : the left-most index who has the partial sum value
		
        table = { 0: -1}
        
        max_length = 0
        
        for idx, number in enumerate( nums ):
            
            # partial_sum add 1 for 1
            # partial_sum minus 1 for 0
            
            if number:
                partial_sum += 1
            else:
                partial_sum -= 1
                
            
            if partial_sum in table:
                
                # we have a subarray with equal number of 0 and 1
                # update max length
                
                max_length = max( max_length, ( idx - table[partial_sum] ) )
                
            else:
                # update the left-most index for specified partial sum value
                table[ partial_sum ] = idx
                
        return max_length",brianchiang_tw
526,https://leetcode.com/problems/beautiful-arrangement/discuss/1094146/Python-Backtracking-the-more-intuitive-way,"class Solution:
    def countArrangement(self, n: int) -> int:
        self.count = 0
        self.backtrack(n, 1, [])
        return self.count
        
    def backtrack(self, N, idx, temp):
        if len(temp) == N:
            self.count += 1
            return
        
        for i in range(1, N+1):
            if i not in temp and (i % idx == 0 or idx % i == 0):
                temp.append(i)
                self.backtrack(N, idx+1, temp)
                temp.pop()",IamCookie
528,https://leetcode.com/problems/random-pick-with-weight/discuss/1535699/Better-than-96.5,"class Solution:

    def __init__(self, w: List[int]):
        self.li = []
        ma = sum(w)
        
        for i, weight in enumerate(w):
            ratio = ceil(weight / ma * 100)
            self.li += ([i] * ratio)
        

    def pickIndex(self) -> int:
        return random.choice(self.li)",josephp27
529,https://leetcode.com/problems/minesweeper/discuss/875335/Python-3-or-Ad-hoc-DFS-or-Explanation,"class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        m, n = len(board), len(board[0])
        def dfs(x, y):
            if board[x][y] == 'M': board[x][y] = 'X'
            elif board[x][y] == 'E':
                cnt, nei = 0, []
                for i, j in map(lambda v: (v[0]+x, v[1]+y), [(-1, 0), (1, 0), (-1, -1), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 1)]):
                    if 0 <= i < m and 0 <= j < n:
                        nei.append((i, j))
                        if board[i][j] == 'M': cnt += 1
                if not cnt:
                    board[x][y] = 'B'
                    for i, j in nei: dfs(i, j)
                else: board[x][y] = str(cnt)
        dfs(*click)            
        return board",idontknoooo
530,https://leetcode.com/problems/minimum-absolute-difference-in-bst/discuss/1414654/Faster-than-99.61-of-Python3-with-logical-explanation,"class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        d = float('inf')
        s = []
        if root == None:
            return 
        d = self.traverse(root,d,s)
        return d
    def traverse(self,root,d,s):
        if root.left != None:
            d = self.traverse(root.left,d,s)
        s.append(root.val)
        if len(s)>1:
            diff = s[-1]-s[-2]
            if diff < d:
                d = diff
        if root.right != None:
            d = self.traverse(root.right,d,s) 
        return d",iron_man_365
532,https://leetcode.com/problems/k-diff-pairs-in-an-array/discuss/1757434/Python-O(n)-Solution-or-98-Faster-or-Easy-Solution-or-K-diff-Pairs-in-an-Array,"class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:
        cnt=0
        c=Counter(nums)
        
        if k==0:
            for key,v in c.items():
                if v>1:
                    cnt+=1
        else:
            for key,v in c.items():
                if key+k in c:
                    cnt+=1
        return cnt",pniraj657
537,https://leetcode.com/problems/complex-number-multiplication/discuss/1187864/Python3-simple-solution,"class Solution:
    def complexNumberMultiply(self, num1: str, num2: str) -> str:
        a1,b1 = num1.split('+')
        a1 = int(a1)
        b1 = int(b1[:-1])
        a2,b2 = num2.split('+')
        a2 = int(a2)
        b2 = int(b2[:-1])
        return str(a1*a2 + b1*b2*(-1)) + '+' + str(a1*b2 + a2*b1) + 'i'",EklavyaJoshi
538,https://leetcode.com/problems/convert-bst-to-greater-tree/discuss/1057429/Python.-faster-than-100.00.-Explained-clear-and-Easy-understanding-solution.-O(n).-Recursive,"class Solution:
	def convertBST(self, root: TreeNode) -> TreeNode:
		sum = 0
		
		def sol(root: TreeNode) -> TreeNode:
			nonlocal sum
			if root:
				sol(root.right)
				root.val += sum
				sum = root.val
				sol(root.left)
			return root
		
		return sol(root)",m-d-f
539,https://leetcode.com/problems/minimum-time-difference/discuss/1829297/python-3-bucket-sort-O(n)-time-O(1)-space,"class Solution:
    def findMinDifference(self, timePoints: List[str]) -> int:
        M = 1440
        times = [False] * M
        for time in timePoints:
            minute = self.minute(time)
            if times[minute]:
                return 0
            times[minute] = True
        
        minutes = [i for i in range(M) if times[i]]
        return min((minutes[i] - minutes[i-1]) % M for i in range(len(minutes)))
        
    def minute(self, time: str) -> int:
        h, m = map(int, time.split(':'))
        return 60*h + m",dereky4
540,https://leetcode.com/problems/single-element-in-a-sorted-array/discuss/1587293/Python-3-Simple-Approaches-with-Explanation,"class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        counts = defaultdict(int)
        for num in nums:
            counts[num] += 1
        for num, count in counts.items():
            if count == 1:
                return num
        return -1  # this will never be reached
		# return Counter(nums).most_common()[-1][0]  # one-liner, but TC O(nlogn)",zayne-siew
541,https://leetcode.com/problems/reverse-string-ii/discuss/343424/Python-3-solution-using-recursion-(efficient)-3-liner-with-explanation,"class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        if len(s)<(k):return s[::-1]
        if len(s)<(2*k):return (s[:k][::-1]+s[k:])
        return s[:k][::-1]+s[k:2*k]+self.reverseStr(s[2*k:],k)",ketan35
542,https://leetcode.com/problems/01-matrix/discuss/1556018/WEEB-DOES-PYTHON-BFS,"class Solution:
	def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
		row, col = len(mat), len(mat[0])
		queue = deque([])

		for x in range(row):
			for y in range(col):
				if mat[x][y] == 0:
					queue.append((x, y, 1))


		return self.bfs(row, col, queue, mat)

	def bfs(self, row, col, queue, grid):
		visited = set()
		while queue:
			x, y, steps = queue.popleft()

			for nx, ny in [[x+1,y], [x-1,y], [x,y+1], [x,y-1]]:
				if 0<=nx<row and 0<=ny<col and (nx,ny) not in visited:
					if grid[nx][ny] == 1:
						visited.add((nx,ny))
						grid[nx][ny] = steps
						queue.append((nx, ny, steps+1))

		return grid",Skywalker5423
543,https://leetcode.com/problems/diameter-of-binary-tree/discuss/1515564/Python-Easy-to-understand-solution-w-Explanation,"class Solution:
    def __init__(self):
	    self.diameter = 0  # stores the maximum diameter calculated
	
    def depth(self, node: Optional[TreeNode]) -> int:
        """"""
        This function needs to do the following:
            1. Calculate the maximum depth of the left and right sides of the given node
            2. Determine the diameter at the given node and check if its the maximum
        """"""
        # Calculate maximum depth
        left = self.depth(node.left) if node.left else 0
        right = self.depth(node.right) if node.right else 0
        # Calculate diameter
        if left + right > self.diameter:
            self.diameter = left + right
        # Make sure the parent node(s) get the correct depth from this node
        return 1 + (left if left > right else right)
    
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # if not root:
        #     return 0
        self.depth(root)  # root is guaranteed to be a TreeNode object
        return self.diameter",zayne-siew
546,https://leetcode.com/problems/remove-boxes/discuss/1379392/Python3-dp,"class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:
        
        @cache
        def fn(lo, hi, k): 
            """"""Return max score of removing boxes from lo to hi with k to the left.""""""
            if lo == hi: return 0 
            while lo+1 < hi and boxes[lo] == boxes[lo+1]: lo, k = lo+1, k+1
            ans = (k+1)*(k+1) + fn(lo+1, hi, 0)
            for mid in range(lo+2, hi): 
                if boxes[lo] == boxes[mid]: 
                    ans = max(ans, fn(lo+1, mid, 0) + fn(mid, hi, k+1))
            return ans 
                
        return fn(0, len(boxes), 0)",ye15
547,https://leetcode.com/problems/number-of-provinces/discuss/727759/Python3-solution-with-detailed-explanation,"class Solution(object):
    def findCircleNum(self, M):
        """"""
        :type M: List[List[int]]
        :rtype: int
        """"""
        n = len(M)  #1
        visited = [False]*n  #2
        count = 0  #3
        
        if not M:  #4
            return 0  #5
        
        def dfs(u):  #6
            for v in range(n):  #7
                if M[u][v] == 1 and visited[v] == False:  #8
                    visited[v] = True  #9
                    dfs(v)  #10
        
        
        for idx in range(n): #11
            if visited[idx] == False: #12
                count += 1 #13
                visited[idx] == True #14
                dfs(idx) #15
        
        return count #16",peyman_np
551,https://leetcode.com/problems/student-attendance-record-i/discuss/356636/Solution-in-Python-3-(one-line),"class Solution:
    def checkRecord(self, s: str) -> bool:
    	return (s.count('A') < 2) and ('LLL' not in s)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
552,https://leetcode.com/problems/student-attendance-record-ii/discuss/356750/Solution-in-Python-3-(five-lines)-(with-explanation),"class Solution:
    def checkRecord(self, n: int) -> int:
    	C, m = [1,1,0,1,0,0], 10**9 + 7
    	for i in range(n-1):
    		a, b = sum(C[:3]) % m, sum(C[3:]) % m
    		C = [a, C[0], C[1], a + b, C[3], C[4]]
    	return (sum(C) % m)",junaidmansuri
553,https://leetcode.com/problems/optimal-division/discuss/1265206/Python3-string-concatenation,"class Solution:
    def optimalDivision(self, nums: List[int]) -> str:
        if len(nums) <= 2: return ""/"".join(map(str, nums))
        return f'{nums[0]}/({""/"".join(map(str, nums[1:]))})'",ye15
554,https://leetcode.com/problems/brick-wall/discuss/1736767/python-easy-hashmap-solution,"class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        count = defaultdict(int)
        tot = len(wall)
        if tot == 1 and len(wall[0]) > 1:
            return 0
        elif tot == 1 and len(wall[0]) == 1:
            return 1
        
        for w in wall:
            s = 0 
            for i in range(len(w)):
                s += w[i]
                count[s] += 1
            count[s] -= 1

        return tot - max(count.values())",byuns9334
556,https://leetcode.com/problems/next-greater-element-iii/discuss/983461/Simple-Python-Solution-easy-to-understand-reading-backwards-from-the-end,"class Solution:
    def nextGreaterElement(self, n: int) -> int:
        m=list(str(n))                       ## n = 257761
        l = len(m)                           ## l = 6
        d = {}
        res = str(n)
        
        ## reading character backwards: 1->6->7->7->5 break
        for i,c in enumerate(m[::-1]): 
            if not d:
                d[c]=1                       ## d = {'1':1}
            else:
                if all(c >= x for x in d):
                    d[c]=d.get(c,0)+1        ## d = {'1':1,'6':1,'7':2} 
                else:
                    d[c]=d.get(c,0)+1        ## d = {'1':1,'5':1,'6':1,'7':2}
                    res = ''.join(m[:l-1-i])        ## res = '2'
                    stock = sorted(list(d.keys()))  ## stock = ['1','5','6','7']
                    cplus = stock[stock.index(c)+1] ## cplus = '6' just > '5'
                    res += cplus                    ## res = '26'
                    d[cplus] -= 1                   ## d = {'1':1,'5':1,'6':0,'7':2}
                    res += ''.join([x * d[x] for x in stock]) 
					                                ## res = '26' + '1577'
                    break
        
        return int(res) if n < int(res) < (2**31-1) else -1",KevinZzz666
557,https://leetcode.com/problems/reverse-words-in-a-string-iii/discuss/332138/Simple-Python-3-Solution-(beats-~98)-(three-lines),"class Solution:
    def reverseWords(self, s: str) -> str:
    	s = s.split()
    	for i in range(len(s)): s[i] = s[i][::-1]
    	return "" "".join(s)
	

- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
560,https://leetcode.com/problems/subarray-sum-equals-k/discuss/1759711/Python-Simple-Python-Solution-Using-PrefixSum-and-Dictionary,"class Solution:
	def subarraySum(self, nums: List[int], k: int) -> int:

		ans=0
		prefsum=0
		d={0:1}

		for num in nums:
			prefsum = prefsum + num

			if prefsum-k in d:
				ans = ans + d[prefsum-k]

			if prefsum not in d:
				d[prefsum] = 1
			else:
				d[prefsum] = d[prefsum]+1

		return ans",ASHOK_KUMAR_MEGHVANSHI
561,https://leetcode.com/problems/array-partition/discuss/390198/Algorithm-and-solution-in-python3,"class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        sum_ = 0
        for i in range(0,len(nums),2):
            sum_ += nums[i]
        return sum_

# Time : 356 ms
# Memory : 16.7 M",ramanaditya
563,https://leetcode.com/problems/binary-tree-tilt/discuss/1617385/Recursive-solution-Python,"class Solution:
    def findTilt(self, root: Optional[TreeNode]) -> int:
        def rec(node):
            nonlocal res
            if not node:
                return 0
            left_sum = rec(node.left)
            right_sum = rec(node.right)
            res += abs(left_sum - right_sum)
            
            return left_sum + node.val + right_sum
        
        res = 0
        rec(root)
        return res",kryuki
564,https://leetcode.com/problems/find-the-closest-palindrome/discuss/2581120/Only-5-Cases-to-Consider%3A-Concise-implementation-in-Python-with-Full-Explanation,"class Solution:
    def find_next_palindrome(self, n, additive):
        l = len(n)
        if l == 0:
            return 0
        first_half = str(int(n[:l // 2 + l % 2]) + additive)
        return int(first_half + first_half[(-1 - l%2)::-1])
            
    def nearestPalindromic(self, n: str) -> str:
        m = int(n)
        candidates = [self.find_next_palindrome(n, additive) for additive in range(-1, 2)] # Cases 1, 2, and 3
        candidates.append(self.find_next_palindrome(""9""*(len(n)-1), 0)) # Case 4
        candidates.append(self.find_next_palindrome(""1"" + ""0""*len(n), 0)) # Case 5

        ans = None
        for t in candidates:
            if t == m:
                continue
            if ans is None or abs(ans - m) > abs(t - m) or (abs(ans - m) == abs(t - m) and t < m):
                ans = t
        return str(ans)",metaphysicalist
565,https://leetcode.com/problems/array-nesting/discuss/1438213/CLEAN-and-SHORT-PYTHON-O(N)-TIME-O(N)-SPACE,"class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        res, l = 0, len(nums)
        globalSet = set()
        for k in range(l):
            if k not in globalSet:
                currLength, currSet, val = 0, set(), k
                while True:
                    if nums[val] in currSet: break
                    currSet.add(nums[val])
                    globalSet.add(nums[val])
                    currLength, val = currLength + 1, nums[val]
                res = max(res, currLength)        
        return res",kushagrabainsla
566,https://leetcode.com/problems/reshape-the-matrix/discuss/2046840/Python-Intuitive-%2B-Direct-for-Beginners-with-Illustrations,"class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        flatten = []
        new_mat = []
        for row in mat:
            for num in row:
                flatten.append(num)
                
        if r * c != len(flatten):   # when given parameters is NOT possible and legal
            return mat
        else:
            for row_index in range(r):
                new_mat.append(flatten[row_index * c : row_index * c + c])
            return new_mat",ziaiz-zythoniz
567,https://leetcode.com/problems/permutation-in-string/discuss/1476884/Python-Sliding-Window-and-Dictionary.-Easy-to-understand,"class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        window = len(s1)
        s1_c = Counter(s1)
        
        for i in range(len(s2)-window+1):
            s2_c = Counter(s2[i:i+window])
            if s2_c == s1_c:
                return True
            
        return False",ParthitPatel
572,https://leetcode.com/problems/subtree-of-another-tree/discuss/265239/Python-Easy-to-Understand,"class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        if not s: 
            return False
        if self.isSameTree(s, t): 
            return True
        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)

    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if p and q:
            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        return p is q",ccparamecium
575,https://leetcode.com/problems/distribute-candies/discuss/1088016/Python.-One-liner-Easy-understanding-solution.,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return min(len(candyType) //2, len(set(candyType)))",m-d-f
576,https://leetcode.com/problems/out-of-boundary-paths/discuss/2288190/Python3-oror-recursion-one-grid-w-explanation-oror-TM%3A-8949,"class Solution:         # The plan is to accrete the number of paths from the starting cell, which
                        # is the sum of (a) the number of adjacent positions that are off the grid
                        # and (b) the number of paths from the adjacent cells in the grid within 
                        # maxMove steps. We determine (b) recursively.

    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:

        @lru_cache(None)                                # <-- Many cells are revisited so we cache the previous calls
        def dp (x,y,steps = maxMove):
            if x not in range(m) or y not in range(n):  # <-- Moved off the grid so increment the tally
                return 1
            if not steps:                               # <-- Ran out of the maxMove steps
                return 0

            ans, dx, dy = 0, 1, 0
            for _ in range(4):
                ans+= dp(x+dx, y+dy, steps-1)           # <-- visit the adjacent cells
                dx, dy = dy,-dx                         # <-- iterates thru the directions:
				                                        #         south => east => north => west 

            return ans  

        return dp (startRow, startColumn)%1000000007
		
		# Thanks to XixiangLiu for fixing a number of my errors in the original post.",warrenruud
581,https://leetcode.com/problems/shortest-unsorted-continuous-subarray/discuss/2002965/Python-Simple-Two-Approaches,"class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        sorted_nums = sorted(nums)
        
        l, u = len(nums) - 1,0
        for i in range(len(nums)):
            if nums[i]!=sorted_nums[i]:
                l=min(l, i)
                u=max(u, i)
        
        
        return 0 if l>=u else u-l+1",constantine786
583,https://leetcode.com/problems/delete-operation-for-two-strings/discuss/2148966/Python-DP-2-approaches-using-LCS,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m,n=len(word1),len(word2)
        @cache
        def lcs(i, j): # find longest common subsequence
            if i==m or j==n:
                return 0            
            return 1 + lcs(i+1, j+1) if word1[i]==word2[j] else  max(lcs(i+1, j), lcs(i,j+1))                               
        # subtract the lcs length from both the strings 
        # the difference is the number of characters that has to deleted
        return m + n - 2*lcs(0,0)",constantine786
587,https://leetcode.com/problems/erect-the-fence/discuss/864619/Python-Solution-with-Monotone-Chain-Algorithm,"class Solution:
    def outerTrees(self, points: List[List[int]]) -> List[List[int]]:
        """"""
        Use Monotone Chain algorithm.
        """"""
        def is_clockwise(
                p0: List[int], p1: List[int], p2: List[int]) -> bool:
            """"""
            Determine the orientation the slope p0p2 is on the clockwise
            orientation of the slope p0p1.
            """"""
            return (p1[1] - p0[1]) * (p2[0] - p0[0]) > \
                (p2[1] - p0[1]) * (p1[0] - p0[0])

        sortedPoints = sorted(points)

        # Scan from left to right to generate the lower part of the hull.
        hull = []
        for p in sortedPoints:
            while len(hull) > 1 and is_clockwise(hull[-2], hull[-1], p):
                hull.pop()

            hull.append(p)

        if len(hull) == len(points):  # All the points are on the perimeter now.
            return hull

        # Scan from right to left to generate the higher part of the hull.
        # Remove the last point first as it will be scanned again.
        hull.pop()
        for p in reversed(sortedPoints):
            while len(hull) > 1 and is_clockwise(hull[-2], hull[-1], p):
                hull.pop()

            hull.append(p)

        # Pop the first point as it is already added to hull when processing
        # the lower part.
        hull.pop()

        return hull",eroneko
591,https://leetcode.com/problems/tag-validator/discuss/449403/Two-Python-Solution%3A(1)-linear-paring-with-stack(2)BNF-parsing-with-pyparsing,"class Solution:
    def isValid(self, code: str) -> bool:
        if code[0] != '<' or code[-1] != '>': return False
        i, n = 0, len(code)
        stk = []
        while i < n:
            if code[i] == '<':
                if i != 0 and code[i: i + 9] == '<![CDATA[':
                    if not stk: return False
                    j = i + 9
                    while j + 3 <= n and code[j: j + 3] != ']]>': j += 1
                    if code[j: j + 3] == ']]>': i = j + 3
                    else: return False
                else:
                    start = i
                    isend = False
                    i += 1
                    if i >= n: return False
                    if code[i] == r'/':
                        isend = True
                        i += 1
                    if i >= n: return False
                    tag = ''
                    while i < n and code[i] != '>':
                        if not code[i].isupper(): return False
                        tag += code[i]
                        i += 1
                    if i >= n or len(tag) == 0 or len(tag) > 9: return False
                    if isend:
                        if not stk or stk[-1] != tag: return False
                        stk.pop(-1)
                    else:
                        if start != 0 and not stk: return False
                        stk.append(tag)
                    i += 1
            else:
                if not stk: return False
                while i < n and code[i] != '<': i += 1
        return not stk",cava
592,https://leetcode.com/problems/fraction-addition-and-subtraction/discuss/1128722/Python-Simple-Parsing-with-example,"class Solution:
    def fractionAddition(self, exp: str) -> str:
        
        if not exp:
            return ""0/1""
        
        if exp[0] != '-':
            exp = '+' + exp
        
        # Parse the expression to get the numerator and denominator of each fraction
        num = []
        den = []
        pos = True
        i = 0
        while i < len(exp):
            # Check sign
            pos = True if exp[i] == '+' else False
            
            # Get numerator
            i += 1
            n = 0
            while exp[i].isdigit():
                n = n*10 + int(exp[i])
                i += 1
            num.append(n if pos else -n)
            
            # Get denominator
            i += 1
            d = 0
            while i < len(exp) and exp[i].isdigit():
                d = d*10 + int(exp[i])
                i += 1
            den.append(d)
        
        # Multiply the numerator of all fractions so that they have the same denominator
        denominator = functools.reduce(lambda x, y: x*y, den)
        for i,(n,d) in enumerate(zip(num, den)):
            num[i] = n * denominator // d
        
        # Sum up all of the numerator values
        numerator = sum(num)
        
        # Divide numerator and denominator by the greatest common divisor (gcd)
        g = math.gcd(numerator, denominator)
        numerator = numerator // g
        denominator = denominator // g
        
        return f""{numerator}/{denominator}""",rowe1227
593,https://leetcode.com/problems/valid-square/discuss/931866/python-easy-to-understand-3-lines-code-beats-95,"class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
        def dist(point1,point2):
            return (point1[0]-point2[0])**2+(point1[1]-point2[1])**2
            
        D=[
        dist(p1,p2),
        dist(p1,p3),
        dist(p1,p4),
        dist(p2,p3),
        dist(p2,p4),
        dist(p3,p4)
        ]
        D.sort()
        return 0<D[0]==D[1]==D[2]==D[3] and D[4]==D[5]",Mahesh_N_V
594,https://leetcode.com/problems/longest-harmonious-subsequence/discuss/1049126/Python.-O(n)-Cool-easy-and-clear-solution.,"class Solution:
	def findLHS(self, nums: List[int]) -> int:
		tmp = Counter(nums)
		keys = tmp.keys()
		max = 0
		for num in keys:
			if num - 1 in keys:
				if tmp[num - 1] + tmp[num] > max:
					max = tmp[num - 1] + tmp[num]
		return max",m-d-f
598,https://leetcode.com/problems/range-addition-ii/discuss/1434604/C-or-C%2B%2B-or-Python-or-Java-or-C-or-JavaScript-or-Go-Same-Simple-Solution,"class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        min_row = m
        min_col = n
        for i in range(len(ops)):
            min_row=min(min_row, ops[i][0])
            min_col=min(min_col, ops[i][1])
        return min_row*min_col",HadaEn
599,https://leetcode.com/problems/minimum-index-sum-of-two-lists/discuss/1382036/Easy-Python-Solution-(Memory-Usage-less-than-97),"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d = {}
        d2 = {}
        min_ = 5000
        ret = []

        for i in range(len(list1)):
            d[list1[i]] = i+1

        for i in range(len(list2)):
            a = d.get(list2[i], 0)
            if a:
                b = a+i-1
                if b <= min_:
                    min_ = b
                    d2[list2[i]] = b

        for k,v in d2.items():
            if v <= min_:
                ret.append(k)

        return ret",the_sky_high
600,https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/discuss/1361794/Python3-Official-Solution-Explained-Simply-with-Diagrams,"class Solution:
    def findIntegers(self, n: int) -> int:
        # f stores the fibonacci numbers
        f = [1, 2]
        for i in range(2, 30):
            f.append(f[-1]+f[-2])
        
        # last_seen tells us if there was a one right before. 
        # If that is the case, we are done then and there!
        # ans is the answer
        ans, last_seen = 0, 0
        for i in reversed(range(30)):
            if (1 << i) &amp; n: # is the ith bit set?
                ans += f[i]
                if last_seen: 
                    ans -= 1
                    break
                last_seen = 1
            else:
                last_seen = 0
        return ans+1",chaudhary1337
605,https://leetcode.com/problems/can-place-flowers/discuss/380474/Three-Solutions-in-Python-3-(beats-~100),"class Solution:
    def canPlaceFlowers(self, f: List[int], n: int) -> bool:
        L, i, c, f = len(f)-2, -2, 0, f + [0]
        while i < L:
        	i += 2
        	if f[i] == 1: continue
        	if f[i+1] == 0: c += 1
        	else: i += 1
        return n <= c
		
		
		
		
class Solution:
    def canPlaceFlowers(self, f: List[int], n: int) -> bool:
    	L, f, i, c = len(f), [0] + f + [0], 1, 0
    	while i <= L:
    		if f[i-1:i+2] == [0,0,0]: c, i = c + 1, i + 1
    		i += 1
    	return n <= c
		
		
		
		
class Solution:
    def canPlaceFlowers(self, f: List[int], n: int) -> bool:
    	L, f, s, c = len(f), f + [0,1], 0, 1
    	for i in range(L+2):
    		if f[i] == 1: s, c = s + max(0,c-1)//2, 0
    		else: c += 1
    	return n <= s
		
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
606,https://leetcode.com/problems/construct-string-from-binary-tree/discuss/1112030/Python-recursive-solution-with-string-builder,"class Solution:
    def tree2str(self, t: TreeNode) -> str:
        sb = [] # init string builder
        
        # helper function to create result
        def helper(node: TreeNode) -> None: 
            if not node:
                return
            
            sb.append(str(node.val))
            
            if not node.left and not node.right:
                # leaf node, stop processing
                return
            
            sb.append('(')          # always wrap left node with parenthesis when right node exist
            helper(node.left)       # process left node recursively 
            sb.append(')')                         

            if node.right:          # adding parenthesis for the right node only if it is not empty
                sb.append('(')
                helper(node.right)
                sb.append(')') 
        
        helper(t)

        return ''.join(sb)",ignat-s
609,https://leetcode.com/problems/find-duplicate-file-in-system/discuss/2595019/LeetCode-The-Hard-Way-Explained-Line-By-Line,"class Solution:
    def findDuplicate(self, paths: List[str]) -> List[List[str]]:
        m = defaultdict(list)
        for p in paths:
            # 1. split the string by ' '
            path = p.split()
            # the first string is the directory path
            # the rest of them are just file names with content
            directoryPath, rest = path[0], path[1:]
            # for each file names with content
            for f in rest:
                # we retrieve the file name and the file content
                fileName, fileContent = f.split('(')[0], f.split('(')[1][:-1]
                # then group {directoryPath}/{fileName} by file content
                m[fileContent].append(""{}/{}"".format(directoryPath, fileName))
        # return the file list only when the size is greater than 1, meaning they are duplicate files
        return [m[k] for k in m.keys() if len(m[k]) > 1]",wingkwong
611,https://leetcode.com/problems/valid-triangle-number/discuss/884373/Python3-O(N2)-time-solution,"class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        ans = 0
        for i in range(len(nums)): 
            lo, hi = 0, i-1
            while lo < hi: 
                if nums[lo] + nums[hi] > nums[i]:
                    ans += hi - lo 
                    hi -= 1
                else: lo += 1
        return ans",ye15
617,https://leetcode.com/problems/merge-two-binary-trees/discuss/1342175/Elegant-Python-Iterative-and-Recursive-solutions,"class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root1: return root2
        if not root2: return root1
        queue = deque([(root1, root2)])
        while queue:
            current_root1, current_root2 = queue.pop()
            if current_root1.left and current_root2.left: queue.append((current_root1.left, current_root2.left))
            elif not current_root1.left: current_root1.left = current_root2.left
            if current_root1.right and current_root2.right: queue.append((current_root1.right, current_root2.right))
            elif not current_root1.right: current_root1.right = current_root2.right
            current_root1.val += current_root2.val
        return root1",soma28
621,https://leetcode.com/problems/task-scheduler/discuss/2667200/Python-O(n)-time-count-it-directly,"class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        cnt = [0] * 26
        for i in tasks: cnt[ord(i) - ord('A')] += 1
        mx, mxcnt = max(cnt), 0
        for i in cnt: 
            if i == mx: mxcnt += 1
        return max((mx - 1) * (n + 1) + mxcnt, len(tasks))",alex391a
623,https://leetcode.com/problems/add-one-row-to-tree/discuss/1101104/Python.-Recursive.-Easy-understanding-solution,"class Solution:
    def addOneRow(self, root: TreeNode, v: int, d: int, side = ""left"") -> TreeNode:
        if d == 1:
            res = TreeNode(v)
            setattr(res, side, root)
            return res
        if root:
            root.left = self.addOneRow(root.left, v, d - 1)
            root.right = self.addOneRow(root.right, v, d - 1, 'right')
        return root",m-d-f
628,https://leetcode.com/problems/maximum-product-of-three-numbers/discuss/356715/Python3-O(N)-and-O(NlogN)-solutions,"class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        max1 = max2 = max3 = float(""-inf"")
        min1 = min2 = float(""inf"")
        
        for num in nums: 
            if num > max1:
                max1, max2, max3 = num, max1, max2
            elif num > max2:
                max2, max3 = num, max2
            elif num > max3:
                max3 = num
                
            if num < min1:
                min1, min2 = num, min1
            elif num < min2:
                min2 = num
        
        return max(max2*max3, min1*min2) * max1",ye15
629,https://leetcode.com/problems/k-inverse-pairs-array/discuss/2293304/Python3-oror-dp1D-array-10-lines-w-explanation-oror-TM%3A-9586,"class Solution:
                        # A very good description of the dp solution is at
                        # https://leetcode.com/problems/k-inverse-pairs-array/solution/ 
                        # The code below uses two 1D arrays--dp and tmp--instead if a 
                        # 2D array. tmp replaces dp after each i-iteration.
    def kInversePairs(self, n: int, k: int) -> int:
        dp, mod = [1]+[0] * k, 1000000007
        
        for i in range(n):
            tmp, sm = [], 0
            for j in range(k + 1):
                sm+= dp[j]
                if j-i >= 1: sm-= dp[j-i-1]
                sm%= mod
                tmp.append(sm)
            dp = tmp
            #print(dp)       # <-- uncomment this line to get a sense of dp from the print output
			                 #     try n = 6, k = 4; your answer should be 49.
        return dp[k]",warrenruud
630,https://leetcode.com/problems/course-schedule-iii/discuss/2185553/Python3-oror-Heapq-oror-Faster-Solution-with-explanation,"class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        courses.sort(key=lambda c: c[1])
        A, curr = [], 0
        for dur, ld in courses:
            heapq.heappush(A,-dur)
            curr += dur
            if curr > ld: curr += heapq.heappop(A)
        return len(A)",bvian
632,https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/discuss/1495460/PYTHON-SOLUTION-FASTER-THAN-88.58-OF-PYTHON-SUBMISSIONS,"class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        k=len(nums)
        maxx=-float('inf')
        ans=[0,float('inf')]
        heap=[]
        for i in range(k):
            heap.append((nums[i][0],i,0))
            if nums[i][0]>maxx:maxx=nums[i][0]
        heapq.heapify(heap)
        while True:
            val,row,col= heapq.heappop(heap)
            tmp=maxx-val
            if tmp<ans[1]-ans[0]:ans=[val,maxx]
            elif tmp==ans[1]-ans[0] and val<ans[0]:ans=[val,maxx]
            if col+1==len(nums[row]):break        
            if nums[row][col+1]>maxx:maxx=nums[row][col+1]
            heapq.heappush(heap,(nums[row][col+1],row,col+1))
        return ans",reaper_27
633,https://leetcode.com/problems/sum-of-square-numbers/discuss/2203194/Python3-solution-using-two-pointers,"class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        low = 0
        high = int(sqrt(c))
        
        if high**2 == c:
            return True
        
        while low<=high:
            x = low **2 + high **2
            if x == c:
                return True
            if x > c:
                high-=1
            else:
                low+=1
        return False",Dark_wolf_jss
636,https://leetcode.com/problems/exclusive-time-of-functions/discuss/863039/Python-3-or-Clean-Simple-Stack-or-Explanation,"class Solution:
    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:
        helper = lambda log: (int(log[0]), log[1], int(log[2])) # to covert id and time to integer
        logs = [helper(log.split(':')) for log in logs]         # convert [string] to [(,,)]
        ans, s = [0] * n, []                                    # initialize answer and stack
        for (i, status, timestamp) in logs:                     # for each record
            if status == 'start':                               # if it's start
                if s: ans[s[-1][0]] += timestamp - s[-1][1]     # if s is not empty, update time spent on previous id (s[-1][0])
                s.append([i, timestamp])                        # then add to top of stack
            else:                                               # if it's end
                ans[i] += timestamp - s.pop()[1] + 1            # update time spend on `i`
                if s: s[-1][1] = timestamp+1                    # if s is not empty, udpate start time of previous id; 
        return ans",idontknoooo
637,https://leetcode.com/problems/average-of-levels-in-binary-tree/discuss/492462/PythonGo-O(n)-by-level-order-traversal.-w-Explanation,"class Solution:
    def averageOfLevels(self, root: TreeNode) -> List[float]:
        
        if not root:
            
            # Quick response for empty tree
            return []
        
        traversal_q = [root]
        
        average = []
        
        while traversal_q:
            
            # compute current level average
            cur_avg = sum( (node.val for node in traversal_q if node) ) / len(traversal_q)
            
            # add to result
            average.append( cur_avg )
            
            # update next level queue
            next_level_q = [ child for node in traversal_q for child in (node.left, node.right) if child ]
            
            # update traversal queue as next level's
            traversal_q = next_level_q
            
        return average",brianchiang_tw
638,https://leetcode.com/problems/shopping-offers/discuss/783072/Python-3-DFS-%2B-Memoization-(lru_cache),"class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        n = len(price)
        @lru_cache(maxsize=None)
        def dfs(needs):
            ans = sum([i*j for i, j in zip(price, needs)]) 
            cur = sys.maxsize
            for s in special:
                new_needs, ok = [], True
                for i in range(n):
                    need, give = needs[i], s[i]
                    if need < give:  # if over purchase, ignore this combination
                        ok = False
                        break
                    new_needs.append(need-give)    
                if ok: cur = min(cur, dfs(tuple(new_needs)) + s[-1])
            return min(ans, cur)
        return dfs(tuple(needs))",idontknoooo
639,https://leetcode.com/problems/decode-ways-ii/discuss/2509952/Best-Python3-implementation-(Top-93.7)-oror-Clean-code,"class Solution:
    def numDecodings(self, s: str) -> int:
        non_zero = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
        first_incl, second_incl = 1, 0
        first_excl, second_excl = 0, 0
        
        if s[0] in non_zero:
            second_incl = 1
        if s[0] == '*':
            second_incl = 9
            
        for i in range(1, len(s)):
            new_incl, new_excl = 0, 0
            if s[i] == '*':
                new_incl = 9 * (second_incl + second_excl)
                
                if s[i-1] == '1':
                    # number is of type (1, *)
                    new_excl = 9 * (first_incl + first_excl)
                    
                elif s[i-1] == '2':
                    # number is of type (2, *)
                    new_excl = 6 * (first_incl + first_excl)
                    
                elif s[i-1] == '*':
                    # number is of type (*, *)
                    new_excl = 15 * (first_incl + first_excl)
            else:
                if s[i] in non_zero:
                    new_incl = second_incl + second_excl
                        
                if s[i-1] == '*':
                    # number is of type (*,digit)
                    if int(s[i]) <= 6:
                        new_excl = 2 * (first_excl + first_incl)
                    else:
                        new_excl = first_incl + first_excl
                        
                else:
                    # number is of type (digit,digit)
                    val = int(s[i-1:i+1])
                    if 10 <= val <= 26:
                        new_excl = first_incl + first_excl
                    else:
                        new_excl = 0
            first_incl, first_excl = second_incl, second_excl
            second_incl, second_excl = new_incl, new_excl
        return (second_incl + second_excl) % (10**9 + 7)",UpperNoot
640,https://leetcode.com/problems/solve-the-equation/discuss/837106/Python-or-No-Regex-or-Simple-Logic-or-Probably-better-for-interviews-or-Commented,"class Solution:
    def solveEquation(self, equation: str) -> str:
        def helper(l,r): # left inclusive and right exclusive
            constant = unknown = 0
            sign,val = 1,''
            while l < r:
                if equation[l].isnumeric():
                    val += equation[l]
                elif equation[l] == 'x':
                    unknown += sign*int(val or '1') # in case the coefficient is 1
                    val = ''
                else: # meet a +/-
                    if val:
                        constant += sign*int(val)
                    sign = 1 if equation[l]=='+' else -1
                    val = ''
                l += 1
            if val: # if the last digit is a number
                constant += sign*i
            return constant,unknown
    
        mid = equation.find('=')
        constant1,unknown1 = helper(0,mid)
        constant2,unknown2 = helper(mid+1,len(equation))
        const,var = constant2-constant1,unknown1-unknown2
        # print(a,b)
        if var == 0:
            if const == 0: return ""Infinite solutions""
            else: return ""No solution""
        else: return 'x={}'.format(const//var)",since2020
643,https://leetcode.com/problems/maximum-average-subarray-i/discuss/336428/Solution-in-Python-3-(beats-100),"class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
    	M = d = 0
    	for i in range(len(nums)-k):
    		d += nums[i+k] - nums[i]
    		if d > M: M = d
    	return (sum(nums[:k])+M)/k
		
		
- Python 3
- Junaid Mansuri",junaidmansuri
645,https://leetcode.com/problems/set-mismatch/discuss/2733971/Easy-Python-Solution,"class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        c=Counter(nums)
        l=[0,0]
        for i in range(1,len(nums)+1):
            if c[i]==2:
                l[0]=i
            if c[i]==0:
                l[1]=i
        return l",Vistrit
646,https://leetcode.com/problems/maximum-length-of-pair-chain/discuss/1564508/Fast-O(NlogN)-and-simple-Python-3-solution,"class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs.sort()
        rt = 1
        l = pairs[0]
        for r in range(1,len(pairs)):
            if l[1] < pairs[r][0]:
                rt += 1 
                l = pairs[r]
            elif pairs[r][1]<l[1]:
                l = pairs[r]
        return rt",cyrille-k
647,https://leetcode.com/problems/palindromic-substrings/discuss/392119/Solution-in-Python-3-(beats-~94)-(six-lines)-(With-Detaiiled-Explanation),"class Solution:
    def countSubstrings(self, s: str) -> int:
	    L, r = len(s), 0
	    for i in range(L):
	    	for a,b in [(i,i),(i,i+1)]:
	    		while a >= 0 and b < L and s[a] == s[b]: a -= 1; b += 1
	    		r += (b-a)//2
	    return r
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
648,https://leetcode.com/problems/replace-words/discuss/1576514/Fast-solution-beats-97-submissions,"class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        d = {w:len(w) for w in dictionary}
        mini, maxi = min(d.values()), max(d.values())
        wd = sentence.split()
        rt = []
        for s in wd:
            c = s 
            for k in range(mini,min(maxi,len(s))+1):
                ss = s[:k]
                if ss in d:
                    c = ss 
                    break 
            rt.append(c)
        return "" "".join(rt)",cyrille-k
649,https://leetcode.com/problems/dota2-senate/discuss/845912/Python-3-or-Greedy-Simulation-or-Explanantion,"class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        n = len(senate)
        s, banned = set(), [False] * n
        ban_d = ban_r = 0
        while len(s) != 1:
            s = set()
            for i, p in enumerate(senate):
                if banned[i]: continue
                if p == 'R':
                    if ban_r > 0:           # current R being banned
                        ban_r -= 1
                        banned[i] = True
                    else:                   # if current R is valid, it will ban D
                        ban_d += 1
                        s.add('R')
                else:        
                    if ban_d > 0:           # current D being banned
                        ban_d -= 1
                        banned[i] = True
                    else:                   # if current D is valid, it will ban R
                        ban_r += 1
                        s.add('D')
        return 'Radiant' if s.pop() == 'R' else 'Dire'",idontknoooo
650,https://leetcode.com/problems/2-keys-keyboard/discuss/727856/Python3-Dynamic-Programming-Beginners,"class Solution:
    def minSteps(self, n: int) -> int:
        
        dp = [float('inf')] * (n+1)	
		## Intialize a dp array to store the solutions of sub problems i.e. number of steps needed
	
        dp[1] = 0
		## Intially first element of dp array with 0 as 'A' is already present and we haven't consumed any steps yet. 
		## As the value of n is from [1,3000] and initally 'A' is already present so we don't need to bother about the dp[0]
        
        divisors = []
		## This is to store the divisors of N
		
        for i in range(1, n//2 + 1):
            if n % i == 0:
                divisors.append(i)
		## We have stored all the divisors. For n = 10, divisors = [1,2,5]
        
        for j in divisors:
            dp[j] += 1
			##To copy the current number of A's, we add one step
			
            for i in range(j+1, n+1):
                if i % j == 0:
				## We can only form the string length which is divisible by j 
                    dp[i] = min(dp[i], dp[i-j] + 1)
					## Compare with previous number of steps and update with the minimum
        return dp[-1]
		#Return last value of dp i.e. N",ayushjain94
652,https://leetcode.com/problems/find-duplicate-subtrees/discuss/1178526/Easy-%2B-Clean-%2B-Straightforward-Python-Recursive,"class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        
        seen = collections.defaultdict(int)
        res = []
        
        def helper(node):
            if not node:
                return
            sub = tuple([helper(node.left), node.val, helper(node.right)])
            if sub in seen and seen[sub] == 1:
                res.append(node)
            seen[sub] += 1
            return sub
        
        helper(root)
        return res",Pythagoras_the_3rd
653,https://leetcode.com/problems/two-sum-iv-input-is-a-bst/discuss/1011974/BFS-two-pointers-and-recursive,"class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        queue = [root]
        unique_set = set()
        
        while len(queue) > 0:
            current = queue.pop()
            if k - current.val in unique_set: return True
            unique_set.add(current.val)
            if current.left: queue.append(current.left)
            if current.right: queue.append(current.right)
        
        return False",borodayev
654,https://leetcode.com/problems/maximum-binary-tree/discuss/944324/simple-python3-solution-with-recursion,"class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        
        # base case
        if not nums:
            return None
        
        max_val = max(nums)
        max_idx = nums.index(max_val)
        root = TreeNode(max_val)
        
        root.left = self.constructMaximumBinaryTree(nums[:max_idx])
        root.right = self.constructMaximumBinaryTree(nums[max_idx+1:])
        
        return root",Gushen88
655,https://leetcode.com/problems/print-binary-tree/discuss/1384379/Python-3-or-DFS-%2B-BFS-(Level-order-traversal)-or-Explanation,"class Solution:
    def printTree(self, root: TreeNode) -> List[List[str]]:
        height = 0
        def dfs(node, h):                               # Find height
            nonlocal height
            height = max(height, h)
            if node.left:
                dfs(node.left, h+1)
            if node.right:    
                dfs(node.right, h+1)
        dfs(root, 0)
        n = 2 ** (height + 1) - 1                       # Get `n`
        offset = (n - 1) // 2                           # Column for root node
        ans = [[''] * n for _ in range(height + 1)]
        q = [(root, 0, offset)]
        for i in range(height+1):                       # BFS
            tmp_q = []
            while q:
                cur, r, c = q.pop()
                ans[r][c] = str(cur.val)
                if cur.left:
                    tmp_q.append((cur.left, r+1, c-2 ** (height - r - 1)))
                if cur.right:    
                    tmp_q.append((cur.right, r+1, c+2 ** (height - r - 1)))
            q = tmp_q
        return ans",idontknoooo
657,https://leetcode.com/problems/robot-return-to-origin/discuss/342078/Solution-in-Python-3-(~beats-99)-(-one-line-),"class Solution:
    def judgeCircle(self, moves: str) -> bool:
        return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')


- Python 3
- Junaid Mansuri",junaidmansuri
658,https://leetcode.com/problems/find-k-closest-elements/discuss/1310805/Python-Solution,"class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
		# first binary search where the value 'x' should be in the sorted array
        n = len(arr)
        low, high = 0, n - 1
        while low <= high:
            mid = low + (high - low) // 2
            if arr[mid] == x:
                start, end = mid - 1, mid + 1
                k -= 1
                break
            elif arr[mid] < x:
                low = mid + 1
            else:
                high = mid - 1
                
        if low > high:
            start = high
            end = low
        #  after we found where 'x' should be in the sorted array we expand to the left and to the right to find the next values until k (using two pointers start, end)
        while k > 0:
            if start == -1:
                end += 1
            elif end == n:
                start -= 1
            else:
                if abs(arr[start] - x) <= abs(arr[end] - x):
                    start -= 1
                else:
                    end += 1
            k -= 1
        return arr[start + 1:end]",mariandanaila01
659,https://leetcode.com/problems/split-array-into-consecutive-subsequences/discuss/2446738/Python-524ms-98.3-Faster-Multiple-solutions-94-memory-efficient,"class Solution:
		def isPossible(self, nums: List[int]) -> bool:
			len1 = len2 = absorber = 0
			prev_num = nums[0] - 1
			for streak_len, streak_num in Solution.get_streaks(nums):
				if streak_num == prev_num + 1:
					spillage = streak_len - len1 - len2
					if spillage < 0:
						return False
					absorber = min(absorber, spillage)
					len1, len2, absorber = spillage - absorber, len1, absorber + len2
				else:
					if len1 or len2:
						return False
					absorber = 0
				prev_num = streak_num
			return len1 == len2 == 0

		@staticmethod
		def get_streaks(nums: List[int]):
			streak_num = nums[0]
			streak_len = 0
			for num in nums:
				if num == streak_num:
					streak_len += 1
				else:
					yield streak_len, streak_num
					streak_num = num
					streak_len = 1
			yield streak_len, streak_num",anuvabtest
661,https://leetcode.com/problems/image-smoother/discuss/454951/Python3-simple-solution,"class Solution:
    def imageSmoother(self, M: List[List[int]]) -> List[List[int]]:
        row, col = len(M), len(M[0])
        res = [[0]*col for i in range(row)]
        dirs = [[0,0],[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1],[-1,1],[1,-1]]
        for i in range(row):
            for j in range(col):
                temp = [M[i+m][j+n] for m,n in dirs if 0<=i+m<row and 0<=j+n<col]
                res[i][j] = sum(temp)//len(temp)
        return res",jb07
662,https://leetcode.com/problems/maximum-width-of-binary-tree/discuss/688259/Python-solution-O(N)-BFS-traversal,"class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        Q = collections.deque()
        Q.append((root,0))
        ans = 0
        while Q:
            length = len(Q)
            _, start = Q[0]
            for i in range(length):
                node, index = Q.popleft()
                if node.left:
                    Q.append((node.left, 2*index))
                if node.right:
                    Q.append((node.right, 2*index+1))
            ans = max(ans, index-start+1)
        return ans",realslimshady
664,https://leetcode.com/problems/strange-printer/discuss/1492420/Python3-dp,"class Solution:
    def strangePrinter(self, s: str) -> int:
        s = """".join(ch for i, ch in enumerate(s) if i == 0 or s[i-1] != ch)
        
        @cache
        def fn(lo, hi): 
            """"""Return min ops to print s[lo:hi].""""""
            if lo == hi: return 0
            ans = 1 + fn(lo+1, hi)
            for mid in range(lo+1, hi): 
                if s[lo] == s[mid]: 
                    ans = min(ans, fn(lo, mid) + fn(mid+1, hi))
            return ans 
        
        return fn(0, len(s))",ye15
665,https://leetcode.com/problems/non-decreasing-array/discuss/2193030/Python-Easy-Greedy-w-explanation-O(1)-space,"class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        cnt_violations=0        
        for i in range(1, len(nums)):                       
            if nums[i]<nums[i-1]:
                if cnt_violations==1:
                    return False
                cnt_violations+=1
                if i>=2 and nums[i-2]>nums[i]:
                    nums[i]=nums[i-1]                       
        return True",constantine786
667,https://leetcode.com/problems/beautiful-arrangement-ii/discuss/1158414/Python3-greedy,"class Solution:
    def constructArray(self, n: int, k: int) -> List[int]:
        lo, hi = 1, n 
        ans = []
        while lo <= hi: 
            if k&amp;1: 
                ans.append(lo)
                lo += 1
            else: 
                ans.append(hi)
                hi -= 1
            if k > 1: k -= 1
        return ans",ye15
668,https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/discuss/1581461/Binary-Search-Solution-with-detailed-explanation-beating-98-in-time-and-86-in-space,"class Solution:
    def findKthNumber(self, m: int, n: int, k: int) -> int:
		# special cases: k == 1,  k == m * n
        if k == 1: 
            return 1
        if k == m * n: 
            return m * n
		# make the matrix a tall one - height >= width 
		# because later I will loop along the width. This will reduce the time
        if n >= m: 
            m, n = n, m
        
		# set the left, right boundaries and the ranks (the largest ranks for the values)
		# e.g. in a 3 * 3 table, number 2 shows up twice, taking up ranks from 2 to 3
		# so the largest rank here is 3 for number 2. 
        left = 1
        # left_rank = 1
        right = m * n
        # right_rank = m * n
        
		# binary search loop
        while right - left > 1: 
            mid = (left + right) // 2
			# mid_rank is the largest rank of the number
            mid_rank = 0
			
			# find the number of columns whose maximum < mid
			# (mid - 1) is to prevent counting the column with maximum == mid.
            num_cols = (mid - 1) // m
            residual = mid - num_cols * m
            mid_rank += num_cols * m
            
			# flag to track if mid is a valid value in the table
            flag = 0
            for i in range(num_cols + 1, n + 1): 
                if i == mid: 
                    mid_rank += 1
                    break
                else: 
                    mid_rank += mid // i
                    if mid % i == 0: 
                        flag = 1
            if flag == 1: 
				# mid is a valid number in the table
				# if mid_rank == k: mid's largest rank is k and mid is the kth number
				# if mid_rank < k: kth number > mid, so left = mid
				# if mid_rank > k: mid's largest rank > k but mid still can be the kth number but kth number can be no larger than mid, so right = mid
                if mid_rank == k: 
                    return mid
                elif mid_rank > k: 
                    right = mid
                else: 
                    left = mid
            else: 
				# mid is not a valid number in the table
				# if mid_rank == k, it means there are k values in the table smaller than mid
				# so there is a number smaller than mid ranking the kth. 
				# mid_rank > k or mid_rank < k:  similar operation as above
                if mid_rank >= k: 
                    right = mid
                else: 
                    left = mid
        
		# In case the while loop breaks out without returning
		# let's assume when right - left == 2 and mid == left + 1. The solution must be among the three. 
		# right with its largest rank > k
		# left with its largest rank < k
		# Scenario 1. if mid is a valid number in the table
		## 1a. if mid_rank < k: right has its rank from mid_rank + 1 (<= k) till right_rank (> k)
		## 1b. if mid_rank > k: right = mid. Now right (== mid) has its rank from left_rank + 1 (<= k) till mid_rank (> k)
		## in both cases, right is the solution
		# Scenario 2. if mid is not a valid number in the table then we can just ignore mid and imply the solution is right. 
		## But step by step, as mid is not in the table, mid_rank == left_rank, so left = mid. 
		## So right has its rank from mid_rank + 1 (i.e. left_rank + 1) (<= k) till right_rank (> k). right is the solution. 
        return right",leonine9
669,https://leetcode.com/problems/trim-a-binary-search-tree/discuss/1046286/Python.-faster-than-98.05.-recursive.-6-lines.-DFS.,"class Solution:
	def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
		if not root: return root
		if root.val < low: return self.trimBST(root.right, low, high)
		if root.val > high: return self.trimBST(root.left, low, high)
		root.left = self.trimBST(root.left, low, high)
		root.right = self.trimBST(root.right, low, high)
		return root",m-d-f
670,https://leetcode.com/problems/maximum-swap/discuss/846837/Python-3-or-Greedy-Math-or-Explanations,"class Solution:
    def maximumSwap(self, num: int) -> int:
        s = list(str(num))
        n = len(s)
        for i in range(n-1):                                # find index where s[i] < s[i+1], meaning a chance to flip
            if s[i] < s[i+1]: break
        else: return num                                    # if nothing find, return num
        max_idx, max_val = i+1, s[i+1]                      # keep going right, find the maximum value index
        for j in range(i+1, n):
            if max_val <= s[j]: max_idx, max_val = j, s[j]
        left_idx = i                                        # going right from i, find most left value that is less than max_val
        for j in range(i, -1, -1):    
            if s[j] < max_val: left_idx = j
        s[max_idx], s[left_idx] = s[left_idx], s[max_idx]   # swap maximum after i and most left less than max
        return int(''.join(s))                              # re-create the integer",idontknoooo
671,https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/discuss/405721/Beats-100-Python-Solution,"class Solution:
	def findSecondMinimumValue(self, root: TreeNode) -> int:
		def inorderTraversal(root):
			if not root:
				return []
			else:
				return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)
		r = set(inorderTraversal(root))
		if len(r)>=2:
			return sorted(list(r))[1]
		else:
			return -1",saffi
672,https://leetcode.com/problems/bulb-switcher-ii/discuss/897976/Python3-O(1),"class Solution:
    def flipLights(self, n: int, m: int) -> int:
        
        def fn(n, m): 
            """"""Return number of different status.""""""
            if m * n == 0: return 1
            return fn(n-1, m-1) + fn(n-1, m)
        
        return fn(min(n, 3), min(m, 3))",ye15
673,https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/1881188/Python-DP-solution-explained,"class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        ct = [1] * len(nums)
        maxLen, maxCt = 0, 0
        
        # same as the LIS code, iterate
        # over all the elements once and then
        # from 0 -> i again to compute LISs
        for i in range(len(nums)):
            for j in range(i):
                # If it's a valid LIS
                if nums[i] > nums[j]:
                    # and if the length
                    # of LIS at i wrt j
                    # is going to be increased
                    # update the length dp
                    # and since this is just one
                    # continous LIS, count of i
                    # will become same as that of j
                    if dp[j]+1 > dp[i]:
                        dp[i] = dp[j] + 1
                        ct[i] = ct[j]
                    # if on the other hand, the
                    # length of the LIS at i becomes
                    # the same as it was, it means
                    # there's another LIS of this same
                    # length, in this case, add the LIS
                    # count of j to i, because the current
                    # LIS count at i consists of ways to get
                    # to this LIS from another path, and now
                    # we're at a new path, so sum thse up
                    # there's no point
                    # in updating the length LIS here.
                    elif dp[i] == dp[j] + 1:
                        ct[i] += ct[j]
            
            # at any point, keep track
            # of the maxLen and maxCt
            # we'll use it to compute our result
            if dp[i] > maxLen:
                maxLen = dp[i]
                
        # now, we have the maxLength
        # of the given nums, we can iterate
        # over all 3 arrays (hypothetically)
        # and just add up the count of all those
        # LIS which are the longest (maxLen)
        # and that's the result
        for i in range(len(nums)):
            if maxLen == dp[i]:
                maxCt += ct[i]
    
 
        return maxCt",buccatini
674,https://leetcode.com/problems/longest-continuous-increasing-subsequence/discuss/2445685/Two-python-solutions-using-dp-and-a-straightforward-soln,"class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        counter=1
        temp=1
        for i in range(0,len(nums)-1):
            if nums[i]<nums[i+1]:
                temp+=1
                if temp>counter:
                    counter=temp
            else:
                temp=1
        return counter",guneet100
675,https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/1204000/Python-normal-and-priority-BFS-faster-than-99-and-faster-than-77,"class Solution:
    def cutOffTree(self, forest: List[List[int]]) -> int:
        forest.append([0] * len(forest[0]))
        for row in forest: row.append(0)
        def bfs(end, start):
            if end == start: return 0
            visited, queue = set(), {start}
            visited.add(start)
            step = 0
            while queue:
                s = set()
                step += 1
                for p in queue:                    
                    for dr, dc in ((-1, 0), (1, 0), (0, 1), (0, -1)):
                        r, c = p[0] + dr, p[1] + dc
                        if not forest[r][c] or (r, c) in visited: continue
                        if (r, c) == end: return step
                        visited.add((r, c))
                        s.add((r, c))
                queue = s

        trees = [(height, r, c) for r, row in enumerate(forest) for c, height in enumerate(row) if forest[r][c] > 1]
        # check
        queue = [(0, 0)]
        reached = set()
        reached.add((0, 0))
        while queue:
            r, c = queue.pop()
            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                row, col = r + dr, c + dc
                if forest[row][col] and (row, col) not in reached:
                    queue.append((row, col))
                    reached.add((row,col))
        if not all([(i, j) in reached for (height, i, j) in trees]): return -1
        trees.sort()
        return sum([bfs((I,J),(i,j)) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees)])",dustlihy
678,https://leetcode.com/problems/valid-parenthesis-string/discuss/584655/Python-O(n)-by-stack.-85%2B-w-Comment,"class Solution:
    def checkValidString(self, s: str) -> bool:
        
        # store the indices of '('
        stk = []
        
        # store the indices of '*'
        star = []
        
        
        for idx, char in enumerate(s):
            
            if char == '(':
                stk.append( idx )
                
            elif char == ')':
                
                if stk:
                    stk.pop()
                elif star:
                    star.pop()
                else:
                    return False
            
            else:
                star.append( idx )
        
        
        # cancel ( and * with valid positions, i.e., '(' must be on the left hand side of '*'
        while stk and star:
            if stk[-1] > star[-1]:
                return False
        
            stk.pop()
            star.pop()
        
        
        # Accept when stack is empty, which means all braces are paired
        # Reject, otherwise.
        return len(stk) == 0",brianchiang_tw
680,https://leetcode.com/problems/valid-palindrome-ii/discuss/1409641/Python-3-oror-Two-Pointer-Approach-oror-Self-Understandable,"class Solution:
    def validPalindrome(self, s: str) -> bool:
            p1=0
            p2=len(s)-1
            while p1<=p2:
                if s[p1]!=s[p2]:
                    string1=s[:p1]+s[p1+1:]
                    string2=s[:p2]+s[p2+1:]
                    return string1==string1[::-1] or string2==string2[::-1]
                p1+=1
                p2-=1
            return True",bug_buster
682,https://leetcode.com/problems/baseball-game/discuss/380544/Two-Solutions-in-Python-3-(beats-~99),"class Solution:
    def calPoints(self, s: List[str]) -> int:
    	p = []
    	for i in s:
    		if i == 'C': p.pop()
    		elif i == 'D': p.append(2*p[-1])
    		elif i == '+': p.append(p[-1]+p[-2])
    		else: p.append(int(i))
    	return sum(p)",junaidmansuri
684,https://leetcode.com/problems/redundant-connection/discuss/2755933/Python-Union-Find-Easy,"class Solution(object):
    def findRedundantConnection(self, edges):
        self.parent = dict()
        
        for e in edges:
            
            f0 = self.find(e[0])
            f1 = self.find(e[1])
            if f0 == f1:
                return e
            
            self.parent[f0] = f1
            
    def find(self, x):
        if x not in self.parent:
            return x
    
        return self.find(self.parent[x])",lokeshsenthilkumar
686,https://leetcode.com/problems/repeated-string-match/discuss/330741/Simple-Python3-Solution-(beats-~100)-(my-first-post-on-LeetCode-!!!),"class Solution:
    def repeatedStringMatch(self, A: str, B: str) -> int:
    	if set(B).issubset(set(A)) == False: return -1
    	for i in range(1,int(len(B)/len(A))+3):
    		if B in A*i: return i
    	return -1
		
	- Python3
	- Junaid Mansuri",junaidmansuri
687,https://leetcode.com/problems/longest-univalue-path/discuss/902315/Python3-dfs-(post-order),"class Solution:
    def longestUnivaluePath(self, root: TreeNode) -> int:
        
        def dfs(node): 
            """"""Return longest univalue branch and longest univalue path (post-order traversal).""""""
            if not node: return 0, 0
            (lx, llup), (rx, rlup) = dfs(node.left), dfs(node.right) 
            if not node.left or node.left.val != node.val: lx = 0
            if not node.right or node.right.val != node.val: rx = 0 
            return 1 + max(lx, rx), max(llup, rlup, 1 + lx + rx)
        
        return max(0, dfs(root)[-1]-1)",ye15
688,https://leetcode.com/problems/knight-probability-in-chessboard/discuss/2193242/Python3-DFS-with-DP-beats-99-()()-Explained,"class Solution:
    def knightProbability(self, n: int, k: int, row0: int, col0: int) -> float:
	
		# precalculate possible moves
        adj_list = defaultdict(list)
        d = ((-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2))
        for row in range(n):
            for col in range(n):
                for dx, dy in d:
                    pos = (row + dx, col + dy)
                    if 0 <= pos[0] < n and 0 <= pos[1] < n:
                        adj_list[(row, col)].append(pos)

        @cache
        def get_leafs_num(pos, h):
            if h == k:
                return 1
            
            res = 0
            for next_pos in adj_list[pos]:
                res += get_leafs_num(next_pos, h + 1)
                
            return res            
            
        leafs_num = get_leafs_num((row0, col0), 0)

        return leafs_num / 8**k",artod
689,https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/discuss/1342651/Python3-dp,"class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        @cache
        def fn(i, n): 
            """"""Return max sum of 3 non-overlapping subarrays.""""""
            if n == 0: return []
            if i+k >= len(prefix): return []
            return max([i] + fn(i+k, n-1), fn(i+1, n), key=lambda x: sum(prefix[xx+k] - prefix[xx] for xx in x))
        
        return fn(0, 3)",ye15
690,https://leetcode.com/problems/employee-importance/discuss/332600/Iterative-Python-beats-99.73,"class Solution:
    def getImportance(self, employees, id):
        """"""
        :type employees: Employee
        :type id: int
        :rtype: int
        """"""
        id_to_emp = {employee.id: employee for employee in employees}
        importance = 0
        stack = [id_to_emp[id]]
        while stack:
            cur_emp = stack.pop()
            importance += cur_emp.importance
            stack.extend([id_to_emp[new_emp] for new_emp in cur_emp.subordinates])
        return importance",hgrsd
691,https://leetcode.com/problems/stickers-to-spell-word/discuss/1366983/Python3-dp,"class Solution:
    def minStickers(self, stickers: List[str], target: str) -> int:
        freqs = [Counter(x) for x in stickers]
        
        @cache
        def fn(x):
            """"""Return min sticks to give x.""""""
            if not x: return 0 
            ans = inf
            freq = Counter(x)
            for cnt in freqs: 
                if x[0] in cnt: 
                    xx = """".join(k*v for k, v in (freq - cnt).items())
                    ans = min(ans, 1 + fn(xx))
            return ans 
        
        ans = fn(target)
        return ans if ans < inf else -1",ye15
692,https://leetcode.com/problems/top-k-frequent-words/discuss/1657648/Simple-or-4-lines-or-using-heap-or-With-explanation,"class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        #Have a dict of word and its freq
        counts = collections.Counter(words)
        
        #get a array wchich will have a tuple of word and count
        heap = [(-count, word) for word, count in counts.items()]
        
        #as default heap structure in python min heap and we want max heap
        # to get top frequent word, we will do a make the counter negative
        #so that the topmost element will come up (i.e -8 < -2 so in min heap -8 will come up wich is actually 8)
        
        heapq.heapify(heap) #creating heap in place
        #by deualt it will sort by fre then word
        
        return [heapq.heappop(heap)[1] for _ in range(k)]",shraddhapp
693,https://leetcode.com/problems/binary-number-with-alternating-bits/discuss/1095502/Python3-simple-solution,"class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        s = bin(n).replace('0b','')
        for i in range(len(s)-1):
            if s[i] == s[i+1]:
                return False
        return True",EklavyaJoshi
695,https://leetcode.com/problems/max-area-of-island/discuss/1459194/python-Simple-and-intuitive-DFS-approach-!!!,"class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        if not grid:
            return 0
        
        maxArea = 0
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1: # run dfs only when we find a land
                    maxArea = max(maxArea, self.dfs(grid, i, j))
                    
        return maxArea
    
                    
    def dfs(self, grid, i, j):
		# conditions for out of bound and when we encounter water
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:
            return 0
        
        maxArea = 1
        grid[i][j] = '#'  # this will act as visited set
        maxArea += self.dfs(grid, i+1, j)
        maxArea += self.dfs(grid, i-1, j)
        maxArea += self.dfs(grid, i, j+1)
        maxArea += self.dfs(grid, i, j-1)
        
        return maxArea",nandanabhishek
696,https://leetcode.com/problems/count-binary-substrings/discuss/384054/Only-using-stack-with-one-iteration-logic-solution-in-Python-O(N),"class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        stack = [[], []]
        latest = int(s[0])
        stack[latest].append(latest)
        result = 0
        for i in range(1,len(s)):
            v = int(s[i])
            if v != latest:
                stack[v].clear()
                latest = v
            stack[v].append(v)
            if len(stack[1-v]) > 0:
                stack[1-v].pop()
                result += 1
        return result",zouqiwu09
697,https://leetcode.com/problems/degree-of-an-array/discuss/349801/Solution-in-Python-3-(beats-~98),"class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
    	C = {}
    	for i, n in enumerate(nums):
    		if n in C: C[n].append(i)
    		else: C[n] = [i]
    	M = max([len(i) for i in C.values()])
    	return min([i[-1]-i[0] for i in C.values() if len(i) == M]) + 1
		
		
- Junaid Mansuri",junaidmansuri
698,https://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/1627241/python-simple-with-detailed-explanation-or-96.13,"class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        if k==1:
            return True
        total = sum(nums)
        n = len(nums)
        if total%k!=0:
            return False
        nums.sort(reverse=True)
        average = total//k
        if nums[0]>average:
            return False
        
        visited = [False]*n
        def dfs(cur, begin, k):
            if k==0:
                return True
            if cur>average:
                return False
            elif cur==average:
                return dfs(0, 0, k-1)
            for i in range(begin, n):
                if not visited[i]:
                    visited[i] = True
                    if dfs(cur + nums[i], i+1, k):
                        return True
                    visited[i] = False
            return False
        
        return dfs(0, 0, k)",1579901970cg
699,https://leetcode.com/problems/falling-squares/discuss/2397036/faster-than-90.37-or-python-or-solution-or-explained,"class Solution:
    def fallingSquares(self, positions):
            height, pos, max_h,res = [0],[0],0,[]
            for left, side in positions:
                i = bisect.bisect_right(pos, left)
                j = bisect.bisect_left(pos, left + side)
                high = max(height[i - 1:j] or [0]) + side 
                pos[i:j] = [left, left + side]
                height[i:j] = [high, height[j - 1]]
                max_h = max(max_h, high)
                res.append(max_h)
            return res",vimla_kushwaha
712,https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/discuss/1516574/Greedy-oror-DP-oror-Same-as-LCS,"class Solution:
def minimumDeleteSum(self, s1: str, s2: str) -> int:
    
    def lcs(s,p):
        m,n = len(s),len(p)
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
        for i in range(m):
            for j in range(n):
                if s[i]==p[j]:
                    dp[i+1][j+1] = dp[i][j]+ord(s[i])
                else:
                    dp[i+1][j+1] = max(dp[i+1][j],dp[i][j+1])
                    
        return dp[-1][-1]
    
    common = lcs(s1,s2)
    total,res = 0,0
    for c in s1:
        total+=ord(c)
    for c in s2:
        total+=ord(c)
    
    res = total - common*2
    return res",abhi9Rai
713,https://leetcode.com/problems/subarray-product-less-than-k/discuss/481917/Python-sol.-based-on-sliding-window.-run-time-90%2B-w-Explanation,"class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        
        if k <= 1:
            # Quick response for invalid k on product of positive numbers
            return 0
        
        else:
            left_sentry = 0

            num_of_subarray = 0
            product_of_subarry = 1

            # update right bound of sliding window
            for right_sentry in range( len(nums) ):

                product_of_subarry *= nums[right_sentry]

                # update left bound of sliding window
                while product_of_subarry >= k:
                    product_of_subarry //= nums[left_sentry]
                    left_sentry += 1

                # Note:
                # window size = right_sentry - left_sentry + 1

                # update number of subarrary with product < k
                num_of_subarray += right_sentry - left_sentry + 1

            return num_of_subarray",brianchiang_tw
714,https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/1532323/Python3-dp,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy, sell = inf, 0
        for x in prices:
            buy = min(buy, x)
            sell = max(sell, x - buy)
        return sell",ye15
717,https://leetcode.com/problems/1-bit-and-2-bit-characters/discuss/2012976/Python-Clean-and-Simple!,"class Solution:
    def isOneBitCharacter(self, bits):
        i, n, numBits = 0, len(bits), 0
        while i < n:
            bit = bits[i]
            if bit == 1:
                i += 2
                numBits = 2
            else:
                i += 1
                numBits = 1
        return numBits == 1",domthedeveloper
718,https://leetcode.com/problems/maximum-length-of-repeated-subarray/discuss/2599501/LeetCode-The-Hard-Way-Explained-Line-By-Line,"class Solution:
    # DP Approach - Similar to 1143. Longest Common Subsequence
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        n, m = len(nums1), len(nums2)
        # dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        ans = 0
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                # if both character is same
                if nums1[i - 1] == nums2[j - 1]:
                    # then we add 1 to the previous state, which is dp[i - 1][j - 1]
                    # in other word, we extend the repeated subarray by 1
                    # e.g. a = [1], b = [1], length of repeated array is 1
                    #      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    # record the max ans here
                    ans = max(ans, dp[i][j])
                # else:
                    # if you are looking for longest common sequence,
                    # then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here
                    # however, this problem is looking for subarray,
                    # since both character is not equal, which means we need to break it here
                    # hence, set dp[i][j] to 0
        return ans",wingkwong
719,https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/2581420/Simple-python-binary-search,"class Solution:
	def smallestDistancePair(self, nums: List[int], k: int) -> int:

		def getPairs(diff):
			l = 0
			count = 0

			for r in range(len(nums)):
				while nums[r] - nums[l] > diff:
					l += 1
				count += r - l

			return count


		nums.sort()
		l, r = 0, nums[-1] - nums[0]

		while l < r:
			mid = (l + r) // 2
			res = getPairs(mid)

			if res >= k:
				r = mid
			else:
				l = mid + 1

		return l",shubhamnishad25
720,https://leetcode.com/problems/longest-word-in-dictionary/discuss/2075147/Python-O(n-log(n))-Time-O(n)-Space-Faster-Than-95,"class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort()                  # for smallest lexicographical order
        visited = {""""}                # hashset to keep a track of visited words
        res = ''
        
        for word in words:
            if word[:-1] in visited:     # check previous word ie. word[:len(word)-1] visited or not
                visited.add(word)        # add this word to the set
                if len(word) > len(res): # current word have greater lenght and lexicographically smaller
                    res = word           # update res
        
        return res
    
    
    
# Time: O(n log(n))   # for sorting the words
# Space: O(n)         # for making the set visited",samirpaul1
721,https://leetcode.com/problems/accounts-merge/discuss/2014051/Python-easy-to-read-and-understand-or-DFS,"class Solution:
    def dfs(self, graph, node, visit):
        visit.add(node)
        for nei in graph[node]:
            if nei not in visit:
                self.dfs(graph, nei, visit)
        self.res.append(node)
    
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        graph = collections.defaultdict(set)
        for account in accounts:
            for email in account[1:]:
                graph[account[1]].add(email)
                graph[email].add(account[1])
        #print(graph.items())
        
        visit = set()
        ans = []
        for account in accounts:
            name = account[0]
            for email in account[1:]:
                if email not in visit:
                    self.res = []
                    self.dfs(graph, email, visit)
                    ans.append([name]+sorted(self.res))
        return ans",sanial2001
722,https://leetcode.com/problems/remove-comments/discuss/2446606/Easy-to-understand-using-Python,"class Solution:
    def removeComments(self, source: List[str]) -> List[str]:
        ans, inComment = [], False
        new_str = """"
        for c in source:
            if not inComment: new_str = """"
            i, n = 0, len(c)
            # inComment, we find */
            while i < n:
                if inComment:
                    if c[i:i + 2] == '*/' and i + 1 < n:
                        i += 2
                        inComment = False
                        continue
                    i += 1
                # not in Comment, we find /* // and common character
                else:
                    if c[i:i + 2] == '/*' and i + 1 < n:
                        i += 2
                        inComment = True
                        continue
                    if c[i:i + 2] == '//' and i + 1 < n:
                        break
                    new_str += c[i]
                    i += 1
            if new_str and not inComment:
                ans.append(new_str)
                    

        return ans",fguo10
724,https://leetcode.com/problems/find-pivot-index/discuss/2321669/Python-99.85-faster-or-Simplest-solution-with-explanation-or-Beg-to-Adv-or-Prefix-Sum,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        left = 0 # nums[0] + nums[1] + ... + nums[middleIndex-1]
        right = sum(nums) # nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]

        for i, num in enumerate(nums): # we can use normal for loop as well.
            right -= num # as we are trying to find out pivot index so iteratively we`ll reduce the value of right to find the pivot index
            if left == right: # comparing the values for finding out the pivot index.
                return i # if there is any return the index whixh will be our required index.
            left += num # we have to add the num iteratively. 

        return -1",rlakshay14
725,https://leetcode.com/problems/split-linked-list-in-parts/discuss/1322974/Clean-Python-and-Java,"class Solution:
    def splitListToParts(self, head: ListNode, k: int) -> List[ListNode]:
        size = self.get_size(head)
        min_len, one_more = divmod(size, k)
        res = []
        current = ListNode()
        current.next = head
        for i in range(k):
            ans = current
            for _ in range(min_len + int(i < one_more)):
                current = current.next
            res.append(ans.next)
            ans.next = None
        return res

    def get_size(self, head: ListNode) -> int:
        size = 0
        while head is not None:
            size += 1
            head = head.next
        return size",aquafie
726,https://leetcode.com/problems/number-of-atoms/discuss/1335787/efficient-O(N)-python3-solution-using-stack-of-stacks-with-explanation-of-code-and-approach,"class Solution:
    def countOfAtoms(self, formula: str) -> str:
        # constant declarations
        upper=""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
        lower=upper.lower()
        digits = ""0123456789""
        
        # variables
        count=defaultdict(int)
        element_name = None
        element_name_parse_start=False
        element_count =""""
        bracket_stacks = [[]]
        buffer = []
        
        # function to parse out the complete number if a digit is seen, 
        # the function takes the character, that was seen as a digit and 
        # the generator object to get the remaining (yet to be read) part of formula
        def parseout_number(ch,gen):
            nonlocal buffer
            num=""""
            try:
                while ch in digits:
                    num += ch
                    ch = next(gen)
                # after number is parsed out and a non-number character is seen, 
                # add that non-number character to the buffer to be read next, dont miss parsing it
                buffer.append(ch)
            except StopIteration:
                # while iterating to find the end digit of the number, we have reached the end of the formula, 
                # meaning the digit ch and subsequent characters were numbers and were the last thing in the formula
				# the code, outside of try-catch handles all the possible scenerios of parsing the number out, 
				# so do nothing here. move along
                pass
            # if we saw a number, return it as integer, else return empty string
            if num != """":
                return int(num)
            else:
                return """"
        
        #generator expression
        formula_chars = (ch for ch in formula)
        
        # iterate over all characters
        for char in formula_chars:
            
            # add the character emitted by generator into buffer for processing
            buffer.append(char)
            
            # process what ever is in the buffer queue
            while buffer:
                ch = buffer.pop(0)
                
                # if the character is an upper case character
                # set the a flag to indicate start of a new element name
                # check if the previous elementname was added to the processing_stack (bracket_stacks)
                # if not then add it, noting one atom for that element
                # set the character to element_name variable
                if ch in upper:
                    element_name_parse_start=True
                    if element_name is not None and element_count == """":
                        bracket_stacks[-1].append([element_name,1])
                    element_name = ch
                # if character is lowercase, just concat it to the element_name
                elif ch in lower:
                    element_name += ch
                # if character is a numerical digit, then parse that number out completely as integer
                # set the flag to indicate the reading the element name is done
                # store the element name and it's corresponding count into the processing_stack
                # reset the variables element_name and element_count, ready for next element
                elif ch in digits:
                    element_name_parse_start=False
                    element_count = parseout_number(ch,formula_chars)
                    bracket_stacks[-1].append([element_name,element_count])
                    element_count = """"
                    element_name = None
                # if open bracket is seen, check if reading the element_name flag is still True
                # if it is then that element has one atom only
                # add it to the processing stack
                # set the flag to indicate that reading the 'element_name' is done and 
                # add another processing stack top the top of the 'bracket_stacks'
                # this new processing stack will have the atom details within the bracket
                # finally, reset all other variables to ensure 
				# clean slate for the new child 'processing-stack' before exiting the code-block
                elif ch == ""("":
                    if element_name_parse_start:
                        bracket_stacks[-1].append([element_name,1])
                    element_name_parse_start=False
                    element_count = """"
                    bracket_stacks.append([]) # new processing stack
                    element_name = None
                
                # if a bracket is closed
                # make sure we account for one atom of element, if a number was not seen before closing the bracket
                # set the flag to indicate we are done reading element_name
                # check what is the next character after the bracket close char. 
				# if it's a digit, then parse that number out 
                # that number is the multiplier for the current processing stack
                # which means we will need to multiply every atom/element count by the multiplier
                # at this point the current processing stack 
				# which was created as part of opening the bracket is processed
                # so, merge what we found into the parent processing stack by 
                # extending the parent processing stack with the results of the child stack
                elif ch == "")"":
                    if element_name_parse_start:
                        bracket_stacks[-1].append([element_name,1])
                    element_name = None
                    element_name_parse_start=False
                    braket_multiplier = """"
                    try:
                        next_ch= next(formula_chars)
                        braket_multiplier = parseout_number(next_ch,formula_chars)
                    except StopIteration:
                        pass
                    
                    if braket_multiplier == """":
                        braket_multiplier = 1
					# pop the child processing - stack to be processed
                    process_this = bracket_stacks.pop()
                    
					#processing
                    for idx,_ in enumerate(process_this):
                        process_this[idx][1] = process_this[idx][1]*braket_multiplier
					
					#merging processed child stack with the parent stack
                    bracket_stacks[-1].extend(process_this)
        
        # if the new element name seen flag is set then process that 
        # atom by adding it's element-name and atom count to the current processing stack
        if element_name_parse_start:
            if element_name is not None:
                if element_count != """":
                    bracket_stacks[-1].append([element_name,int(element_count)])
                else:
                    bracket_stacks[-1].append([element_name,1])
        
        # pop the top-level processing-stack, this should contain a 'flattened' version of the atoms and their counts
        # note that the counts of elements are not aggregated yet, 
        # eg:If Oxygen was seen within a bracket and also seen outside that bracket, 
        # then we'll have two entries for Oxygen. We'll aggregate them next...
        count_pairs = bracket_stacks.pop()
        
        # aggregate all the 'flattened' data in 'count_pairs' variable, using a dictionary
        for element_name,element_count in count_pairs:
            count[element_name]+= element_count
        
        # preparing the output string...
        # create a list meant to hold the 'words' of the output string, based on the description
        output=[]
        
        # fetch the keylist
        elements_list = list(count.keys())
        
        #sort it
        elements_list.sort()
        
        # for each element in the sorted keylist, if the element has more 
        # than 1 atom, append the atom and it's count
        # if element has only 1 atom only append the atom name, 
        # but don't append the atom's count (which is 1)
        for element in elements_list:
            if count[element] > 1:
                output.append(element)
                output.append(str(count[element]))
            else:
                output.append(element)
        
        # output will now have an list of words representation of what we need. turn the list into a string and return it
        return """".join(output)",anupamkumar
728,https://leetcode.com/problems/self-dividing-numbers/discuss/1233710/WEEB-DOES-PYTHON(BEATS-91.49),"class Solution:
	def selfDividingNumbers(self, left: int, right: int) -> List[int]:
		result = []

		for i in range(left, right+ 1):
			if ""0"" in str(i): continue
			val = i
			while val > 0:
				n = val % 10
				if i % n != 0:
					val = -1
				val = val // 10

			if val != -1: result.append(i)

		return result",Skywalker5423
729,https://leetcode.com/problems/my-calendar-i/discuss/2731671/Fastest-Python-solution-greater-Create-a-Binary-Search-Tree,"# Binary Search Tree Solution -> If exact matching of intervals found then return False
#                                Else you can add this interval to that particular node's left or right
class Node:
    def __init__(self, s, e):
        self.s = s
        self.e = e
        self.left = None
        self.right = None
class MyCalendar:
    def __init__(self):
        self.head = None
        
    def insert(self, s, e, node):
        if s >= node.e:
            if node.right: return self.insert(s, e, node.right)
            else: 
                nn = Node(s, e)
                node.right = nn
                return True
        elif e <= node.s:
            if node.left: return self.insert(s, e, node.left)
            else:
                nn = Node(s, e)
                node.left = nn
                return True
        else: return False
        
    def book(self, s: int, e: int) -> bool:
        if self.head == None:
            nn = Node(s, e)
            self.head = nn
            return True
        return self.insert(s, e, self.head)",shiv-codes
730,https://leetcode.com/problems/count-different-palindromic-subsequences/discuss/1612723/DP-Python,"class Solution:
    def countPalindromicSubsequences(self, s:str) -> int:
        
        @cache
        def fn(ch, i, j):
            if i > j:
                return 0
            
            if i == j and s[i] == ch:
                return 1
            
            if s[i] == s[j] == ch:
                return 2 + fn('a', i+1, j-1) + fn('b', i+1, j-1) + fn('c', i+1, j-1) + fn('d', i+1, j-1)
            elif s[i] != ch:
                return fn(ch, i+1, j)
            elif s[j] != ch:
                return fn(ch, i, j-1)
        
        
        n = len(s)
        return (fn('a', 0, n-1) + fn('b', 0, n-1) + fn('c', 0, n-1) + fn('d', 0, n-1)) % (10**9+7)",yshawn
733,https://leetcode.com/problems/flood-fill/discuss/626424/PythonJSGoC%2B%2B-sol-by-DFS-w-Comment,"class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        
        h, w = len(image), len(image[0])
        
		
        def dfs( r, c, src_color):
            
            if r < 0 or c < 0 or r >= h or c >= w or image[r][c] == newColor or image[r][c] != src_color:
                # Reject for invalid coordination, repeated traversal, or different color
                return
            
            # update color
            image[r][c] = newColor
            
            
            # DFS to 4-connected neighbors
            dfs( r-1, c, src_color )
            dfs( r+1, c, src_color )
            dfs( r, c-1, src_color )
            dfs( r, c+1, src_color )
            
        # ---------------------------------------------------------------------------
        
        dfs(sr, sc, src_color = image[sr][sc] )
        
        return image",brianchiang_tw
735,https://leetcode.com/problems/asteroid-collision/discuss/646757/Python3-concise-solution-Asteroid-Collision,"class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for a in asteroids:
            if a > 0:
                stack.append(a)
            else:
                while stack and stack[-1] > 0 and stack[-1] + a < 0:
                    stack.pop()
                if not stack or stack[-1] < 0:
                    stack.append(a)
                elif stack[-1] + a == 0:
                    stack.pop()
        return stack",r0bertz
736,https://leetcode.com/problems/parse-lisp-expression/discuss/2149196/Python3-Solution,"class Solution:
    def evaluate(self, expression: str) -> int:
        stack = []
        parenEnd = {}
        
        # Get the end parenthesis location 
        for idx, ch in enumerate(expression):
            if ch == '(':
                stack.append(idx)
            if ch == ')':
                parenEnd[stack.pop()] = idx

        # Parses the expression into a list, each new sublist is a set of parenthesis
        # Example: 
        # Input: ""(let x 2 (mult x (let x 3 y 4 (add x y))))""
        # Output: ['let', 'x', '2', ['mult', 'x', ['let', 'x', '3', 'y', '4', ['add', 'x', 'y']]]]
        def parse(lo, hi):
            arr = []
            word = []

            i = lo
            while i < hi:
                if expression[i] == '(':
                    arr.append(parse(i + 1, parenEnd[i]))
                    i = parenEnd[i]
                elif expression[i] == ' ' or expression[i] == ')' and word != []:
                    if ''.join(word) != '':
                        arr.append(''.join(word))
                    word = []
                    i += 1
                elif expression[i] != ')':
                    word.append(expression[i])
                    i += 1
                else:
                    i += 1


            if word != []:
                arr.append(''.join(word))

            return arr

        # Change string expression into the list expression
        expressionList = parse(1, len(expression) - 1)

        # Eval expression with starting scope (variables)
        return self.genEval(expressionList, {})
    
    def genEval(self, expression, scope):
        if type(expression) != list:
            # If expression is just a variable or int
            try:
                return int(expression)
            except:
                return scope[expression]
        else:
            if expression[0] == 'let':
                # Remove ""let"" from expression list
                expression = expression[1:]
                
                # This loop updates the scope (variables)
                while len(expression) > 2:
                    scope = self.letEval(expression, scope.copy())
                    expression = expression[2:]
                    
                # Return the last value
                return self.genEval(expression[0], scope.copy())
                
            if expression[0] == 'add':
                return self.addEval(expression, scope.copy())
                
            if expression[0] == 'mult':
                return self.multEval(expression, scope.copy())


    
    def letEval(self, expression, scope):
        scope[expression[0]] = self.genEval(expression[1], scope)
        return scope
    
    def addEval(self, expression, scope):
        return self.genEval(expression[1], scope) + self.genEval(expression[2], scope)
    
    def multEval(self, expression, scope):
        return self.genEval(expression[1], scope) * self.genEval(expression[2], scope)",krzys2194
738,https://leetcode.com/problems/monotone-increasing-digits/discuss/921119/Python3-O(N)-via-stack,"class Solution:
    def monotoneIncreasingDigits(self, N: int) -> int:
        nums = [int(x) for x in str(N)] # digits 
        stack = []
        for i, x in enumerate(nums): 
            while stack and stack[-1] > x: x = stack.pop() - 1
            stack.append(x) 
            if len(stack) <= i: break 
        return int("""".join(map(str, stack)).ljust(len(nums), ""9"")) # right padding with ""9""",ye15
739,https://leetcode.com/problems/daily-temperatures/discuss/2506436/Python-Stack-97.04-faster-or-Simplest-solution-with-explanation-or-Beg-to-Adv-or-Monotonic-Stack,"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        result = [0] * len(temperatures) # having list with 0`s elements of same lenght as temperature array.
        stack = [] # taking empty stack. 
        for index, temp in enumerate(temperatures): # Traversing through provided list. 
            while stack and temperatures[stack[-1]] < temp: # stack should not be empty and checking previous temp with current temp. 
                # the above while loop and taking stack for saving index is very common practice in monotonic stack questions. Suggestion: understand it properly. 
                prev_temp = stack.pop() # stack.pop() will provide index of prev temp, taking in separate var as we are using it more then on place. 
                result[prev_temp] = index - prev_temp #at the index of prev_temp and i - prev_temp by this we`ll get how many step we moved to have greater temp. 
            stack.append(index) # in case stack is empty we`ll push index in it. 

        return result # returing the list of number of days to wait.",rlakshay14
740,https://leetcode.com/problems/delete-and-earn/discuss/916859/Python3-top-down-dp,"class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        mp = {}
        for x in nums: mp[x] = x + mp.get(x, 0)
        
        @lru_cache(None)
        def fn(i): 
            """"""Return maximum points one can earn from nums[i:].""""""
            if i >= len(nums): return 0 
            if nums[i] + 1 not in mp: return mp[nums[i]] + fn(i+1)
            return max(mp[nums[i]] + fn(i+2), fn(i+1))
        
        nums = sorted(set(nums))
        return fn(0)",ye15
741,https://leetcode.com/problems/cherry-pickup/discuss/699169/Python3-dp,"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        
        @lru_cache(None)
        def fn(t, i, ii): 
            """"""Return maximum cherries collected at kth step when two robots are at ith and iith row""""""
            j, jj = t - i, t - ii #columns
            if not (0 <=  i < n and 0 <=  j < n) or t <  i or grid[ i][ j] == -1: return -inf #robot 1 not at proper location
            if not (0 <= ii < n and 0 <= jj < n) or t < ii or grid[ii][jj] == -1: return -inf #robot 2 not at proper location
            if t == 0: return grid[0][0] #starting from 0,0
            return grid[i][j] + (i != ii)*grid[ii][jj] + max(fn(t-1, x, y) for x in (i-1, i) for y in (ii-1, ii))
            
        return max(0, fn(2*n-2, n-1, n-1))",ye15
743,https://leetcode.com/problems/network-delay-time/discuss/2036405/Python-Simple-Dijkstra-Beats-~90,"class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:        
        adj_list = defaultdict(list)
        
        for x,y,w in times:
            adj_list[x].append((w, y))
        
        visited=set()
        heap = [(0, k)]
        while heap:
            travel_time, node = heapq.heappop(heap)
            visited.add(node)
            
            if len(visited)==n:
                return travel_time
            
            for time, adjacent_node in adj_list[node]:
                if adjacent_node not in visited:
                    heapq.heappush(heap, (travel_time+time, adjacent_node))
                
        return -1",constantine786
744,https://leetcode.com/problems/find-smallest-letter-greater-than-target/discuss/1568523/Python-easy-solution-with-detail-explanation-(modified-binary-search),"class Solution(object):
    def nextGreatestLetter(self, letters, target):
        """"""
        :type letters: List[str]
        :type target: str
        :rtype: str
        """"""
        
        # if the number is out of bound
        if target >= letters[-1] or target < letters[0]:
            return letters[0]
        
        low = 0
        high = len(letters)-1
        while low <= high:
            mid = (high+low)//2
            
            if  target >= letters[mid]: # in binary search this would be only greater than
                low = mid+1
            
            if target < letters[mid]:
                high = mid-1
                
        return letters[low]",Abeni
746,https://leetcode.com/problems/min-cost-climbing-stairs/discuss/2260902/94-FASTER-97-Space-Efficient-Python-solutions-Different-approaches,"class Solution:
	def minCostClimbingStairs(self, cost: List[int]) -> int:
		cur = 0 
		dp0 = cost[0]
		if len(cost) >= 2:
			dp1 = cost[1]

		for i in range(2, len(cost)):
			cur = cost[i] + min(dp0, dp1)
			dp0 = dp1
			dp1 = cur

		return min(dp0, dp1)",anuvabtest
747,https://leetcode.com/problems/largest-number-at-least-twice-of-others/discuss/2069691/no-loops,"class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
        if len(nums) is 1:
            return 0
        dom = max(nums)
        i = nums.index(dom)
        nums.remove(dom)
        if max(nums) * 2 <= dom:
            return i
        return -1",andrewnerdimo
748,https://leetcode.com/problems/shortest-completing-word/discuss/1277850/Python3-Simple-solution-without-Dictionary,"class Solution:
    def shortestCompletingWord(self, P: str, words: List[str]) -> str:
        alphs=""""
        res=""""        
        for p in P:
                if p.isalpha():
                        alphs+=p.lower()
        for word in words:                
                if all(alphs.count(alphs[i]) <= word.count(alphs[i]) for i in range(len(alphs))):
                        if res=="""" or len(res)>len(word):
                                res=word
        
        return res",Rei4126
749,https://leetcode.com/problems/contain-virus/discuss/2224726/Pyhon-Easy-Solution-oror-DFS-oror-Time-O(m*n*max(m-n))-oror-Faster,"class Solution:
    def containVirus(self, mat: List[List[int]]) -> int:
        m,n = len(mat),len(mat[0])

        def dfs(i,j,visited,nextInfected):  # return no. of walls require to quarantined dfs area
            if 0<=i<m and 0<=j<n and (i,j) not in visited:
                if mat[i][j]==2: # Already quarantined cell
                    return 0
                if mat[i][j]==0:
                    nextInfected.add((i,j)) # add cell which will be infected next day
                    return 1   # require one wall to quarantined cell from one side
                    
                else:
                    visited.add((i,j))
                    return dfs(i-1,j,visited,nextInfected) + dfs(i+1,j,visited,nextInfected) + dfs(i,j-1,visited,nextInfected) + dfs(i,j+1,visited,nextInfected)  # traverse all four direction
            else:
                return 0
				
        ans = 0 
        while True:   # this loop running ""how many days we should installing the walls"" times
            # For every day check which area infect more cells
            visited = set()  # Using in dfs
            All_nextinfect  = set()
            stop , walls = set(),0   # here stop store the indices of maximum no. of cells in which we stop spreading of virus this day
            
            for i in range(m):
                for j in range(n):
                    if mat[i][j]==1 and (i,j) not in visited:
                        nextInfected = set()
                        a = dfs(i,j,visited,nextInfected)
                        
                        if len(stop)<len(nextInfected):
                            All_nextinfect  = All_nextinfect | stop # leave previous saved area from virus
                            stop = nextInfected  # pick new area which we want to save
                            walls = a  # require walls
                            p,q = i,j  # starting position(indices) of this area
                        else:
                            All_nextinfect  = All_nextinfect | nextInfected   
                            
            if not stop : # if our job is done i.e. No cell will be infect Later
                break
            ans += walls  # add new walls installed this day
            
            # change each cell value to 2 which will be covered by quarantined area
            def fun(p,q):
                if 0<=p<m and 0<=q<n and mat[p][q]==1:
                    mat[p][q]=2
                    fun(p+1,q)
                    fun(p-1,q)
                    fun(p,q-1)
                    fun(p,q+1)
            fun(p,q) # start dfs from start point of quarantined area
            
            for a,b in All_nextinfect: # set new infected cell value = 1 for iterating next day
                mat[a][b] = 1

        return ans   # Final answer",Laxman_Singh_Saini
752,https://leetcode.com/problems/open-the-lock/discuss/1251501/Python-or-Bi-directional-A-star-BFS-or-99.7-or-52ms-or-14.3MB,"class Solution:
    def openLock(self, deadends: List[str], end: str) -> int:
        if end in deadends or ""0000"" in deadends:
            return -1
        if end == ""0000"":
            return 0
        start, end, deadends = 0, int(end), {int(deadend) for deadend in deadends}

        def distance(cur: int, target: int) -> int:
            diff = 0
            for _ in range(4):
                a, b = cur % 10, target % 10
                d = abs(a - b)
                diff += min(d, 10 - d)
                cur, target = cur // 10, target // 10
            return diff

		def turn_knob(cur: int, idx: int) -> Tuple[int, int]:
			index = 10 ** idx
			digit = cur // index % 10
			up = cur - 9 * index if digit == 9 else cur + index
			down = cur - index if digit else cur + 9 * index
			return up, down

        def process(
            this_q: List[int], this_v: Dict[int, int], other_v: Dict[int, int], target: int
        ) -> int:
            _, cur = heappop(this_q)
            step = this_v[cur]
            for i in range(4):
                up, down = turn_knob(cur, i)
                if up in other_v:
                    return step + other_v[up] + 1
                if down in other_v:
                    return step + other_v[down] + 1
                if up not in deadends and up not in this_v:
                    this_v[up] = step + 1
                    this_q.append((distance(up, target), up))
                if down not in deadends and down not in this_v:
                    this_v[down] = step + 1
                    this_q.append((distance(down, target), down))
            heapify(this_q)
            return None

        s_q, s_v = [(distance(start, end), start)], {start: 0}
        e_q, e_v = [(distance(end, start), end)], {end: 0}
        while s_q and e_q:
            s = process(s_q, s_v, e_v, end)
            if s: return s
            e = process(e_q, e_v, s_v, start)
            if e: return e
        return -1",PuneethaPai
753,https://leetcode.com/problems/cracking-the-safe/discuss/2825347/DFS-Solution-in-Python,"class Solution:
    def crackSafe(self, n: int, k: int) -> str:
        def dfs(path, visitedCombinations, targetNumVisited, combos):
            # Base Case. We've visited all possible combinations
            if len(visitedCombinations) == targetNumVisited:
                combos.append(''.join([str(x) for x in path]))
                return True
            # This if/else is necessary to prevent Python from picking up the first element if n = 1
            if n > 1:
                lastDigits = ''.join([str(x) for x in path[-(n-1):]])
            else:
                lastDigits = ''
            for i in range(k):
                path.append(i)
                newPwd = f'{lastDigits}{i}'
                # We have not reached the minimum pwd length. Continue recursion
                if len(newPwd) != n: 
                    if dfs(path, visitedCombinations, targetNumVisited, combos):
                        return True
                if len(newPwd) == n and newPwd not in visitedCombinations:
                    visitedCombinations[newPwd] = 1
                    if dfs(path, visitedCombinations, targetNumVisited, combos):
                        return True
                    del visitedCombinations[newPwd]
                path.pop()
            return False
                          
        
        # Empty visited Combinations hash set
        visitedCombinations = {}
        combos = []
        dfs([], visitedCombinations, k**n, combos)
        return combos[0]",user0138r
754,https://leetcode.com/problems/reach-a-number/discuss/991390/Python-Dummy-math-solution-easy-to-understand,"class Solution:
    def reachNumber(self, target: int) -> int:
        target = abs(target)
        step = 0
        far = 0
        while far < target or far%2 != target%2:
            step += 1
            far +=step
        
        return step",KevinZzz666
756,https://leetcode.com/problems/pyramid-transition-matrix/discuss/921324/Python3-progressively-building-new-rows,"class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        mp = {}
        for x, y, z in allowed: mp.setdefault((x, y), set()).add(z)
            
        def fn(row): 
            """"""Return list of rows built from given row.""""""
            ans = [""""]
            for x, y in zip(row, row[1:]):
                if (x, y) not in mp: return []
                ans = [xx + zz for xx in ans for zz in mp[x, y]]
            return ans 
        
        # dfs 
        stack = [bottom]
        while stack: 
            row = stack.pop()
            if len(row) == 1: return True 
            stack.extend(fn(row))
        return False",ye15
757,https://leetcode.com/problems/set-intersection-size-at-least-two/discuss/2700915/Python-Explained-or-O(nlogn),"class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda x:x[1])
        size = 0
        prev_start = -1
        prev_end = -1

        for curr_start, curr_end in intervals:
            if prev_start == -1 or prev_end < curr_start: #if intervals do not overlap
                size += 2
                prev_start = curr_end-1
                prev_end = curr_end

            elif prev_start < curr_start: #if intervals overlap
                if prev_end != curr_end:
                    prev_start = prev_end
                    prev_end = curr_end
                    
                else:
                    prev_start = curr_end-1
                    prev_end = curr_end

                size += 1

        return size",diwakar_4
761,https://leetcode.com/problems/special-binary-string/discuss/1498369/Easy-Approach-oror-Well-Explained-oror-Substring,"class Solution:
def makeLargestSpecial(self, s: str) -> str:
    
    l = 0
    balance = 0
    sublist = []
    for r in range(len(s)):
        balance += 1 if s[r]=='1' else -1
        if balance==0:
            sublist.append(""1"" + self.makeLargestSpecial(s[l+1:r])+ ""0"")
            l = r+1
    
    sublist.sort(reverse=True)
    return ''.join(sublist)",abhi9Rai
762,https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/discuss/1685874/Simple-python-code,"class Solution:
    def isPrime(self,x):
        flag=0
        if x==1:
            return False
        for i in range(2,x):
            if x%i==0:
                flag=1
                break
        if flag==1:
            return False
        return True
        
    def countPrimeSetBits(self, left: int, right: int) -> int:
        arr_dict={}
        lst=list(range(left,right+1))
        for i in lst:
            if i not in arr_dict:
                arr_dict[i]=bin(i).replace(""0b"","""")
        arr=list(arr_dict.values())
        count=0
        for i in arr:
            if self.isPrime(i.count('1')):
                # print(i)
                count+=1
        return count",amannarayansingh10
763,https://leetcode.com/problems/partition-labels/discuss/1868757/Python3-GREEDY-VALIDATION-(-)-Explained,"class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        L = len(s)
        last = {s[i]: i for i in range(L)} # last appearance of the letter
        i, ans = 0, []
        while i < L:
            end, j = last[s[i]], i + 1
            while j < end: # validation of the part [i, end]
                if last[s[j]] > end:
                    end = last[s[j]] # extend the part
                j += 1
           
            ans.append(end - i + 1)
            i = end + 1
            
        return ans",artod
764,https://leetcode.com/problems/largest-plus-sign/discuss/833937/Python-3-or-DP-Bomb-Enemy-or-Explanations,"class Solution:
    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:
        mat = [[1]*N for _ in range(N)]
        for x, y in mines: mat[x][y] = 0                   # create matrix with mine
            
        up = [[0]*N for _ in range(N)]                     # count 1s above mat[i][j] if mat[i][j] is 1
        for i in range(N):
            for j in range(N):
                if mat[i][j]: 
                    up[i][j] = 1
                    if i > 0: up[i][j] += up[i-1][j] 
                
        down = [[0]*N for _ in range(N)]                   # count 1s below mat[i][j] if mat[i][j] is 1
        for i in range(N-1, -1, -1):
            for j in range(N):
                if mat[i][j]: 
                    down[i][j] = 1
                    if i < N-1: down[i][j] += down[i+1][j] 
                    
        left = [[0]*N for _ in range(N)]                   # count 1s on the left side of mat[i][j] if mat[i][j] is 1
        for i in range(N):
            for j in range(N):
                if mat[i][j]:
                    left[i][j] = 1
                    if j > 0: left[i][j] += left[i][j-1]
                    
        right = [[0]*N for _ in range(N)]                  # count 1s on the right side of mat[i][j] if mat[i][j] is 1
        for i in range(N):
            for j in range(N-1, -1, -1):
                if mat[i][j]:
                    right[i][j] = 1
                    if j < N-1: right[i][j] += right[i][j+1]
         
		# find the largest + sign by using cached directions information
        return max(min([up[i][j], down[i][j], left[i][j], right[i][j]]) for i in range(N) for j in range(N))",idontknoooo
765,https://leetcode.com/problems/couples-holding-hands/discuss/1258087/Python3-a-few-approaches,"class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        loc = {x: i for i, x in enumerate(row)}
        ans = 0
        for i in range(0, len(row), 2): 
            p = row[i] - 1 if row[i]&amp;1 else row[i]+1
            if row[i+1] != p: 
                ans += 1
                ii = loc[p]
                loc[row[i+1]], loc[row[ii]] = loc[row[ii]], loc[row[i+1]] # swap mappings
                row[i+1], row[ii] = row[ii], row[i+1] # swap values 
        return ans",ye15
766,https://leetcode.com/problems/toeplitz-matrix/discuss/2761795/Python-Simple-and-Easy-Way-to-Solve-or-97-Faster,"class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]])->bool:
        r_len, c_len = len(matrix),len(matrix[0])
        
        for r in range (1, r_len):
            for c in range (1, c_len):
                if matrix[r][c]!=matrix[r-1][c-1]:
                    return False
        
        return True",pniraj657
767,https://leetcode.com/problems/reorganize-string/discuss/488325/Python-8-Liner-Memory-usage-less-than-100,"class Solution:
    def reorganizeString(self, S: str) -> str:
        counter = collections.Counter(S)
        i, res, n = 0, [None] * len(S), len(S)
        for k in sorted(counter, key = counter.get, reverse = True):
            if counter[k] > n // 2 + (n % 2): return """"
            for j in range(counter[k]):
                if i >= n: i = 1
                res[i] = k; i += 2
        return """".join(res)",mmbhatk
768,https://leetcode.com/problems/max-chunks-to-make-sorted-ii/discuss/1498733/Easy-to-Understand-oror-98-faster-oror-Well-Explained,"class Solution:
def maxChunksToSorted(self, nums: List[int]) -> int:
    
    st = []
    for n in nums:
        if len(st)==0 or st[-1]<=n:
            st.append(n)
        else:
            ma = st[-1]
            while st and st[-1]>n:
                ma = max(ma,st.pop())
            st.append(ma)
    
    return len(st)",abhi9Rai
769,https://leetcode.com/problems/max-chunks-to-make-sorted/discuss/1579999/Python3-Solution-with-using-stack,"class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        stack = []
        
        for num in arr:
            lagest = num
            while stack and num < stack[-1]:
                lagest = max(lagest, stack.pop())

            stack.append(lagest)
        
        return len(stack)",maosipov11
771,https://leetcode.com/problems/jewels-and-stones/discuss/362196/Solution-in-Python-3-(beats-~94)-(one-line)-(three-solutions),"class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
    	return sum(i in J for i in S)



class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
    	return sum(S.count(i) for i in J)



from collections import Counter

class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
    	return sum(Counter(S)[i] for i in J)
		
		

- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
773,https://leetcode.com/problems/sliding-puzzle/discuss/2831256/Python-BFS%3A-77-time-70-space,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def isSolved(board):
            if board[-1] != 0: return False
            for i in range(5):
                if board[i] != i + 1: return False
            return True
        
        swap = {
            0: [1, 3],
            1: [0, 2, 4],
            2: [1, 5],
            3: [0, 4],
            4: [1, 3, 5],
            5: [2, 4],
        }

        q = [board[0] + board[1]]
        steps = 0
        seen = set()
        while (len(q)):
            new_q = []
            for board in q:
                if tuple(board) in seen: continue
                seen.add(tuple(board))
                if isSolved(board): return steps

                zeroIdx = board.index(0)
                for swapIdx in swap[zeroIdx]:
                    copy = board.copy()
                    copy[zeroIdx], copy[swapIdx] = copy[swapIdx], copy[zeroIdx]
                    new_q.append(copy)
            steps += 1
            q = new_q

        return -1",hqz3
775,https://leetcode.com/problems/global-and-local-inversions/discuss/1084172/(Optimal-Solution)-Thinking-Process-Explained-in-More-Detail-than-You'd-Ever-Want,"class Solution:
    def isIdealPermutation(self, A: List[int]) -> bool:
        for i, a in enumerate(A):
            if (abs(a - i) > 1):
                return False
        
        return True",valige7091
777,https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/2712752/Python3-Solution-or-O(n)-or-Clean-and-Concise,"class Solution:
    def canTransform(self, S, E):
        L, R, X = 0, 0, 0
        for i, j in zip(S, E):
            L += (j == 'L')
            R += (i == 'R')
            if i == 'R' and L: return False
            if j == 'L' and R: return False
            L -= (i == 'L')
            R -= (j == 'R')
            if L < 0 or R < 0: return False
            X += (i == 'X') - (j == 'X')
        return X == 0",satyam2001
778,https://leetcode.com/problems/swim-in-rising-water/discuss/2464943/Easy-to-follow-python3-solutoon,"class Solution:
    # O(max(n^2, m)) time, h --> the highest elevation in the grid
    # O(n^2) space,
    # Approach: BFS, Priority queue
    # I wld advise to do task scheduler question, it's pretty similar
    # except that u apply bfs to traverse the grid 4 directionally
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)
        if n == 1:
            return 0
        
        def getNeighbours(coord: Tuple) -> List[Tuple]:
            i, j = coord
            n = len(grid)
            neighbours = []
            
            if i < n-1:
                neighbours.append((i+1, j))
            if i > 0:
                neighbours.append((i-1, j))
            if j < n-1:
                neighbours.append((i, j+1))
            if j > 0:
                neighbours.append((i, j-1))
                
            return neighbours
        
        qu = deque()
        waiting_qu = []
        vstd = set()
        waiting_qu.append([grid[0][0], (0, 0)])
        vstd.add((0, 0))
        time = 0
        
        while waiting_qu:
            time +=1
            while waiting_qu and waiting_qu[0][0] <= time:
                qu.append(heapq.heappop(waiting_qu)[1])
            
            while qu:
                cell = qu.popleft()
                if cell == (n-1, n-1):
                    return time
                nbrs = getNeighbours(cell)
                for nb in nbrs:
                    if nb in vstd:  continue
                    x, y = nb
                    elevation = grid[x][y]
                    vstd.add(nb)
                    if elevation > time:
                        heapq.heappush(waiting_qu, [elevation, nb])
                    else:
                        qu.append(nb)
        
        return -1",destifo
779,https://leetcode.com/problems/k-th-symbol-in-grammar/discuss/945679/Python-recursive-everything-you-need-to-know,"class Solution:
    
    def kthGrammar(self, N: int, K: int) -> int:
        if N == 1: 
            return 0
        half = 2**(N - 2) 
        
        if K > half:
            return 1 if self.kthGrammar(N - 1, K - half) == 0 else 0
        else:
            return self.kthGrammar(N - 1, K)",lattices
780,https://leetcode.com/problems/reaching-points/discuss/808072/Python-recursive-solution-runtime-beats-98.91,"class Solution:
    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
        if sx > tx or sy > ty: return False
        if sx == tx: return (ty-sy)%sx == 0 # only change y
        if sy == ty: return (tx-sx)%sy == 0
        if tx > ty: 
            return self.reachingPoints(sx, sy, tx%ty, ty) # make sure tx%ty < ty
        elif tx < ty: 
            return self.reachingPoints(sx, sy, tx, ty%tx)
        else:
            return False",yiz486
781,https://leetcode.com/problems/rabbits-in-forest/discuss/838445/Python-3-or-Hash-Table-1-liner-or-Explanations,"class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        return sum((key+1) * math.ceil(freq / (key+1)) if key+1 < freq else key+1 for key, freq in collections.Counter(answers).items())",idontknoooo
782,https://leetcode.com/problems/transform-to-chessboard/discuss/1305763/Python3-alternating-numbers,"class Solution:
    def movesToChessboard(self, board: List[List[int]]) -> int:
        n = len(board)
        
        def fn(vals): 
            """"""Return min moves to transform to chessboard.""""""
            total = odd = 0 
            for i, x in enumerate(vals): 
                if vals[0] == x: 
                    total += 1
                    if i&amp;1: odd += 1
                elif vals[0] ^ x != (1 << n) - 1: return inf
            ans = inf 
            if len(vals) <= 2*total <= len(vals)+1: ans = min(ans, odd)
            if len(vals)-1 <= 2*total <= len(vals): ans = min(ans, total - odd)
            return ans 
        
        rows, cols = [0]*n, [0]*n
        for i in range(n): 
            for j in range(n): 
                if board[i][j]: 
                    rows[i] ^= 1 << j 
                    cols[j] ^= 1 << i
        ans = fn(rows) + fn(cols)
        return ans if ans < inf else -1",ye15
783,https://leetcode.com/problems/minimum-distance-between-bst-nodes/discuss/1957176/Python-In-Order-Traversal-Explained-Well-Via-Comments,"class Solution:
    def minDiffInBST(self, root: Optional[TreeNode]) -> int:
        
        # list with two element
        # the first for the previous element
        # the second for the min value
        pre_mn = [-float(""inf""), float(""inf"")]
        
        def dfs(tree):
            
            if not tree:
                return
            
            # Keep going to the left
            dfs(tree.left)
            
            # if we can't go further, update min and pre
            pre_mn[1] = min(pre_mn[1], abs(tree.val) - pre_mn[0])
            pre_mn[0] = tree.val
            
            # keep traversing in-order
            dfs(tree.right)
        
        dfs(root)
        
        # return min (the second element in the list)
        return pre_mn[1]",Hejita
784,https://leetcode.com/problems/letter-case-permutation/discuss/379928/Python-clear-solution,"class Solution(object):
    def letterCasePermutation(self, S):
        """"""
        :type S: str
        :rtype: List[str]
        """"""
        def backtrack(sub="""", i=0):
            if len(sub) == len(S):
                res.append(sub)
            else:
                if S[i].isalpha():
                    backtrack(sub + S[i].swapcase(), i + 1)
                backtrack(sub + S[i], i + 1)
                
        res = []
        backtrack()
        return res",DenysCoder
785,https://leetcode.com/problems/is-graph-bipartite/discuss/1990803/JavaC%2B%2BPythonJavaScriptKotlinSwiftO(n)timeBEATS-99.97-MEMORYSPEED-0ms-APRIL-2022,"class Solution:

    def isBipartite(self, graph: list[list[int]]) -> bool:
	
        vis = [False for n in range(0, len(graph))]
        
        while sum(vis) != len(graph): # Since graph isn't required to be connected this process needs to be repeated

            ind = vis.index(False) # Find the first entry in the visited list that is false
            vis[ind] = True
            grp = {ind:True} # initialize first node as part of group 1
            q = [ind] # Add current index to queue
            
            while q: # Go to each node in the graph
                u = q.pop(0)

                for v in graph[u]: # Go to each vertice connected to the current node

                    if vis[v] == True: #  If visited check that it is in the opposite group of the current node
                        if grp[u] == grp[v]:
                            return False # If a single edge does not lead to a group change return false

                    else: # If not visited put v in opposite group of u, set to visited, and append to q
                        vis[v] = True
                        grp[v] = not grp[u]
                        q.append(v)
        
        return True",cucerdariancatalin
786,https://leetcode.com/problems/k-th-smallest-prime-fraction/discuss/2121258/Explained-Easiest-Python-Solution,"class Solution:

	def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
		if len(arr) > 2:
			res = []  # list for storing the list: [prime fraction of arr[i]/arr[j], arr[i], arr[j]]

			for i in range(len(arr)):
				for j in range(i + 1, len(arr)):
					# creating and adding the sublist to res
					tmp = [arr[i] / arr[j], arr[i], arr[j]]
					res.append(tmp)

			# sorting res on the basis of value of arr[i] 
			res.sort(key=lambda x: x[0])

			# creating and returning the required list
			return [res[k - 1][1], res[k - 1][2]]
		else:
			return arr",the_sky_high
787,https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/2066105/Python-Easy-Solution-using-Dijkstra's-Algorithm,"class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        #Make graph
        adj_list = {i:[] for i in range(n)}
        for frm, to, price in flights:
            adj_list[frm].append((to, price))
        
        best_visited = [2**31]*n # Initialized to maximum
        
        prior_queue = [ (0, -1, src) ]  # weight, steps, node

        while prior_queue:
            cost, steps, node = heapq.heappop(prior_queue)
            
            if best_visited[node] <= steps:  # Have seen the node already, and the current steps are more than last time
                continue

            if steps > k:  # More than k stops, invalid
                continue

            if node==dst:  # reach the destination # as priority_queue is a minHeap so this cost is the most minimum cost.
                return cost
            
            best_visited[node] = steps # Update steps

            for neighb, weight in adj_list[node]:
                heapq.heappush(prior_queue, (cost + weight, steps + 1, neighb))

        return -1
		
# Time: O(n * len(flights) * log(n))
# Space: O(n)",samirpaul1
788,https://leetcode.com/problems/rotated-digits/discuss/1205605/Python3-simple-solution-using-two-approaches,"class Solution:
    def rotatedDigits(self, N: int) -> int:
        count = 0
        for x in range(1, N+1):
            x = str(x)
            if '3' in x or '4' in x or '7' in x:
                continue
            if '2' in x or '5' in x or '6' in x or '9' in x:
                count+=1
        return count",EklavyaJoshi
789,https://leetcode.com/problems/escape-the-ghosts/discuss/1477363/Python-3-or-Manhattan-Distance-Math-or-Explanation,"class Solution:
    def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:
        t_x, t_y = target
        m_x, m_y = abs(t_x), abs(t_y)
        for x, y in ghosts:
            manhattan = abs(t_x - x) + abs(t_y - y)
            if manhattan <= m_x + m_y:
                return False
        return True",idontknoooo
790,https://leetcode.com/problems/domino-and-tromino-tiling/discuss/1620809/PythonJAVACC%2B%2B-DP-oror-Image-Visualized-Explanation-oror-100-Faster-oror-O(N),"class Solution(object):
    def numTilings(self, n):
        dp = [1, 2, 5] + [0] * n
        for i in range(3, n):
            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007
        return dp[n - 1]",linfq
791,https://leetcode.com/problems/custom-sort-string/discuss/2237060/Simple-yet-interview-friendly-or-Faster-than-99.97-or-Custom-Sorting-in-Python,"class Solution:
    def customSortString(self, order: str, s: str) -> str:

        rank = [26]*26
        
        for i in range(len(order)):
            rank[ord(order[i]) - ord('a')] = i

        return """".join(sorted(list(s), key= lambda x: rank[ord(x) - ord('a')]))",reinkarnation
792,https://leetcode.com/problems/number-of-matching-subsequences/discuss/1289476/Easy-Approach-oror-Well-explained-oror-95-faster,"class Solution:
def numMatchingSubseq(self, s: str, words: List[str]) -> int:
    
    def is_sub(word):
        index=-1
        for ch in word:
            index=s.find(ch,index+1)
            if index==-1:
                return False
        return True
    
    c=0
    for word in words:
        if is_sub(word):
            c+=1
    
    return c",abhi9Rai
793,https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function/discuss/1306028/Python3-binary-search,"class Solution:
    def preimageSizeFZF(self, k: int) -> int:
        lo, hi = 0, 1 << 32
        while lo <= hi: 
            mid = lo + hi >> 1
            x, y = mid, 0 
            while x: 
                x //= 5
                y += x
            if y < k: lo = mid + 1
            elif y > k: hi = mid - 1
            else: return 5
        return 0",ye15
794,https://leetcode.com/problems/valid-tic-tac-toe-state/discuss/2269469/Python3-oror-int-array-7-lines-w-explanation-oror-TM%3A-98-49,"class Solution:
    def validTicTacToe(self, board: List[str]) -> bool:
                                            # The two criteria for a valid board are:
                                            #   1) num of Xs - num of Os is 0 or 1
                                            #   2) X is not a winner if the # of moves is even, and
                                            #      O is not a winner if the # of moves is odd.

        d = {'X': 1, 'O': -1, ' ': 0}               # transform the 1x3 str array to a 1x9 int array
        s = [d[ch] for ch in ''.join(board)]        # Ex: [""XOX"","" X "",""   ""] --> [1,-1,1,0,1,0,0,0,0]
        sm = sum(s)

        if sm>>1: return False                                      # <-- criterion 1
        
        n = -3 if sm == 1 else 3                                    # <-- criterion 2.
        if n in {s[0]+s[1]+s[2], s[3]+s[4]+s[5], s[6]+s[7]+s[8], 
                 s[0]+s[3]+s[6], s[1]+s[4]+s[7], s[2]+s[5]+s[8],         # the elements of the set are 
                 s[0]+s[4]+s[8], s[2]+s[4]+s[6]}: return False           # the rows, cols, and diags
        
        return True                                                 # <-- both criteria are true",warrenruud
795,https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/discuss/2304108/Python-or-Two-pointer-technique-or-Easy-solution,"class Solution:
    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:
        start,end = -1, -1
        res = 0
        for i in range(len(nums)):
            if nums[i] > right:
                start = end = i
                continue
                
            if nums[i] >= left:
                end = i
                
            res += end - start
        return res",__Asrar
796,https://leetcode.com/problems/rotate-string/discuss/2369025/or-python3-or-ONE-LINE-or-FASTER-THAN-99-or,"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        return len(s) == len(goal) and s in goal+goal",sahelriaz
797,https://leetcode.com/problems/all-paths-from-source-to-target/discuss/752799/Python-simple-BFS-solution-explained,"class Solution:
     def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
            q = [[0]]
            result = []
            target = len(graph) - 1
            
            while q:
                temp = q.pop(0)
                
                if temp[-1] == target:
                    result.append(temp)
                else:
                    for neighbor in graph[temp[-1]]:
                        q.append(temp + [neighbor])
            
            return result",spec_he123
798,https://leetcode.com/problems/smallest-rotation-with-highest-score/discuss/1307760/Python3-difference-array,"class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        diff = [0]*(len(nums) + 1)
        for i, x in enumerate(nums): 
            diff[i+1] += 1
            if x <= i: diff[0] += 1
            diff[(i-x)%len(nums) + 1] -= 1
        
        ans = prefix = 0 
        mx = -inf 
        for i, x in enumerate(diff): 
            prefix += x
            if prefix > mx: mx, ans = prefix, i
        return ans",ye15
799,https://leetcode.com/problems/champagne-tower/discuss/1818232/Python-Easy-Solution-or-95-Faster-or-Dynamic-Programming,"class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        dp = [[0 for _ in range(x)] for x in range(1, query_row + 2)]
        dp[0][0] = poured
        
        for i in range(query_row):
            for j in range(len(dp[i])):
                temp = (dp[i][j] - 1) / 2.0
                if temp>0:
                    dp[i+1][j] += temp
                    dp[i+1][j+1] += temp
        
        return dp[query_row][query_glass] if dp[query_row][query_glass] <= 1 else 1",pniraj657
801,https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/discuss/932390/Python3-two-counters,"class Solution:
    def minSwap(self, A: List[int], B: List[int]) -> int:
        ans = sm = lg = mx = 0
        for x, y in zip(A, B): 
            if mx < min(x, y): # prev max < current min
                ans += min(sm, lg) # update answer &amp; reset 
                sm = lg = 0 
            mx = max(x, y)
            if x < y: sm += 1 # count ""x < y""
            elif x > y: lg += 1 # count ""x > y""
        return ans + min(sm, lg)",ye15
802,https://leetcode.com/problems/find-eventual-safe-states/discuss/1317749/Python-DFS-Easy,"class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n=len(graph)
        status=[0]*(n)
        res=[]
        
        def dfs(i):# this function will check is there any loop, cycle and i is a part of that loop,cycle 
            if status[i]==""visited"": #if this node is already visited, loop detected return true
                return True
            if status[i]==""safe"": #if this node is previously visited and marked safe no need to repeat it ,return False no loop possible from it
                return False
            status[i]=""visited"" # so we have visited this node
            for j in graph[i]:
                if  dfs(j):# if loop detected return True
                    return True
            status[i]=""safe"" # if we reached till here means no loop detected from node i so this node is safe
            return False # no loop possible return false
       
    
        for i in range(n):
            if not dfs(i): #if no loop detected this node is safe 
                res.append(i)
        return res",manmohan1105
804,https://leetcode.com/problems/unique-morse-code-words/discuss/2438206/Python-Elegant-and-Short-or-Two-lines-or-No-loops,"class Solution:
	""""""
	Time:   O(n)
	Memory: O(n)
	""""""

	MORSE = {
		'a': '.-',   'b': '-...', 'c': '-.-.', 'd': '-..',  'e': '.',    'f': '..-.', 'g': '--.',
		'h': '....', 'i': '..',   'j': '.---', 'k': '-.-',  'l': '.-..', 'm': '--',   'n': '-.',
		'o': '---',  'p': '.--.', 'q': '--.-', 'r': '.-.',  's': '...',  't': '-',    'u': '..-',
		'v': '...-', 'w': '.--',  'x': '-..-', 'y': '-.--', 'z': '--..',
	}

	def uniqueMorseRepresentations(self, words: List[str]) -> int:
		return len(set(map(self.encode, words)))

	@classmethod
	def encode(cls, word: str) -> str:
		return ''.join(map(cls.MORSE.get, word))",Kyrylo-Ktl
805,https://leetcode.com/problems/split-array-with-same-average/discuss/120654/Simple-python-with-explanation,"class Solution(object):
    def splitArraySameAverage(self, A):
        if len(A)==1: return False
        global_avg = sum(A)/float(len(A))
        for lenB in range(1, len(A)/2+1):
            if int(lenB*global_avg) == lenB*global_avg:
                if self.exist(lenB*global_avg, lenB, A):
                    return True
        return False
            
    def exist(self, tosum, item_count, arr):
        if item_count==0:
            return False if tosum else True
        if item_count > len(arr) or not arr: 
            return False
        if any([self.exist(tosum-arr[0], item_count-1, arr[1:]),
               self.exist(tosum, item_count, arr[1:])]):
            return True
        return False",licaiuu
806,https://leetcode.com/problems/number-of-lines-to-write-string/discuss/1170893/Python3-97-Faster-Solution,"class Solution:
    def numberOfLines(self, widths: List[int], s: str) -> List[int]:
        count = ans =  wi = 0
        s = list(s)
        while s:
            val = ord(s[0]) - 97
            
            if(widths[val] + wi > 100):
                wi = 0
                count += 1
            
            wi += widths[val]
            
            s.pop(0)
        return([count + 1 , wi])",VoidCupboard
807,https://leetcode.com/problems/max-increase-to-keep-city-skyline/discuss/445773/Python-3-(two-lines)-(beats-~100),"class Solution:
    def maxIncreaseKeepingSkyline(self, G: List[List[int]]) -> int:
        M, N, R, C = len(G), len(G[0]), [max(r) for r in G], [max(c) for c in zip(*G)]
        return sum(min(R[i],C[j]) - G[i][j] for i,j in itertools.product(range(M),range(N)))
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
808,https://leetcode.com/problems/soup-servings/discuss/1651208/Python-3-or-Bottom-up-and-Top-down-DP-or-Explanation,"class Solution:
    def soupServings(self, n: int) -> float:
        @cache                                 # cache the result for input (a, b)
        def dfs(a, b):
            if a <= 0 and b > 0: return 1      # set criteria probability
            elif a <= 0 and b <= 0: return 0.5
            elif a > 0 and b <= 0: return 0
            return (dfs(a-4, b) + dfs(a-3, b-1) + dfs(a-2, b-2) + dfs(a-1, b-3)) * 0.25 # dfs
        if n > 4275: return 1                  # observe the distribution you will find `a` tends to be easier to get used up than `b`
        n /= 25                                # reduce the input scale
        return dfs(n, n)                       # both soup have `n` ml",idontknoooo
809,https://leetcode.com/problems/expressive-words/discuss/1507874/Problem-description-is-horrible...-but-here's-simple-python-solution,"class Solution:
    def expressiveWords(self, s: str, words: List[str]) -> int:
        
        def summarize(word):
            res = []
            
            n = len(word)
            i, j = 0, 0
            while i<=j and j <= n-1:
                while j <= n-1 and word[j] == word[i]:
                    j += 1
                res.append(word[i])
                res.append(j-i)
                i = j
            return res
        
        t = 0 
        start = summarize(s)
        n = len(start)//2
        def compare(w):
            r = summarize(w)
        
            if len(r) != len(start):
                return False 
            for i in range(0, 2*n, 2):
                if start[i] != r[i]:
                    return False
                elif start[i] == r[i]:
                    if start[i+1] < r[i+1]:
                        return False
                    elif start[i+1] == r[i+1]:
                        pass 
                    elif start[i+1] < 3:
                        return False
            return True

        for w in words:
            if compare(w):
                t += 1
        return t",byuns9334
810,https://leetcode.com/problems/chalkboard-xor-game/discuss/2729320/Simple-python-code-with-explanation,"class Solution:
    def xorGame(self, nums):
        #create a variable 0 
        x = 0 
        #iterate over the elements in the nums
        for i in nums:
            #do xor of all the elements
            x ^= i 
        #Alice wins in two situations :
        #1.if the xor is already 0 (x == 0 )
        #2.if the length of nums is even because if alice got chance with even length and xor != 0 he will select a number so that he will leave the odd number of same integer 
        #if nums == [a,a,a,b] then alice erase b so bob must erase from [a,a,a] so he will lose if he erase any number 
        return x == 0 or len(nums)%2 == 0 
        #in other situations bob will win",thomanani
811,https://leetcode.com/problems/subdomain-visit-count/discuss/914736/Python3-100-faster-100-less-memory-(32ms-14.1mb),"class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        d = defaultdict(int)
        for s in cpdomains:
            cnt, s = s.split()
            cnt = int(cnt)
            d[s] += cnt
            pos = s.find('.') + 1
            while pos > 0:
                d[s[pos:]] += cnt
                pos = s.find('.', pos) + 1
        for x, i in d.items():
            yield f'{i} {x}'",haasosaurus
812,https://leetcode.com/problems/largest-triangle-area/discuss/1585033/Python-oror-Faster-than-93-oror-Simple-maths-oror-with-explanation,"class Solution:
    def largestTriangleArea(self, points: List[List[int]]) -> float:        
       
        area = 0
        n = len(points)
        for i in range(n):
            x1,y1 = points[i]
            for j in range(i+1,n):
                x2,y2 = points[j]
                for k in range(j+1,n):
                    x3,y3 = points[k]
                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))
                    if curr>area:
                        area = curr
        return area",ana_2kacer
813,https://leetcode.com/problems/largest-sum-of-averages/discuss/1633894/Python-3-Solution-Using-Memoization,"class Solution:
    def largestSumOfAverages(self, nums: List[int], k: int) -> float:
        
        @lru_cache(maxsize=None)
        def maxAvgSum(index: int, partitions_left: int) -> int:
            if partitions_left == 1:
                return sum(nums[index:]) / (len(nums) - index)

            max_sum: float = 0.0
            for i in range(index, len(nums) - (partitions_left - 1)):
                cur_sum: float = sum(nums[index:i + 1])/(i + 1 - index)
                cur_sum += maxAvgSum(i + 1, partitions_left - 1)
                max_sum = max(cur_sum, max_sum)
            return max_sum
    
        return maxAvgSum(0, k)",mlalma
814,https://leetcode.com/problems/binary-tree-pruning/discuss/298312/Python-faster-than-98-16-ms,"class Solution(object):
    def pruneTree(self, root):
        """"""
        :type root: TreeNode
        :rtype: TreeNode
        """"""
        if root==None:
            return None
        _l = self.pruneTree(root.left)
        _r = self.pruneTree(root.right)
        if root.val == 0 and _l == None and _r == None:
            return None
        else:
            root.left = _l
            root.right = _r
        return root",il_buono
815,https://leetcode.com/problems/bus-routes/discuss/2275016/Python3-BFS-Approach,"class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        m = defaultdict(set)
        for i, route in enumerate(routes):
            for node in route:
                m[node].add(i)
        ans = -1
        vis = set()
        queue = deque()
        queue.append(source)
        while queue:
            l = len(queue)
            ans += 1
            for _ in range(l):
                cur = queue.popleft()
                if cur == target:
                    return ans
                for bus in m[cur]:
                    if bus not in vis:
                        vis.add(bus)
                        queue.extend(routes[bus])
        return -1",van_fantasy
816,https://leetcode.com/problems/ambiguous-coordinates/discuss/934654/Python3-valid-numbers,"class Solution:
    def ambiguousCoordinates(self, s: str) -> List[str]:
        s = s.strip(""("").strip("")"")
        
        def fn(s): 
            """"""Return valid numbers from s.""""""
            if len(s) == 1: return [s]
            if s.startswith(""0"") and s.endswith(""0""): return []
            if s.startswith(""0""): return [s[:1] + ""."" + s[1:]]
            if s.endswith(""0""): return [s]
            return [s[:i] + ""."" + s[i:] for i in range(1, len(s))] + [s]
        
        ans = []
        for i in range(1, len(s)): 
            for x in fn(s[:i]):
                for y in fn(s[i:]): 
                    ans.append(f""({x}, {y})"")
        return ans",ye15
817,https://leetcode.com/problems/linked-list-components/discuss/933679/Python3-counting-end-of-component,"class Solution:
    def numComponents(self, head: ListNode, G: List[int]) -> int:
        Gs = set(G)
        ans = 0
        while head: 
            if head.val in Gs and (head.next is None or head.next.val not in Gs): ans += 1
            head = head.next 
        return ans",ye15
818,https://leetcode.com/problems/race-car/discuss/1512080/Greedy-Approach-oror-Normal-conditions-oror-94-faster-oror-Well-Coded,"class Solution:
def racecar(self, target: int) -> int:
    
    q = deque()
    q.append((0,0,1))
    while q:
        m,p,s = q.popleft()
        if p==target:
            return m
        rev = -1 if s>0 else 1
		
        q.append((m+1,p+s,s*2))
        
        if (p+s<target and s<0) or (p+s>target and s>0):        # If you are back to the target and speed is reverse or if you are ahead of target and speed is positive then reverse the speed
            q.append((m+1,p,rev))
    
    return -1",abhi9Rai
819,https://leetcode.com/problems/most-common-word/discuss/2830994/Python-oror-Long-but-FAST-oror-Memory-beats-82.67!,"class Solution:
    def getSplit(self, s):
        result = []
        strS = ''
        for i in s.lower():
            if i not in ""!?',;. "": strS += i
            else:
                if len(strS) > 0: result.append(strS)
                strS = ''
        if len(strS) > 0: result.append(strS)
        return result

    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = self.getSplit(paragraph)
        freq = {}
        for s in paragraph:
            if s not in banned:
                if s in freq: freq[s] += 1
                else: freq[s] = 1
                
        m = max(freq.values())
        for k in freq:
            if freq[k] == m: return k",qiy2019
820,https://leetcode.com/problems/short-encoding-of-words/discuss/2172401/Python-Concise-Brute-Force-and-Trie-Solutions-with-Explanation,"class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        words.sort(key=len, reverse=True)
        res = []
        for suffix in words:
            if not any(word.endswith(suffix) for word in res):  # check that this word is not actually a suffix
                res.append(suffix)
        return sum(len(word)+1 for word in res)  # append hash '#' symbol to each word that is not a suffix",zayne-siew
821,https://leetcode.com/problems/shortest-distance-to-a-character/discuss/1226696/Python3Any-improvement,"class Solution:
    def shortestToChar(self, s: str, c: str) -> List[int]:
        L = []
        for idx, value in enumerate(s):
            if value == c:
                L.append(idx)
        
        distance = []
        i = 0
        for idx, value in enumerate(s):
            if value == c:
                distance.append(0)
                i += 1
            elif idx < L[0]:
                distance.append(L[0] - idx)
            elif idx > L[-1]:
                distance.append(idx - L[-1])
            else:
                distance.append(min((L[i] - idx), (idx - L[i-1])))                    
        return distance",qiaochow
822,https://leetcode.com/problems/card-flipping-game/discuss/530999/Python3-simple-solution-using-a-for()-loop,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        """"""
        O(n) time complexity: n is length of fronts
        O(n) space complexity
        """"""
        same = {x for i, x in enumerate(fronts) if x == backs[i]}
        res = 9999
        for i in range(len(fronts)):
            if fronts[i] not in same: res = min(res, fronts[i])
            if backs[i] not in same: res = min(res, backs[i])
        return res % 9999",jb07
823,https://leetcode.com/problems/binary-trees-with-factors/discuss/2402569/Python-oror-Detailed-Explanation-oror-Easily-Understood-oror-DP-oror-O(n-*-sqrt(n)),"class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        total_nums = len(arr)
        moduler = 1000000007
        count_product_dict = {num: 1 for num in arr}
        arr.sort()

        for i in range(1, total_nums):
            for j in range(i):
                quotient = arr[i] // arr[j]
                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:
                    break
                if arr[i] % arr[j] == 0:
                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)
                    count_product_dict[arr[i]] %= moduler
                    
        return sum(count_product_dict.values()) % moduler",wingskh
824,https://leetcode.com/problems/goat-latin/discuss/1877272/Python-3-Simple-Solution-w-Explanation,"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        new = sentence.split() # Breaks up the input into individual sentences
        count = 1 # Starting at 1 since we only have one ""a"" to begin with.
        
        for x in range(len(new)):
            if new[x][0].casefold() in 'aeiou': # Checks if the first value of x is a vowel. The casefold, can be replaced with lower, lowers the case. Can also just be removed and have ""in 'aeiouAEIOU'
                new[x] = new[x] + 'ma' + 'a'*count # Brings it together with the count multiplying number of ""a""'s as needed.
                count += 1
            elif new[x].casefold() not in 'aeiou': # Same comment as above.
                new[x] = new[x][1:] + new[x][0] + 'ma' + 'a'*count # Just moves the first value to the end then does the a.
                count += 1
        
        return "" "".join(x for x in new) # Converts the list back into a string.",IvanTsukei
825,https://leetcode.com/problems/friends-of-appropriate-ages/discuss/2074946/Python-3-or-Three-Methods-(Binary-Search-CounterHashmap-Math)-or-Explanation,"class Solution:
    def numFriendRequests(self, ages: List[int]) -> int:
        ages.sort()                                   # sort the `ages`
        ans = 0
        n = len(ages)
        for idx, age in enumerate(ages):              # for each age
            lb = age                                  # lower bound
            ub = (age - 7) * 2                        # upper bound
            i = bisect.bisect_left(ages, lb)          # binary search lower bound
            j = bisect.bisect_left(ages, ub)          # binary search upper bound
            if j - i <= 0: continue
            ans += j - i                              # count number of potential friends
            if lb <= age < ub:                        # ignore itself
                ans -= 1
        return ans",idontknoooo
826,https://leetcode.com/problems/most-profit-assigning-work/discuss/2603913/Python3-or-Solved-Using-Binary-Search-W-Sorting-O((n%2Bm)*logn)-Runtime-Solution!,"class Solution:
    #Time-Complexity: O(n + nlogn + n + mlog(n)) -> O((n+m) *logn)
    #Space-Complexity: O(n)
    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
        #Approach: First of all, linearly traverse each and every corresponding index
        #position of first two input arrays: difficulty and profit to group each
        #item by 1-d array and put it in separate 2-d array. Then, sort the 2-d array
        #by increasing difficulty of the job! Then, for each worker, perform binary
        #search and consistently update the max profit the current worker can work and
        #earn! Add this value to answer variable, which is cumulative for all workers!
        #this will be the result returned at the end!
        arr = []
        for i in range(len(difficulty)):
            arr.append([difficulty[i], profit[i]])
        #sort by difficulty!
        arr.sort(key = lambda x: x[0])
        #then, I need to update the maximum profit up to each and every item!
        maximum = float(-inf)
        for j in range(len(arr)):
            maximum = max(maximum, arr[j][1])
            arr[j][1] = maximum
        ans = 0
        #iterate through each and every worker!
        for w in worker:
            bestProfit = 0
            #define search space to perform binary search!
            L, R = 0, len(arr) - 1
            #as long as search space has at least one element to consider or one job,
            #continue iterations of binary search!
            while L <= R:
                mid = (L + R) // 2
                mid_e = arr[mid]
                #check if current job has difficulty that is manageable!
                if(mid_e[0] <= w):
                    bestProfit = max(bestProfit, mid_e[1])
                    #we still need to search right and try higher difficulty
                    #jobs that might yield higher profit!
                    L = mid + 1
                    continue
                else:
                    R = mid - 1
                    continue
            #once we break from while loop and end binary search, we should have
            #found bestProfit for current worker performing task that is manageable!
            ans += bestProfit
        return ans",JOON1234
827,https://leetcode.com/problems/making-a-large-island/discuss/1340782/Python-Clean-DFS,"class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        N = len(grid)
        DIRECTIONS = [(-1, 0), (0, -1), (0, 1), (1, 0)]
        
		address = {}
        def dfs(row, column, island_id):
            queue = deque([(row, column, island_id)])
            visited.add((row, column))
            area = 1
            while queue: 
                row, column, island_id = queue.pop()
                address[(row, column)] = island_id
                for direction in DIRECTIONS:
                    r, c = row + direction[0], column + direction[1]
                    if r in range(N) and c in range(N) and grid[r][c] == 1 and (r, c) not in visited:
                        queue.append((r, c, island_id))
                        visited.add((r, c))
                        area += 1
            return area
        
        visited = set()
        area = {}
        island_id = 0
        for row in range(N):
            for column in range(N):
                if grid[row][column] == 1 and (row, column) not in visited:
                    area[island_id] = dfs(row, column, island_id)
                    island_id += 1
                    
        if len(address.keys()) == N**2: return N**2   
        
        largest_area = 1
        for row in range(N):
            for column in range(N):
                if grid[row][column] == 1: continue
                neighbours = set()
                large_area = 1
                for direction in DIRECTIONS:
                    r, c = row + direction[0], column + direction[1]
                    if r in range(N) and c in range(N) and grid[r][c] == 1 and address[(r, c)] not in neighbours:
                        neighbours.add(address[(r, c)])
                        large_area += area[address[(r, c)]]
                largest_area = max(largest_area, large_area)
                
        return largest_area",soma28
828,https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/2140546/Python-O(n)-with-intuition-step-by-step-thought-process,"class Solution:
    def uniqueLetterString(self, s: str) -> int:
        r=0
        for i in range(len(s)):
            for j in range(i, len(s)):
                ss=s[i:j+1]
                unique=sum([ 1 for (i,v) in Counter(ss).items() if v == 1 ])
                r+=unique
        return r",alskdjfhg123
829,https://leetcode.com/problems/consecutive-numbers-sum/discuss/1466133/8-lines-Python3-code,"class Solution:
    def consecutiveNumbersSum(self, n: int) -> int:
        csum=0
        result=0
        for i in range(1,n+1):
            csum+=i-1
            if csum>=n:
                break
            if (n-csum)%i==0:
                result+=1
        return result",tongho
830,https://leetcode.com/problems/positions-of-large-groups/discuss/1831860/Python-simple-and-elegant-multiple-solutions-%22Streak%22,"class Solution(object):
    def largeGroupPositions(self, s):
        s += "" ""
        
        streak, char, out = 0, s[0], []
        
        for i,c in enumerate(s):
            if c != char:
                if streak >= 3:
                    out.append([i-streak, i-1])
                
                streak, char = 0, s[i]
                
            streak += 1
        
        return out",domthedeveloper
831,https://leetcode.com/problems/masking-personal-information/discuss/1868652/3-Lines-Python-Solution-oror-98-Faster-oror-Memory-less-than-87,"class Solution:
    def maskPII(self, s: str) -> str:
        if '@' in s: return f'{s[0].lower()}*****{s[s.index(""@"")-1].lower()+"""".join([x.lower() for x in s[s.index(""@""):]])}'
        s=''.join([x for x in s if x not in '()- +'])
        return ('' if len(s)<=10 else '+'+'*'*(len(s)-10)+'-')+f'***-***-{s[-4:]}'",Taha-C
832,https://leetcode.com/problems/flipping-an-image/discuss/1363051/PYTHON-VERY-VERY-EASY-SOLN.-3-solutions-explained-O(n).-With-or-without-inbuilt-functions.,"class Solution:
    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:
        """"""
        Simple &amp; striaghtforward without using inbuilt functions.
     
        In actual the run time is very less as we are iterating only n/2 time
        for each image list.
        Time complexity : O(n * n/2) == O(n^2) 
        Space complexity : O(1)
        """"""
        
        for im in image: #Iterate through each im list in the image list.
            i, j = 0, len(im)-1    #Maintain two pointers one at start and one at end.
            while i <= j:          #Iterate while first pointer is less than or equal to second pointer.
                im[i], im[j] = im[j]^1, im[i]^1   #swap element at both pointer &amp; complement them at the same time.
                i +=1              #increment first pointer to move forward
                j -=1              #decrement second pointer to move backward
            
        return image         # return same list
    
    
        """"""
        Using inbuilt functions
        """"""
        # for im in range(len(image)):
        #     image[im] = list(map(lambda a : abs(a-1), reversed(image[im])))
        # return image
    
        """"""
        One liner
        """"""
        return [[i^1 for i in im[::-1]] for im in image]",er1shivam
833,https://leetcode.com/problems/find-and-replace-in-string/discuss/1920198/Python-3-or-simple-or-3-lines-of-code-w-explanation,"class Solution:
    def findReplaceString(self, s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:
        # iterate from the greater index to the smallest
        for i, src, tg in sorted(list(zip(indices, sources, targets)), reverse=True):    
            # if found the pattern matches with the source, replace with the target accordingly
            if s[i:i+len(src)] == src: s = s[:i] + tg + s[i+len(src):]            
        return s",Ploypaphat
834,https://leetcode.com/problems/sum-of-distances-in-tree/discuss/1311639/Python3-post-order-and-pre-order-dfs,"class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = {}
        for u, v in edges: 
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)
        
        size = [0]*n
        
        def fn(x, par): 
            """"""Return size and sum of distances in sub-tree.""""""
            c = s = 0
            for xx in graph.get(x, []): 
                if xx != par: 
                    cc, ss = fn(xx, x)
                    c, s = c + cc, s + ss + cc
            size[x] = c + 1
            return c + 1, s
        
        ans = [0]*n
        ans[0] = fn(0, -1)[1]
        
        stack = [0]
        while stack: 
            x = stack.pop()
            for xx in graph.get(x, []): 
                if not ans[xx]: 
                    ans[xx] = ans[x] + n - 2*size[xx]
                    stack.append(xx)
        return ans",ye15
835,https://leetcode.com/problems/image-overlap/discuss/2748733/Python-(Faster-than-82)-or-Brute-force-(Recursive)-and-optimized-using-HashMap,"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        n = len(img1)
        bestOverlap = 0

        def helper(dr, dc):
            overlap = 0
            for r in range(n):
                for c in range(n):
                    nr, nc = r + dr, c + dc
                    if nr in range(n) and nc in range(n) and img1[nr][nc] == 1 and img2[r][c] == 1:
                        overlap += 1

            return overlap

        for r in range(-n, n):
            for c in range(-n, n):
                bestOverlap = max(helper(r, c), bestOverlap)

        return bestOverlap",KevinJM17
836,https://leetcode.com/problems/rectangle-overlap/discuss/342095/Solution-in-Python-3-(beats-100)-(-2-lines-),"class Solution:
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:
        [A,B,C,D], [E,F,G,H] = rec1, rec2
        return F<D and E<C and B<H and A<G
		
		
- Python 3
- Junaid Mansuri",junaidmansuri
837,https://leetcode.com/problems/new-21-game/discuss/938221/Python3-top-down-and-bottom-up-dp,"class Solution:
    def new21Game(self, N: int, K: int, W: int) -> float:
        
        @lru_cache(None)
        def fn(n): 
            """"""Return prob of of points between K and N given current point n.""""""
            if N < n: return 0
            if K <= n: return 1
            if n+1 < K: return (1+W)/W*fn(n+1) - 1/W*fn(n+W+1)
            return 1/W*sum(fn(n+i) for i in range(1, W+1))
        
        return fn(0)",ye15
838,https://leetcode.com/problems/push-dominoes/discuss/2629832/Easy-Python-O(n)-solution,"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        dominoes = 'L' + dominoes + 'R'
        res = []
        left = 0
        
        for right in range(1, len(dominoes)):
            if dominoes[right] == '.': 
                continue
                
            middle = right - left - 1
            if left: 
                res.append(dominoes[left])
            if dominoes[left] == dominoes[right]: 
                res.append(dominoes[left] * middle)
            elif dominoes[left] == 'L' and dominoes[right] == 'R':
                res.append('.' * middle)
            else: 
                res.append('R' * (middle // 2) + '.' * (middle % 2) + 'L' * (middle // 2))
            left = right
            
        return ''.join(res)",namanxk
839,https://leetcode.com/problems/similar-string-groups/discuss/2698654/My-Python-Union-Find-Solution,"class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        N = len(strs)
        parent = [i for i in range(N)]
        depth = [1 for _ in range(N)]

        def find(idx):
            if idx != parent[idx]:
                return find(parent[idx])
            return idx
        
        def union(idx1, idx2):
            p1 = find(idx1)
            p2 = find(idx2)
            if p1 == p2: return
            if depth[p1] < depth[p2]:
                parent[p1] = p2
            elif depth[p2] < depth[p1]:
                parent[p2] = p1
            else:
                parent[p2] = p1
                depth[p1] += 1

        def similar(w1, w2):
            dif_idx = -1
            for idx in range(len(w1)):
                if w1[idx] != w2[idx]:
                    if dif_idx < 0:
                        dif_idx = idx
                    else:
                        if w1[dif_idx] != w2[idx]: return False
                        if w2[dif_idx] != w1[idx]: return False
                        if w1[idx+1:] != w2[idx+1:]: return False
                        return True
            return True
                    
        for idx in range(1, N):
            for pid in range(0, idx):
                if similar(strs[pid], strs[idx]):
                    union(pid, idx)

        return len([i for i, p in enumerate(parent) if i==p])",MonQiQi
841,https://leetcode.com/problems/keys-and-rooms/discuss/1116836/Python3-Soln-greater-Keys-and-Rooms-stack-implementation,"class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited_rooms = set()
        stack = [0] # for rooms that we need to visit and we start from room [0]
        
        while stack: 
            room = stack.pop() 
            visited_rooms.add(room)
            for key in rooms[room]:
                if key not in visited_rooms:
                    stack.append(key)
        return len(visited_rooms) == len(rooms)",avEraGeC0der
842,https://leetcode.com/problems/split-array-into-fibonacci-sequence/discuss/1579510/PYTHON-BACKTRACKING-or-THREE-PROBLEMS-ONE-SOLUTION,"class Solution:
    def splitIntoFibonacci(self, num: str) -> List[int]:
        def dfs(i):
            if i>=len(num):
                return len(ans)>2           
            n = 0
            for j in range(i, len(num)):
                n = n*10 + int(num[j]) 
                if n>2**31: # if number exceeds the range mentioned
                    return False
                # if len < 2 we know more elements need to be appended
                # as size>=3 if size is already greater we check for fibonacci
                # as last + secondLast == curr
                if len(ans)<2 or (ans[-1]+ans[-2]==n):
                    ans.append(n)
                    if dfs(j+1):
                        return True
                    ans.pop()
                if i==j and num[j]=='0': # if trailing 0 is present
                    return False
        
        if len(num)<=2: return []
        ans = []
        if dfs(0): return ans
        return []",hX_
843,https://leetcode.com/problems/guess-the-word/discuss/2385099/Python-Solution-with-narrowed-candidates-and-blacklist,"class Solution:
    def findSecretWord(self, words: List[str], master: 'Master') -> None:        
        k = 1 # for tracing the number of loops
        matches = 0
        blacklists = [[] for i in range(6)]
        
        while matches != 6:
            n = len(words)
            r = random.randint(0, n - 1)
            matches = master.guess(words[r])
            key = words[r]
            # print(k, n, r, matches, key)
            
            words.pop(r)
            
            if matches == 0:
                for i in range(6):
                    blacklists[i].append(key[i])
                # print(blacklists)
            
            elif matches > 0 and matches < 6:
                candidates = []
                for i in range(n - 1):
                    count = 0
                    for j in range(6):
                        if words[i][j] not in blacklists[j] and words[i][j] == key[j]:
                            count += 1
                    if count >= matches:
                        candidates.append(words[i])
                            
                words = candidates.copy()
                # print(words)
            
            k += 1",bbshark
850,https://leetcode.com/problems/rectangle-area-ii/discuss/1398210/Python3-sweeping,"class Solution:
    def rectangleArea(self, rectangles: List[List[int]]) -> int:
        line = []
        for x1, y1, x2, y2 in rectangles: 
            line.append((y1, x1, x2, 1))
            line.append((y2, x1, x2, 0))
        
        ans = yy = val = 0
        seg = []
        for y, x1, x2, tf in sorted(line): 
            ans += val * (y - yy)
            yy = y 
            if tf: insort(seg, (x1, x2))
            else: seg.remove((x1, x2))
            val = 0 
            prev = -inf 
            for x1, x2 in seg: 
                val += max(0, x2 - max(x1, prev))
                prev = max(prev, x2)
        return ans % 1_000_000_007",ye15
851,https://leetcode.com/problems/loud-and-rich/discuss/2714041/Python-Pure-topological-sort,"class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        richer_count = [0 for _ in range(len(quiet))]
        graph = defaultdict(list)
        answer = [idx for idx in range(len(quiet))]
        
        ## create the graph so that we go from the richer to the poorer
        for rich, poor in richer:
            graph[rich].append(poor)
            richer_count[poor] += 1
            
        ## we include the richest ones.
        queue = collections.deque([])
        for person, rich_count in enumerate(richer_count):
            if not rich_count:
                queue.append(person)
                
        while queue:
            person = queue.popleft()
            ## pointer to the quietest person
            quieter_person = answer[person]
            
            for poorer in graph[person]:
                ## pointer to the quietest person richer than me
                quieter_richer = answer[poorer]
                ## on the answer we are storing the pointer to the quietest one. so for the next poorer we are going to store the pointer which contains the quietest
                answer[poorer] = min(quieter_person, quieter_richer, key = lambda prsn : quiet[prsn])
                richer_count[poorer] -= 1
                if not richer_count[poorer]:
                    queue.append(poorer)
        return answer",Henok2011
852,https://leetcode.com/problems/peak-index-in-a-mountain-array/discuss/2068528/Simple-Python-one-liner,"class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        return (arr.index(max(arr)))",tusharkhanna575
853,https://leetcode.com/problems/car-fleet/discuss/939525/Python3-greedy-O(NlogN),"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        ans = prev = 0
        for pp, ss in sorted(zip(position, speed), reverse=True): 
            tt = (target - pp)/ss # time to arrive at target 
            if prev < tt: 
                ans += 1
                prev = tt
        return ans",ye15
854,https://leetcode.com/problems/k-similar-strings/discuss/321201/three-solutions-of-this-problem-good-for-understanding-DFS-DFS-with-memo-and-BFS,"class Solution:
    # DFS
    def kSimilarity(self, A: str, B: str) -> int:
        N = len(A)
        def dfs(A, B, pos):
            if A == B:
                return 0
            
            while A[pos] == B[pos]:
                pos += 1
                
            minCnt = float('inf')
            for i in range(pos + 1, N):
                if B[i] == A[pos] and B[i] != A[i]:
                    B[i], B[pos] = B[pos], B[i]
                    tmp = dfs(A, B, pos + 1) + 1
                    minCnt = min(tmp, minCnt)
                    B[i], B[pos] = B[pos], B[i]
                    
            return minCnt
        
        return dfs(list(A), list(B), 0)

    # DFS with memorization
    def kSimilarity1(self, A: str, B: str) -> int:
        N = len(A)
        def dfs(A, B, pos):
            sB = ''.join(B)
            if sB in map:
                return map[sB]
            
            if A == B:
                return 0
            
            while A[pos] == B[pos]:
                pos += 1
                
            minCnt = float('inf')
            for i in range(pos + 1, N):
                if B[i] == A[pos] and B[i] != A[i]:
                    B[i], B[pos] = B[pos], B[i]
                    tmp = dfs(A, B, pos + 1) + 1
                    minCnt = min(tmp, minCnt)
                    B[i], B[pos] = B[pos], B[i]
                    
            map[sB] = minCnt
            return minCnt
                    
        map = collections.defaultdict()
        return dfs(list(A), list(B), 0)
    
    # BFS
    def kSimilarity2(self, A: str, B: str) -> int:
        N = len(B)
        q = collections.deque([B])
        visited = set(B)
        
        cnt = 0
        pos = 0
        while q:
            qSize = len(q)
            
            for _ in range(qSize):
                cur = q.popleft()
                if cur == A:
                    return cnt
                
                pos = 0
                while cur[pos] == A[pos]:
                    pos += 1
                
                lCur = list(cur)
                for i in range(pos + 1, N):
                    if lCur[i] == A[pos] and lCur[i] != A[i]:
                        lCur[i], lCur[pos] = lCur[pos], lCur[i]
                        
                        sCur = ''.join(lCur)
                        if sCur not in visited:
                            q.append(sCur)
                            
                        visited.add(sCur)
                        lCur[i], lCur[pos] = lCur[pos], lCur[i]
            cnt += 1
            
        return cnt",shchshhappy
856,https://leetcode.com/problems/score-of-parentheses/discuss/2299821/Python-or-faster-than-83-or-easy-understanding-or-explaining-with-comments,"class Solution:
    def scoreOfParentheses(self, s: str) -> int:
        stk = [0]   # temp value to help us

        for char in s:
            if char == '(':
                stk.append(0)   # new parent: current sum = 0
            else:
                # An expression will be closed
                # Find its value: either 1 for empty () or 2 * its sub-expressions
                # we can calc both with a simple max()
                value = max(2 * stk.pop(), 1)

                # Add the expression sum to its parent current sum
                #  Assume we have expression E that is (CHD)
                # where C, H, D are valid-subexpressions with values 5, 10, 4
                # then E is (5+10+4) = (19) = 38
                # Every time we finish an expression, we add its value to its parent
                # get the parent and update its sum with a finished sub-expression
                stk[-1] += value

        return stk.pop()
		```",Saiko15
857,https://leetcode.com/problems/minimum-cost-to-hire-k-workers/discuss/1265778/Python3-greedy-(priority-queue),"class Solution:
    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:
        ans, rsm = inf, 0
        pq = [] # max-heap 
        for q, w in sorted(zip(quality, wage), key=lambda x: x[1]/x[0]): 
            rsm += q 
            heappush(pq, -q)
            if len(pq) > k: rsm += heappop(pq)
            if len(pq) == k: ans = min(ans, rsm * w/q)
        return ans",ye15
858,https://leetcode.com/problems/mirror-reflection/discuss/2376355/Python3-oror-4-lines-geometry-w-explanation-oror-TM%3A-9281,"class Solution:
    def mirrorReflection(self, p: int, q: int) -> int:

        L = lcm(p,q)

        if (L//q)%2 == 0:
            return 2

        return (L//p)%2",warrenruud
859,https://leetcode.com/problems/buddy-strings/discuss/2790774/Python-oror-Beginner-Friendly-oror-98-faster-oror-O(n),"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:

        freq1=[0]*26
        freq2=[0]*26
        diff =0

        if(len(s)!=len(goal)):
            return False
        for i in range(len(s)):
            if(s[i]!=goal[i]):
                diff+=1
            freq1[ord(s[i])-ord('a')]+=1
            freq2[ord(goal[i])-ord('a')]+=1
        unique= True
        for idx in range(len(freq1)):
            if(freq1[idx]!=freq2[idx]):
                return False
            if(freq1[idx]>1):
                unique = False
        if(diff==2 or (unique==False and diff==0)):
            return True",hasan2599
860,https://leetcode.com/problems/lemonade-change/discuss/1260496/Python-3-Easy-to-understand-Better-than-95,"class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        change5=0
        change10=0
        change20=0
        for i in range(len(bills)):
            if bills[i]==5:
                change5+=1
            elif bills[i]==10:
                change10+=1
                change5-=1
            elif bills[i]==20:
                if change10>0 :
                    change5-=1
                    change10-=1
                else:
                    change5-=3
                change20+=1
            if change5<0 or change10<0 or change20<0:
                return False
        return True",mk_mohtashim
861,https://leetcode.com/problems/score-after-flipping-matrix/discuss/940701/Python3-Greedy-O(MN),"class Solution:
    def matrixScore(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        for i in range(m):
            if A[i][0] == 0: 
                for j in range(n): A[i][j] ^= 1 
        
        for j in range(n): 
            cnt = sum(A[i][j] for i in range(m))
            if cnt < m - cnt: 
                for i in range(m): A[i][j] ^= 1
        
        return sum(int("""".join(map(str, A[i])), 2) for i in range(m))",ye15
862,https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/1515369/Python3-binary-search,"class Solution:
    def shortestSubarray(self, nums: List[int], k: int) -> int:
        loc = {0: -1}
        stack = [0] # increasing stack
        ans, prefix = inf, 0
        for i, x in enumerate(nums): 
            prefix += x
            ii = bisect_right(stack, prefix - k)
            if ii: ans = min(ans, i - loc[stack[ii-1]])
            loc[prefix] = i
            while stack and stack[-1] >= prefix: stack.pop()
            stack.append(prefix)
        return ans if ans < inf else -1",ye15
863,https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/discuss/1606006/Easy-to-understand-Python-graph-solution,"class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
    
        graph=defaultdict(list)
        #create undirected graph
        stack=[root]
        while stack:
            node=stack.pop()
            if node==target:
                targetVal=node.val
            if node.left:
                graph[node.val].append(node.left.val)
                graph[node.left.val].append(node.val)
                stack.append(node.left)
            if node.right:
                graph[node.val].append(node.right.val)
                graph[node.right.val].append(node.val)
                stack.append(node.right)
        
        #start BFS
        q=deque([(targetVal,0)]) #startNode distance=0
        seen=set()
        seen.add(targetVal)
        res=[]
        while q:
            node,depth=q.popleft()
            if depth==k: 
                res.append(node)
            if depth>k: break #no need to continue

            for neigh in graph[node]:
                if neigh not in seen:
                    q.append((neigh,depth+1))
                    seen.add(neigh)
        return res",InjySarhan
864,https://leetcode.com/problems/shortest-path-to-get-all-keys/discuss/1516812/Python3-bfs,"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:
        m, n = len(grid), len(grid[0])
        
        ii = jj = total = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == ""@"": ii, jj = i, j
                elif grid[i][j].islower(): total += 1
        
        ans = 0
        seen = {(ii, jj, 0)}
        queue = [(ii, jj, 0)]
        while queue: 
            newq = []
            for i, j, keys in queue: 
                if keys == (1 << total) - 1: return ans 
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] != ""#"": 
                        kk = keys 
                        if grid[ii][jj].islower(): kk |= 1 << ord(grid[ii][jj]) - 97
                        if (ii, jj, kk) in seen or grid[ii][jj].isupper() and not kk &amp; (1 << ord(grid[ii][jj])-65): continue 
                        newq.append((ii, jj, kk))
                        seen.add((ii, jj, kk))
            ans += 1
            queue = newq
        return -1",ye15
865,https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/discuss/940618/Python3-dfs-O(N),"class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        
        @lru_cache(None)
        def fn(node):
            """"""Return height of tree rooted at node.""""""
            if not node: return 0
            return 1 + max(fn(node.left), fn(node.right))
        
        node = root
        while node: 
            left, right = fn(node.left), fn(node.right)
            if left == right: return node
            elif left > right: node = node.left
            else: node = node.right",ye15
866,https://leetcode.com/problems/prime-palindrome/discuss/707393/Python3-check-next-palindrome-Prime-Palindrome,"class Solution:
    def primePalindrome(self, N: int) -> int:
        def isPrime(N):
            return N > 1 and all(N % d for d in range(2, int(N**0.5)+1))
        
        # N must be a palindrome with odd number of digits.
        # The return value will have odd number of digits too.
        def nextPalindrome(N):
            if N in [999, 99999, 9999999]:
                return (N + 1) * 10 + 1
            n = str(N // 10 ** (len(str(N))//2) + 1)
            return int(n + n[-2::-1])
        
        if N <= 11: 
            while not isPrime(N):
                N += 1
            return N
        
        if (digits := len(str(N))) % 2 == 0:
            N = 10 ** digits + 1
        else:
            n = str(N // 10 ** (len(str(N))//2))
            if (p := int(n + n[-2::-1])) >= N:
                N = p
            else:
                N = nextPalindrome(p)
                
        while not isPrime(N):
            N = nextPalindrome(N)
        return N",r0bertz
867,https://leetcode.com/problems/transpose-matrix/discuss/2100098/Python-Easy-2-Approaches-one-liner,"class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        m,n=len(matrix),len(matrix[0])
        ans = [[None] * m for _ in range(n)]
        for i in range(m):
            for j in range(n):
                ans[j][i]=matrix[i][j]
        
        return ans",constantine786
868,https://leetcode.com/problems/binary-gap/discuss/1306246/Easy-Python-Solution(100),"class Solution:
    def binaryGap(self, n: int) -> int:
        if(bin(n).count('1'))==1:
            return 0
        c=0
        x=bin(n)[2:]
        for i in range(len(x)):
            if(x[i]=='1'):
                j=i+1
                while j<len(x):
                    if(x[j]=='1'):
                        c=max(j-i,c)
                        break
                    j+=1
        return c",Sneh17029
869,https://leetcode.com/problems/reordered-power-of-2/discuss/2485025/python-short-and-precise-answer,"class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        for i in range(32):
            if Counter(str(n))==Counter(str(2**i)):
                return True
        return False",benon
870,https://leetcode.com/problems/advantage-shuffle/discuss/843628/Python-3-or-Greedy-Two-Pointers-or-Explanations,"class Solution:
    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:
        sorted_a = sorted(A, reverse=True)                                         # descending order
        sorted_b = sorted(enumerate(B), key=lambda x: (x[1], x[0]), reverse=True)  # descending order with original index
        n, j = len(B), 0
        ans = [-1] * n
        for i, (ori_idx, val) in enumerate(sorted_b):                 # A greedily tries to cover value in B as large as possible
            if sorted_a[j] > val: ans[ori_idx], j = sorted_a[j], j+1
        for i in range(n):                                            # assign rest value in A to ans
            if ans[i] == -1: ans[i], j = sorted_a[j], j+1
        return ans",idontknoooo
871,https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/2454099/Python3-oror-10-lines-heap-wexplanation-oror-TM%3A-90-98,"class Solution:          # Here's the plan:
                         # 
                         # 1) We only need to be concerned with two quantities: the dist traveled (pos)
                         #    and the fuel acquired (fuel). We have to refuel before pos > fuel.
                         # 
                         # 2) Because  we have an infinite capacity tank, we only have to plan where to acquire
                         #    fuel before pos > fuel, and common sense says to stop at the station within range
                         #    with the most fuel.
                         # 
                         # 3) And that's a job for a heap. we heappush the stations that are within range of present
                         #    fuel, and heappop the best choice if and when we need fuel.
                         #  
                         # 4) We are finished when a) we have acquired sufficient fuel such that fuel >= target 
                         #    (return # of fuelings), or b) fuel < target and the heap is empty (return -1).
                       
    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:

        fuel, heap, count = startFuel, [], 0            # <-- initialize some stuff
        
        stations.append([target, 0])                    # <-- this handles the ""stations = []"" test

        while stations:
            if fuel >= target: return count             # <-- 4)            

            while stations and stations[0][0] <= fuel:  # <-- 3)
                _, liters = stations.pop(0)
                heappush(heap,-liters)

            if not heap: return -1                      # <-- 4)
            fuel-= heappop(heap)

            count+= 1",warrenruud
872,https://leetcode.com/problems/leaf-similar-trees/discuss/1564699/Easy-Python-Solution-or-Faster-than-98-(24ms),"class Solution:
    def __init__(self):
        self.n = []
        
    def dfs(self, root):
        if root:
			# checking if the node is leaf
            if not root.left and not root.right:  
				# appends the leaf nodes to the list - self.n 
                self.n.append(root.val)  
				
            self.dfs(root.left)
            self.dfs(root.right)
            
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        self.dfs(root1)
        a = self.n
        self.n = []
        self.dfs(root2)
        
        if a == self.n:
            return True
        else:
            return False",the_sky_high
873,https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/discuss/2732493/python-simple-solution-faster,"class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        arrset=set(arr)
        res=0
        for i in range(len(arr)):
            for j in range(i+1,len(arr)):
                a,b,l=arr[i],arr[j],2
                while(a+b in arrset):
                    a,b,l=b,a+b,l+1
                res=max(res,l)
        return res if res>=3 else 0",Raghunath_Reddy
874,https://leetcode.com/problems/walking-robot-simulation/discuss/381840/Solution-in-Python-3,"class Solution:
    def robotSim(self, c: List[int], b: List[List[int]]) -> int:
        x, y, d, b, M = 0, 0, 0, set([tuple(i) for i in b]), 0
        for i in c:
            if i < 0: d = (d + 2*i + 3)%4
            else:
                if d in [1,3]:
                    for x in range(x, x+(i+1)*(2-d), 2-d):
                        if (x+(2-d), y) in b: break
                else:
                    for y in range(y, y+(i+1)*(1-d), 1-d):
                        if (x, y+(1-d)) in b: break
            M = max(M, x**2 + y**2)
        return M
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
875,https://leetcode.com/problems/koko-eating-bananas/discuss/1705145/Python-BinarySearch-%2B-Optimizations-or-Explained,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        k = 1
        while True:
            total_time = 0
            for i in piles:
                total_time += ceil(i / k)
            if total_time > h:
                k += 1
            else:
                return k",anCoderr
876,https://leetcode.com/problems/middle-of-the-linked-list/discuss/526372/PythonJSJavaGoC%2B%2B-O(n)-by-two-pointers-90%2B-w-Diagram,"class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        
        slow, fast = head, head
        
        while fast:
            
            fast = fast.next
            if fast:
                fast = fast.next
            else:
                # fast has reached the end of linked list
                # slow is on the middle point now
                break
        
            slow = slow.next
        
        return slow",brianchiang_tw
877,https://leetcode.com/problems/stone-game/discuss/643412/Python-O(-n2-)-by-top-down-DP-w-Comment,"class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        
		# Alex always win finally, no matter which step he takes first.
        return True",brianchiang_tw
878,https://leetcode.com/problems/nth-magical-number/discuss/1545825/Python3-binary-search,"class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
	    # inclusion-exclusion principle
        ab = lcm(a,b)
        lo, hi = 0, n*min(a, b)
        while lo < hi: 
            mid = lo + hi >> 1
            if mid//a + mid//b - mid//ab < n: lo = mid + 1
            else: hi = mid 
        return lo % 1_000_000_007",ye15
879,https://leetcode.com/problems/profitable-schemes/discuss/2661178/Python3-DP,"class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        # A[i][j][k] = # schemes using subset of first i crimes, using <= j people, with total profit >= k 
        A = [[[0 for k in range(minProfit + 1)] for j in range(n + 1)] for i in range(len(profit) + 1)]
        # if using first 0 crimes, only one way, and that if minProfit <= 0
        for j in range(n + 1):
            A[0][j][0] = 1
        for i in range(1, len(profit) + 1):
            for j in range(n + 1):
                for k in range(minProfit + 1):
                    # we are here calculating A[j][j][k]
                    # two cases, either we use i'th crime or not. 
                    # but if i'th crime requires more than j people, we con't use it
                    if group[i-1] > j:
                        A[i][j][k] = A[i-1][j][k]
                    else:
                        # if i'th crime gets profit greater than k, then we have no restriction 
                        # on the rest of the groups
                        if profit[i-1] > k:
                            A[i][j][k] = (A[i-1][j][k] + A[i-1][j-group[i-1]][0]) % (10**9 + 7)
                        else:
                            A[i][j][k] = (A[i-1][j][k] + A[i-1][j-group[i-1]][k-profit[i-1]]) % (10**9 + 7)
        return A[len(profit)][n][minProfit]",jbradleyglenn
880,https://leetcode.com/problems/decoded-string-at-index/discuss/1585059/Python3-Solution-with-using-stack,"class Solution:
    def decodeAtIndex(self, s: str, k: int) -> str:
        lens = [0]
        
        for c in s:
            if c.isalpha():
                lens.append(lens[-1] + 1)
            else:
                lens.append(lens[-1] * int(c))
                
        for idx in range(len(s), 0, -1):
            k %= lens[idx]
            if k == 0 and s[idx - 1].isalpha():
                return s[idx - 1]
        
        return",maosipov11
881,https://leetcode.com/problems/boats-to-save-people/discuss/1878155/Explained-Python-2-Pointers-Solution,"class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort()
        lo = 0
        hi = len(people)-1
        boats = 0
        while lo <= hi:
            if people[lo] + people[hi] <= limit:
                lo += 1
                hi -= 1
            else:
                hi -= 1
            boats += 1
        return boats",anCoderr
882,https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/discuss/2568608/BFS-intuitive,"class Solution:
    def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:
        graph = collections.defaultdict(dict)
        for s, e, n in edges: # n: subnodes in edge
            graph[s][e] = n
            graph[e][s] = n
        
        seen = set() # (start, end, step)
        q = collections.deque()
        for n in graph[0]:
            q.append((0, n, 0))
        
        res = 1
        move = maxMoves
        while q:
            for _ in range(len(q)):
                start, end, step = q.popleft()
                seen.add((start, end, step))
                seen.add((end, start, graph[end][start]-step+1))
                
                if step == graph[start][end] + 1: #check if reached next node
                    for n in graph[end]:
                        if (end, n, 1) not in seen:
                            q.append((end, n, 1))
                            res += 1
                            
                else:
                    if (start, end, step+1) not in seen and (end, start, graph[end][start]-step) not in seen:
                        q.append((start, end, step+1))
                        res += 1
                    
            move -= 1  
            if move == 0:
                break

        return res",scr112
883,https://leetcode.com/problems/projection-area-of-3d-shapes/discuss/1357263/Python3-dollarolution,"class Solution:
    def projectionArea(self, grid: List[List[int]]) -> int:
        p = len(grid)
        x, y, c = [], [0]*p, 0
        for i in range(p):
            x.append(0)
            for j in range(p):
                n = grid[i][j]
                if n > 0:
                    c += 1
                if x[i] < n:
                    x[i] = n
                if y[j] < n:
                    y[j] = n

        return (sum(x)+sum(y)+c)",AakRay
884,https://leetcode.com/problems/uncommon-words-from-two-sentences/discuss/1219754/Python3-99-Faster-Solution,"class Solution:
    def uncommonFromSentences(self, A: str, B: str) -> List[str]:
        uncommon = []
        
        def find_uncommon(s , t):
            ans = []
            for i in s:
                if(s.count(i) == 1 and i not in t):
                    ans.append(i)
            
            return ans
        
        return find_uncommon(A.split() , B.split()) + find_uncommon(B.split() , A.split())",VoidCupboard
885,https://leetcode.com/problems/spiral-matrix-iii/discuss/2718364/Easy-Python-Solution-Based-on-Spiral-Matrix-I-and-II,"class Solution:
    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        ans = []
        left, right = cStart, cStart+1
        top, bottom = rStart, rStart+1
        current = 1
        move = 0
        while current <= rows*cols:
            # fill top
            for i in range(left+move, right+1):
                if self.inbound(top, i, rows, cols):
                    ans.append([top, i])
                    current += 1
            left -= 1
            # fill right
            for i in range(top+1, bottom+1):
                if self.inbound(i, right, rows, cols):
                    ans.append([i, right])
                    current += 1
            top -= 1
            # fill bottom
            for i in range(right-1, left-1, -1):
                if self.inbound(bottom, i, rows, cols):
                    ans.append([bottom, i])
                    current += 1
            right += 1
            # fill left
            for i in range(bottom-1, top-1, -1):
                if self.inbound(i, left, rows, cols):
                    ans.append([i, left])
                    current += 1
            bottom += 1
            move = 1
        return ans
    def inbound(self, r, c, rows, cols):
        return 0<=r<rows and 0<=c<cols",Naboni
886,https://leetcode.com/problems/possible-bipartition/discuss/2593419/Clean-Python3-or-Bipartite-Graph-w-BFS-or-Faster-Than-99,"class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        dislike = [[] for _ in range(n)]
        for a, b in dislikes:
            dislike[a-1].append(b-1)
            dislike[b-1].append(a-1)

        groups = [0] * n
        for p in range(n):
            if groups[p] == 0:
                groups[p] = 1
                q = deque([p])
                while q: # bfs
                    a = q.pop()
                    for b in dislike[a]:
                        if groups[b] == 0:
                            groups[b] = 1 if groups[a] == 2 else 2
                            q.appendleft(b)
                        elif groups[a] == groups[b]:
                            return False
        return True",ryangrayson
887,https://leetcode.com/problems/super-egg-drop/discuss/1468875/Python3-a-few-solutions,"class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return min moves given n floors and k eggs.""""""
            if k == 1: return n
            if n == 0: return 0 
            lo, hi = 1, n + 1
            while lo < hi: 
                mid = lo + hi >> 1
                if fn(mid-1, k-1) < fn(n-mid, k): lo = mid + 1
                else: hi = mid 
            return 1 + max(fn(lo-1, k-1), fn(n-lo, k))
        
        return fn(n, k)",ye15
888,https://leetcode.com/problems/fair-candy-swap/discuss/1088075/Python.-Super-simple-solution.,"class Solution:
    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:
        difference = (sum(A) - sum(B)) / 2
        A = set(A)
        for candy in set(B):
            if difference + candy in A:
                return [difference + candy, candy]",m-d-f
889,https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/946726/Python3-consistent-soln-for-105-106-and-889,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        mp = {x: i for i, x in enumerate(inorder)} # relative position 
		root = None
	    stack = []
        for x in preorder: 
            if not root: root = node = TreeNode(x)
            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)
            else: 
                while stack and mp[stack[-1].val] < mp[x]: node = stack.pop() # retrace 
                node.right = node = TreeNode(x)
            stack.append(node)
        return root",ye15
890,https://leetcode.com/problems/find-and-replace-pattern/discuss/500786/Python-O(-nk-)-sol.-by-pattern-matching.-80%2B-With-explanation,"class Solution:
    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        
        def helper( s ):
            
            # dictionary
            # key   : character
            # value : serial number in string type
            char_index_dict = dict()
            
            # given each unique character a serial number
            for character in s:
                
                if character not in char_index_dict:
                    char_index_dict[character] = str( len(char_index_dict) )
            
            
            # gererate corresponding pattern string
            return ''.join( map(char_index_dict.get, s) )

        #--------------------------------------------------------    
            
        pattern_string = helper(pattern)
        
        return [ word for word in words if helper(word) == pattern_string ]",brianchiang_tw
891,https://leetcode.com/problems/sum-of-subsequence-widths/discuss/2839381/MATH-%2B-DP,"class Solution:
    def sumSubseqWidths(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        nums.sort()

        dp = [0] * n

        p = 2
        temp = nums[0]

        for i in range(1, n):
            dp[i] = ((dp[i-1] + ((p-1)*nums[i])%MOD)%MOD - temp)%MOD
            p = (2*p)%MOD
            temp = ((2*temp)%MOD + nums[i])%MOD
        
        return dp[n-1]",roboto7o32oo3
892,https://leetcode.com/problems/surface-area-of-3d-shapes/discuss/2329304/Simple-Python-explained,"class Solution:
    def surfaceArea(self, grid: List[List[int]]) -> int:
        
        l = len(grid)
        area=0
        for row in range(l):
            for col in range(l):
                if grid[row][col]:
                    area += (grid[row][col]*4) +2 #surface area of each block if blocks werent connected
                if row: #row>0
                    area -= min(grid[row][col],grid[row-1][col])*2 #subtracting as area is common among two blocks
                if col: #col>0
                    area -= min(grid[row][col],grid[row][col-1])*2 #subtracting as area is common among two blocks
        return area",sunakshi132
893,https://leetcode.com/problems/groups-of-special-equivalent-strings/discuss/536199/Python-O(n-*-k-lg-k)-sol.-by-signature.-90%2B-w-Hint,"class Solution:
    def numSpecialEquivGroups(self, A: List[str]) -> int:
        
        signature = set()
        
        # Use pair of sorted even substring and odd substring as unique key
        
        for idx, s in enumerate(A):
            signature.add( ''.join( sorted( s[::2] ) ) + ''.join( sorted( s[1::2] ) )  )
        
        return len( signature )",brianchiang_tw
894,https://leetcode.com/problems/all-possible-full-binary-trees/discuss/339611/Python-solution-without-recursion-beets-100-speed,"class Solution:
    def allPossibleFBT(self, N: int) -> List[TreeNode]:
		# Any full binary trees should contain odd number of nodes
		# therefore, if N is even, return 0
		if N % 2 == 0:
			return []
		# for all odd n that are less than N, store all FBTs
        trees_all = collections.defaultdict(list)
		
		#when there is one node, only one tree is available
        trees_all[1] = [TreeNode(0)]
        for n in range(3, N+1, 2):
            for k in range(1, n, 2):
                # trees with k nodes on the left
                # trees with n - k - 1 nodes on the right
				# consider all potential pairs
                for tree1, tree2 in itertools.product(trees_all[k],
													  trees_all[n-k-1]):
                    tree = TreeNode(0)
                    tree.left = tree1
                    tree.right = tree2
                    trees_all[n].append(tree)
                    
        return trees_all[N]",KateMelnykova
896,https://leetcode.com/problems/monotonic-array/discuss/501946/Python-and-Java-Solution-beat-96-and-100,"class Solution:
    def isMonotonic(self, A: List[int]) -> bool:
        if A[-1] < A[0]: 
            A = A[::-1]
        
        for i in range(1, len(A)):
            if A[i] < A[i-1]:
                return False
        return True",justin801514
897,https://leetcode.com/problems/increasing-order-search-tree/discuss/526258/Python-O(n)-sol-by-DFS-90%2B-w-Diagram,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        
        prev_node = None
        
        def helper( node: TreeNode):
                           
            if node.right:
                helper( node.right )

            # prev_novde always points to next larger element for current node
            nonlocal prev_node

            # update right link points to next larger element
            node.right = prev_node

            # break the left link of next larger element
            if prev_node:
                prev_node.left = None

            # update previous node as current node
            prev_node = node

            if node.left:
                helper( node.left)
                
        # ---------------------------------------
        helper( root )
        
        return prev_node",brianchiang_tw
898,https://leetcode.com/problems/bitwise-ors-of-subarrays/discuss/1240982/python-code-with-comment-might-help-to-understand-or,"class Solution:
    def subarrayBitwiseORs(self, arr: List[int]) -> int:
        
        
        ans=set(arr)
        
        # each element is a subarry
        
        
        one = set()
        
        # to get the ans for the subarray of  size >1
        # starting from 0th element to the ending element
        
        
        one.add(arr[0])
        
        for i in  range(1,len(arr)):
            
            two=set()
            
            for j in one:
                
                two.add(j |  arr[i])
                
                # subarray from the element in one set to the current ele(i th one)
                
                ans.add(j| arr[i])
                
            
            two.add(arr[i])
            
            # adding curr element to set two so that from next iteration we can take sub array starting from curr element 
            
            one = two
            
        return len(ans)",chikushen99
899,https://leetcode.com/problems/orderly-queue/discuss/2783233/Python-Simple-and-Easy-Way-to-Solve-with-Explanation-or-99-Faster,"class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        if k > 1:
            return """".join(sorted(s))
        
        res = s
        for i in range(0,len(s)):
            s = s[1:] + s[0]
            res = min(res,s)
                
        return res",pniraj657
902,https://leetcode.com/problems/numbers-at-most-n-given-digit-set/discuss/1633530/Python3-NOT-BEGINNER-FRIENDLY-Explained,"class Solution:
    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
        digits = set(int(d) for d in digits)
        dLen = len(digits)
        nStr = str(n)
        nLen = len(nStr)
        
        res = sum(dLen**i for i in range(1, nLen)) # lower dimensions
        
        def helper(firstDigit, slots):
            if slots == 1:
                return sum(d <= firstDigit for d in digits)

            return sum(d < firstDigit for d in digits) * dLen**(slots - 1)
        
        for i in range(nLen):
            curDigit = int(nStr[i])

            res += helper(curDigit, nLen - i)
            
            if not curDigit in digits: # makes no sense to continue
                break
    
        return res",artod
903,https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/1261833/Python3-top-down-dp,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        
        @cache 
        def fn(i, x): 
            """"""Return number of valid permutation given x numbers smaller than previous one.""""""
            if i == len(s): return 1 
            if s[i] == ""D"": 
                if x == 0: return 0 # cannot decrease
                return fn(i, x-1) + fn(i+1, x-1)
            else: 
                if x == len(s)-i: return 0 # cannot increase 
                return fn(i, x+1) + fn(i+1, x)
        
        return sum(fn(0, x) for x in range(len(s)+1)) % 1_000_000_007",ye15
904,https://leetcode.com/problems/fruit-into-baskets/discuss/1414545/Python-clean-%2B-easy-to-understand-or-Sliding-Window-O(N),"class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        fruit_types = Counter()
        distinct = 0
        max_fruits = 0
        
        left = right = 0
        while right < len(fruits):
            # check if it is a new fruit, and update the counter
            if fruit_types[fruits[right]] == 0:
                distinct += 1
            fruit_types[fruits[right]] += 1
            
            # too many different fruits, so start shrinking window
            while distinct > 2:
                fruit_types[fruits[left]] -= 1
                if fruit_types[fruits[left]] == 0:
                    distinct -= 1
                left += 1
            
            # set max_fruits to the max window size
            max_fruits = max(max_fruits, right-left+1)
            right += 1
        
        return max_fruits",afm2
905,https://leetcode.com/problems/sort-array-by-parity/discuss/356271/Solution-in-Python-3-(beats-~96)-(short)-(-O(1)-space-)-(-O(n)-speed-),"class Solution:
    def sortArrayByParity(self, A: List[int]) -> List[int]:
        i, j = 0, len(A) - 1
        while i < j:
        	if A[i] % 2 == 1 and A[j] % 2 == 0: A[i], A[j] = A[j], A[i]
        	i, j = i + 1 - A[i] % 2, j - A[j] % 2
        return A",junaidmansuri
906,https://leetcode.com/problems/super-palindromes/discuss/1198991/Runtime%3A-Faster-than-94.87-of-Python3-Memory-Usage-less-than-100,"class Solution:
    
        
        
    nums = []
    for i in range(1, 10**5):
        odd = int(str(i)+str(i)[:-1][::-1])**2
        even = int(str(i)+str(i)[::-1])**2
            
        if str(odd) == str(odd)[::-1]:
            nums.append(odd)
                
        if str(even) == str(even)[::-1]:
            nums.append(even)
        
    nums = sorted(list(set(nums)))
    def superpalindromesInRange(self, left: str, right: str) -> int:
        output = []
        for n in self.nums:
            if int(left) <= n <= int(right):
                output.append(n)
                
        return len(output)",pranshusharma712
907,https://leetcode.com/problems/sum-of-subarray-minimums/discuss/2846444/Python-3Monotonic-stack-boundry,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        M = 10 ** 9 + 7

        # right bound for current number as minimum
		q = []
        n = len(arr)
        right = [n-1] * n        
        
        for i in range(n):
            # must put the equal sign to one of the bound (left or right) for duplicate nums (e.g. [71, 55, 82, 55])
            while q and arr[i] <= arr[q[-1]]:
                right[q.pop()] = i - 1
            q.append(i)

        # left bound for current number as minimum
        q = []
        left = [0] * n
        for i in reversed(range(n)):
            while q and arr[i] < arr[q[-1]]:
                left[q.pop()] = i + 1
            q.append(i)
        
        # calculate sum for each number
        ans = 0
        for i in range(n):
            l, r =  abs(i - left[i]), abs(i - right[i])
            # for example:  xx1xxx
            # left take 0, 1, 2 numbers (3 combs) and right take 0, 1, 2, 3 numbers (4 combs)
            covered = (l + 1) * (r + 1)
            ans = (ans + arr[i] * covered) % M
        
        return ans",chestnut890123
908,https://leetcode.com/problems/smallest-range-i/discuss/535164/Python-O(n)-by-min-and-Max.-85%2B-w-Visualization,"class Solution:
    def smallestRangeI(self, A: List[int], K: int) -> int:

        M, m = max(A), min(A)
        diff, extension = M - m, 2*K
        
        if diff <= extension:
            return 0
        
        else:
            return diff - extension",brianchiang_tw
909,https://leetcode.com/problems/snakes-and-ladders/discuss/2491448/Python-3-oror-BFS-Solution-Using-board-mapping,"class Solution:
    def snakesAndLadders(self, board: List[List[int]]) -> int:
        
        # creating a borad map to loop-up the square value
        board_map = {}
        i = 1
        b_rev = board[::-1]
        for d, r in enumerate(b_rev):
			# reverse for even rows - here d is taken as direction 
            if d%2 != 0: r = r[::-1] 
            for s in r:
                board_map[i] = s
                i += 1
        
        # BFS Algorithm
        q = [(1, 0)] # (curr, moves)
        v = set()
        goal = len(board) * len(board) # end square
        
        while q:
            curr, moves = q.pop(0)
            # win situation
            if curr == goal: return moves
            # BFS on next 6 places (rolling a die)
            for i in range(1, 7):
                # skip square outside board
                if curr+i > goal: continue
                # get value from mapping
                next_pos = curr+i if board_map[curr+i] == -1 else board_map[curr+i]
                if next_pos not in v:
                    v.add(next_pos)
                    q.append((next_pos, moves+1))
        
        return -1",kevintoms
910,https://leetcode.com/problems/smallest-range-ii/discuss/980784/Python-3-Solution-Explained-(video-%2B-code),"class Solution:
    def smallestRangeII(self, A: List[int], K: int) -> int:
        A.sort()
        res = A[-1] - A[0]
        
        for indx in range(0, len(A) - 1):
            # assuming that A[indx] is the max val
            min_val = min(A[0] + K, A[indx + 1] - K)
            max_val = max(A[indx] + K, A[-1] - K)
            res = min(res, max_val - min_val)

        return res",spec_he123
912,https://leetcode.com/problems/sort-an-array/discuss/461394/Python-3-(Eight-Sorting-Algorithms)-(With-Explanation),"class Solution:
    def sortArray(self, N: List[int]) -> List[int]:
        L = len(N)
        return [N.pop(min(range(L-i), key = lambda x: N[x])) for i in range(L)]",junaidmansuri
913,https://leetcode.com/problems/cat-and-mouse/discuss/1563154/Python3-dp-minimax,"class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        
        @cache
        def fn(i, m, c): 
            """"""Return """"""
            if i == 2*n: return 0 # tie 
            if m == 0: return 1 # mouse wins
            if m == c: return 2 # cat wins 
            if i&amp;1: # cat's turn 
                tie = 0 
                for cc in graph[c]: 
                    if cc != 0: 
                        x = fn(i+1, m, cc)
                        if x == 2: return 2 
                        if x == 0: tie = 1
                if tie: return 0 
                return 1
            else: # mouse's turn 
                tie = 0 
                for mm in graph[m]: 
                    x = fn(i+1, mm, c)
                    if x == 1: return 1 
                    if x == 0: tie = 1
                if tie: return 0
                return 2 
        
        return fn(0, 1, 2)",ye15
914,https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/discuss/2821961/Did-you-known-about-'gcd'-function-%3AD,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        x = Counter(deck).values()
        return reduce(gcd, x) > 1",almazgimaev
915,https://leetcode.com/problems/partition-array-into-disjoint-intervals/discuss/1359686/PYTHON-Best-solution-yet!-EXPLAINED-with-comments-to-make-life-easier.-O(n)-and-O(1),"class Solution:
    def partitionDisjoint(self, nums: List[int]) -> int:
        """"""
        Intuition(logic) is to find two maximums.
        One maximum is for left array and other maximum is for right array.
        
        But the condition is that, the right maximum should be such that, 
        no element after that right maximum should be less than the left maximum. 
        
        If there is any element after right maximum which is less than left maximum,
        that means there is another right maximum possible and therefore in that case assign
        left maximum to right maximum and keep searching the array for correct right
        maximum till the end.
        """"""
        #start with both left maximum and right maximum with first element.
        left_max = right_max = nums[0]
        # our current index
        partition_ind = 0
        # Iterate from 1 to end of the array
        for i in range(1,len(nums)):
            #update right_max always after comparing with each nums
            #in order to find our correct right maximum
            right_max = max(nums[i], right_max)
            """"""
			if current element is less than left maximum, that means this 
            element must belong to the left subarray. 
              * so our partition index will be updated to current index 
              * and left maximum will be updated to right maximum. 
             Why left maximum updated to right maximum ?
              Because when we find any element less than left_maximum, that 
              means the right maximum which we had till now is not valid and we have
              to find the valid right maximum again while iterating through the end of the loop.
			""""""
            if nums[i] < left_max:
                left_max = right_max
                partition_ind = i
        
        return partition_ind+1",er1shivam
916,https://leetcode.com/problems/word-subsets/discuss/2353565/Solution-Using-Counter-in-Python,"class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        result = []
        tempDict = Counter()
        for w in words2:
            tempDict |= Counter(w)
        print(tempDict)
        
        for w in words1:
            if not tempDict - Counter(w):
                result.append(w)
        return result",AY_
917,https://leetcode.com/problems/reverse-only-letters/discuss/337853/Solution-in-Python-3,"class Solution:
    def reverseOnlyLetters(self, S: str) -> str:
    	S = list(S)
    	c = [c for c in S if c.isalpha()]
    	for i in range(-1,-len(S)-1,-1):
    		if S[i].isalpha(): S[i] = c.pop(0)
    	return """".join(S)
		
		
- Python 3
- Junaid Mansuri",junaidmansuri
918,https://leetcode.com/problems/maximum-sum-circular-subarray/discuss/633106/Python-O(n)-Kadane-DP-w-Visualization,"class Solution:
    def maxSubarraySumCircular(self, A: List[int]) -> int:
        
        array_sum = 0
        
        local_min_sum, global_min_sum = 0, float('inf')
        local_max_sum, global_max_sum = 0, float('-inf')
        
        for number in A:
            
            local_min_sum = min( local_min_sum + number, number )
            global_min_sum = min( global_min_sum, local_min_sum )
            
            local_max_sum = max( local_max_sum + number, number )
            global_max_sum = max( global_max_sum, local_max_sum )
            
            array_sum += number
        
        
        
        # global_max_sum denotes the maximum subarray sum without crossing boundary
        # arry_sum - global_min_sum denotes the maximum subarray sum with crossing boundary
        
        if global_max_sum > 0:
            return max( array_sum - global_min_sum, global_max_sum )
        else:
            # corner case handle for all number are negative
            return global_max_sum",brianchiang_tw
920,https://leetcode.com/problems/number-of-music-playlists/discuss/1358218/Python3-top-down-dp,"class Solution:
    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:
        
        @cache
        def fn(i, x): 
            """"""Return number starting from ith position with x songs already appeared.""""""
            if i == goal: return x == n 
            ans = 0 
            if x < n: ans += (n-x) * fn(i+1, x+1) # a new song
            if k < x: ans += (x-k) * fn(i+1, x) # an old song
            return ans % 1_000_000_007
        
        return fn(0, 0)",ye15
921,https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/discuss/1230943/Python3-Simple-Solution,"class Solution:
    def minAddToMakeValid(self, s: str) -> int:
        count = 0
        
        x = y = 0
        
        for i in s:
            if(i == '('):
                x += 1
            else:
                x -= 1
            
            if(x < 0):
                count += 1
                x = 0
            if(y < 0):
                count += 1
                y = 0
        
        return count + x + y",VoidCupboard
922,https://leetcode.com/problems/sort-array-by-parity-ii/discuss/1490850/Simple-to-understand-oror-For-Beginners-oror-91-faster,"class Solution:
def sortArrayByParityII(self, nums: List[int]) -> List[int]:
    
    odd,even = [],[]
    for n in nums:
        if n%2: odd.append(n)
        else: even.append(n)
    
    o,e = 0,0
    for i in range(len(nums)):
        if i%2==0:
            nums[i]=even[e]
            e+=1
        else:
            nums[i]=odd[o]
            o+=1
    
    return nums",abhi9Rai
923,https://leetcode.com/problems/3sum-with-multiplicity/discuss/1918718/Python-3Sum-Approach-with-Explanation,"class Solution:
    def threeSumMulti(self, arr: List[int], target: int) -> int:
        arr.sort()
		# the rest of the code here",zayne-siew
924,https://leetcode.com/problems/minimize-malware-spread/discuss/1934636/Simple-Python-DFS-with-no-Hashmap,"class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        
        def dfs(i):
            nodes.add(i)
            for j, conn in enumerate(graph[i]):
                if conn and j not in nodes:
                    dfs(j)
        
        maxRemoval, minNode = -1, float('inf')
        for node in initial:
            nodes = set()
            dfs(node)
            
            if nodes &amp; initial == {node}:
                l = len(nodes)
                if l > maxRemoval or (l == maxRemoval and node < minNode):
                    minNode = node
                    maxRemoval = l
                    
        return minNode if maxRemoval > -1 else min(initial)",totoslg
925,https://leetcode.com/problems/long-pressed-name/discuss/1343001/Python3-2-pointers,"class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
        ni = 0       # index of name
        ti = 0       # index of typed
        while ni <= len(name) and ti < len(typed):
            if ni < len(name) and typed[ti] == name[ni]:
                ti += 1
                ni += 1
            elif typed[ti] == name[ni-1] and ni != 0:
                ti += 1
            else:
                return False
            
        return ni == len(name) and ti == len(typed)",samirpaul1
926,https://leetcode.com/problems/flip-string-to-monotone-increasing/discuss/1535758/Python3,"class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        """"""
                     0 0 1 1 0
        oneCount:    0 0 1 2 2
        zeroCount:   1 1 0 0 1
        flipCount:   0 0 0 0 1
        
        
                     0 1 0 1 0
        oneCount:    0 1 1 2 2
        zeroCount:   1 0 1 1 2
        flipCount:   0 0 1 1 2
        
                     0 0 0 1 1 0 0 0
        oneCount:    0 0 0 1 2 2 2 2
        zeroCount:   1 1 1 0 0 1 2 3
        flipCount:   0 0 0 0 0 1 2 2
        """"""
        oneCount = 0
        zeroCount = 0
        flipCount = 0
        for c in s:
            if c == ""1"":
                oneCount += 1
            if c == ""0"":
                zeroCount += 1
            flipCount = min(zeroCount,oneCount)
            zeroCount = flipCount
        return flipCount",zhanweiting
927,https://leetcode.com/problems/three-equal-parts/discuss/1343709/2-clean-Python-linear-solutions,"class Solution:
    def threeEqualParts(self, arr: List[int]) -> List[int]:
        # count number of ones
        ones = sum(arr)
        if ones % 3 != 0:
            return [-1, -1]
        elif ones == 0:  # special case: all zeros
            return [0, 2]
        
        # find the start index of each group of ones
        c = 0
        starts = []
        for i, d in enumerate(arr):
            if d == 1:
                if c % (ones // 3) == 0:
                    starts.append(i)
                c += 1

        # scan the groups in parallel to compare digits
        i, j, k = starts
        while k < len(arr):  # note that the last/rightmost group must include all digits till the end
            if arr[i] == arr[j] == arr[k]:
                i += 1
                j += 1
                k += 1
            else:
                return [-1, -1]
        return [i-1, j]",cthlo
928,https://leetcode.com/problems/minimize-malware-spread-ii/discuss/2845885/Python-9-lines-O(kn2)-BFS,"class Solution:
    # the key observation for me is the fact that we don't need to
    # really delete the initial in the graph. We can simply ignore
    # the deleted initial while we are doing BFS. So basically we
    # do BFS with each deleted value on initial, and we get the
    # minimal count of the connected graph. Note if two deleted
    # values give same count of connected graph, then we choose
    # smaller value. that's why I used a tuple, (BFS(a), a) this 
    # will first compare BFS(a), if they are equal then it compares
    # a.
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def BFS(delval):
            seen, lst = set(), list(initial)
            while lst:
                node = lst.pop()
                if node == delval or node in seen: continue
                seen.add(node)
                lst += [i for i, val in enumerate(graph[node]) if val]
            return len(seen)
        return min(initial, key=lambda a: (BFS(a), a))",tinmanSimon
929,https://leetcode.com/problems/unique-email-addresses/discuss/261959/Easy-understanding-python-solution-(44ms-faster-than-99.3),"class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def parse(email):
            local, domain = email.split('@')
            local = local.split('+')[0].replace('.',"""")
            return f""{local}@{domain}""
        
        return len(set(map(parse, emails)))",ShaneTsui
930,https://leetcode.com/problems/binary-subarrays-with-sum/discuss/957414/Python3-hash-O(N),"class Solution:
    def numSubarraysWithSum(self, A: List[int], S: int) -> int:
        ans = prefix = 0
        seen = {0: 1}
        for x in A:
            prefix += x
            ans += seen.get(prefix - S, 0)
            seen[prefix] = 1 + seen.get(prefix, 0)
        return ans",ye15
931,https://leetcode.com/problems/minimum-falling-path-sum/discuss/1628101/Easy-and-Simple-Python-solution,"class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        
        r=len(matrix)
        c=len(matrix[0])
        
        for i in range(1,r):
            for j in range(c):
                
                if j==0:
                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j+1])
                    
                elif j==c-1:
                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1])
                    
                else:
                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1],matrix[i-1][j+1])
                    
        
        return min(matrix[r-1])",diksha_choudhary
932,https://leetcode.com/problems/beautiful-array/discuss/1368125/Detailed-Explanation-with-Diagrams.-A-Collection-of-Ideas-from-Multiple-Posts.-Python3,"class Solution:
    def recurse(self, nums):
        if len(nums) <= 2: return nums
        return self.recurse(nums[::2]) + self.recurse(nums[1::2])
    
    def beautifulArray(self, n: int) -> List[int]:
        return self.recurse([i for i in range(1, n+1)])",chaudhary1337
934,https://leetcode.com/problems/shortest-bridge/discuss/958926/Python3-DFS-and-BFS,"class Solution:
    def shortestBridge(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        i, j = next((i, j) for i in range(m) for j in range(n) if A[i][j])
        
        # dfs 
        stack = [(i, j)]
        seen = set(stack)
        while stack: 
            i, j = stack.pop()
            seen.add((i, j)) # mark as visited 
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 <= ii < m and 0 <= jj < n and A[ii][jj] and (ii, jj) not in seen: 
                    stack.append((ii, jj))
                    seen.add((ii, jj))
        
        # bfs 
        ans = 0
        queue = list(seen)
        while queue:
            newq = []
            for i, j in queue: 
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen: 
                        if A[ii][jj] == 1: return ans 
                        newq.append((ii, jj))
                        seen.add((ii, jj))
            queue = newq
            ans += 1",ye15
935,https://leetcode.com/problems/knight-dialer/discuss/1544986/Python-simple-dp-O(n)-time-O(1)-space,"class Solution:
    def knightDialer(self, n: int) -> int:
        arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        
        
        for _ in range(n-1):
            dp = [0 for _ in range(10)]
            dp[0] = arr[5] + arr[7]
            dp[1] = arr[6] + arr[8]
            dp[2] = arr[3] + arr[7]
            dp[3] = arr[2] + arr[8] + arr[9]
            dp[4] = 0
            dp[5] = arr[0] + arr[6] + arr[9]
            dp[6] = arr[1] + arr[5]
            dp[7] = arr[0] + arr[2]
            dp[8] = arr[1] + arr[3]
            dp[9] = arr[3] + arr[5]
            arr = dp
        return sum(arr) % (10**9+7)",byuns9334
936,https://leetcode.com/problems/stamping-the-sequence/discuss/1888562/PYTHON-SOL-oror-WELL-EXPLAINED-oror-SIMPLE-ITERATION-oror-EASIEST-YOU-WILL-FIND-EVER-!!-oror,"class Solution:
    def movesToStamp(self, stamp: str, target: str) -> List[int]:
        N,M = len(target),len(stamp)
        move = 0
        maxmove = 10*N
        ans = []
        def check(string):
            for i in range(M):
                if string[i] == stamp[i] or string[i] == '?':
                    continue
                else:
                    return False
            return True
        
        while move < maxmove:
            premove = move
            for i in range(N-M+1):
                if check(target[i:i+M]):
                    move += 1
                    ans.append(i)
                    target = target[:i] + ""?""*M + target[i+M:]
                    if target == ""?""*N : return ans[::-1]
            if premove == move:return []
        return []",reaper_27
937,https://leetcode.com/problems/reorder-data-in-log-files/discuss/1135934/Python3-simple-solution,"class Solution:
    def reorderLogFiles(self, logs: List[str]) -> List[str]:
        l = []
        d = []
        for i in logs:
            if i.split()[1].isdigit():
                d.append(i)
            else:
                l.append(i)
        l.sort(key = lambda x : x.split()[0])
        l.sort(key = lambda x : x.split()[1:])
        return l + d",EklavyaJoshi
938,https://leetcode.com/problems/range-sum-of-bst/discuss/1627963/Python3-ITERATIVE-BFS-Explained,"class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], lo: int, hi: int) -> int:
        res = 0
        
        q = deque([root])
        while q:
            c = q.popleft()
            v, l, r = c.val, c.left, c.right

            if lo <= v and v <= hi:
                res += v
                
            if l and (lo < v or v > hi):
                q.append(l)
                
            if r and (lo > v or v < hi):
                q.append(r)
            
        return res",artod
939,https://leetcode.com/problems/minimum-area-rectangle/discuss/1888886/PYTHON-SOLUTION-oror-PASSED-ALL-CASES-oror-WELL-EXPLAINED-oror-EASY-SOL-oror,"class Solution:
    def minAreaRect(self, points: List[List[int]]) -> int:
        x_axis = defaultdict(dict)
        y_axis = defaultdict(dict)
        d = {}
        points.sort()
        
        ans = float('inf')
        
        for point in points:
            x_axis[point[0]][point[1]] = True
            y_axis[point[1]][point[0]] = True
            d[(point[0],point[1])] = True

        for point in points:
            x1 = point[0]
            y1 = point[1]
            for y2 in x_axis[x1]:
                if y2 == y1:continue
                for x2 in y_axis[y2]:
                    if x2 == x1:continue
                    if (x2,y1) in  d:
                        tmp = abs(x2-x1) * abs(y2-y1)
                        if tmp < ans : ans = tmp
        return ans if ans!=float('inf') else 0",reaper_27
940,https://leetcode.com/problems/distinct-subsequences-ii/discuss/1894186/PYTHON-SOL-oror-DP-oror-EXPLAINED-oror-FULL-APPROACH-EXPLAINED-oror-TLE-TO-OPTIMIZED-SOL-oror,"class Solution:
    def distinctSubseqII(self, s: str) -> int:
        n = len(s)
        MOD = 1000000007
        dp = {}
        
        def recursion(string,index):
            ans = 1 if index > 0 else 0
            used = {}
            for idx in range(index,n):
                if s[idx] in used:continue
                used[s[idx]] = True
                ans += recursion(string + s[idx] , idx + 1)
            
            return ans
        
        res = recursion("""",0)%MOD
        return res",reaper_27
941,https://leetcode.com/problems/valid-mountain-array/discuss/338636/Python-solution-using-Two-pointer-from-opposite-sides,"class Solution:
    def validMountainArray(self, A: List[int]) -> bool:
        if len(A)<3:return False
        l=len(A)
        i,j=0,l-1
        while i<j and A[i]<A[i+1]:
            i+=1
        while j>0 and A[j]<A[j-1]:
            j-=1
        if i==j and j!=l-1 and i!=0:return True
        return False",ketan35
942,https://leetcode.com/problems/di-string-match/discuss/1199072/Python3-Simple-And-Readable-Solution,"class Solution:
    def diStringMatch(self, s: str) -> List[int]:
        ans = []
        a , b = 0 , len(s)
        
        for i in s:
            if(i == 'I'):
                ans.append(a)
                a += 1
            else:
                ans.append(b)
                b -= 1
        
        if(s[-1] == 'D'):
            ans.append(a)
        else:
            ans.append(b)
                       
        return ans",VoidCupboard
943,https://leetcode.com/problems/find-the-shortest-superstring/discuss/1231147/Python3-travelling-sales-person-(TSP),"class Solution:
    def shortestSuperstring(self, words: List[str]) -> str:
        n = len(words)
        graph = [[0]*n for _ in range(n)] # graph as adjacency matrix 
        
        for i in range(n):
            for j in range(n): 
                if i != j: 
                    for k in range(len(words[j])): 
                        if words[i].endswith(words[j][:k]): 
                            graph[i][j] = len(words[j]) - k 
                            
        @cache
        def fn(prev, mask): 
            """"""Return length of shortest superstring &amp; current choice of word.""""""
            if mask == 0: return 0, None
            vv, kk = inf, None
            for k in range(n): 
                if mask &amp; 1<<k: 
                    v, _ = fn(k, mask ^ 1<<k)
                    offset = len(words[k]) if prev == -1 else graph[prev][k]
                    if v + offset < vv: vv, kk = v + offset, k
            return vv, kk
        
        ans = []
        prev = -1 
        mask = (1<<n) - 1
        while mask: 
            _, k = fn(prev, mask)
            if ans: ans.append(words[k][-graph[prev][k]:])
            else: ans.append(words[k])
            prev = k
            mask ^= 1<<k 
        return """".join(ans)",ye15
944,https://leetcode.com/problems/delete-columns-to-make-sorted/discuss/427225/Python3-6-line-96ms-beats-99-easy-to-understand,"class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        zipped=list(map(list,zip(*A)))
        count=0
        for item in zipped:
            if item!=sorted(item):
                count+=1
        return count",wangzi100
945,https://leetcode.com/problems/minimum-increment-to-make-array-unique/discuss/1897470/PYTHON-SOL-oror-WELL-EXPLAINED-oror-SORTING-ororGREEDYoror-APPROACH-EXPLAINED-oror-SIMPLE-oror-O(n*log(n))oror,"class Solution:
    def minIncrementForUnique(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        ans = 0
        for i in range(1,n):
            if nums[i] <= nums[i-1]:
                # this is the case for making item unique
                diff = nums[i-1] + 1 - nums[i]
                ans += diff
                nums[i] = nums[i-1] + 1
        return ans",reaper_27
946,https://leetcode.com/problems/validate-stack-sequences/discuss/1106110/Easy-python-solution-or-86-memory-86-time,"class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        stack = []
        for i in pushed:
            stack.append(i)
            while stack and popped and stack[-1] == popped[0]:
                stack.pop()
                popped.pop(0)
        return not stack",vanigupta20024
947,https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/1689443/For-Beginners-oror-Count-Number-of-Connected-Graphs-O(N)-oror-94-Faster,"class Solution:
		def removeStones(self, stones: List[List[int]]) -> int:
			
			def remove_point(a,b):                           # Function to remove connected points from the ongoing graph. 
				points.discard((a,b))
				for y in x_dic[a]:
					if (a,y) in points:
						remove_point(a,y)

				for x in y_dic[b]:
					if (x,b) in points:
						remove_point(x,b)

			x_dic = defaultdict(list)
			y_dic = defaultdict(list)
			points= {(i,j) for i,j in stones}
			
			for i,j in stones:                                # Construction of graph by x_coordinates and y_coordinates.
				x_dic[i].append(j)
				y_dic[j].append(i)

			cnt = 0
			for a,b in stones:                                # counting of distinct connected graph.
				if (a,b) in points:
					remove_point(a,b)
					cnt+=1

			return len(stones)-cnt",abhi9Rai
948,https://leetcode.com/problems/bag-of-tokens/discuss/2564480/Easy-python-solution-TC%3A-O(nlogn)-SC%3A-O(1),"class Solution:
    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:
        score=0
        tokens.sort()
        i=0
        j=len(tokens)-1
        mx=0
        while i<=j:
            if tokens[i]<=power:
                power-=tokens[i]
                score+=1
                i+=1
                mx=max(mx,score)
            elif score>0:
                score-=1
                power+=tokens[j]
                j-=1
            else:
                break
        return mx",shubham_1307
949,https://leetcode.com/problems/largest-time-for-given-digits/discuss/406661/Python3-6-line-via-permutation,"class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        hh = mm = -1
        for x in set(permutations(A, 4)): 
            h = 10*x[0] + x[1]
            m = 10*x[2] + x[3]
            if h < 24 and m < 60 and 60*h + m > 60*hh + mm: hh, mm = h, m
        return f""{hh:02}:{mm:02}"" if hh >= 0 else """"",ye15
950,https://leetcode.com/problems/reveal-cards-in-increasing-order/discuss/394028/Solution-in-Python-3-(Deque)-(three-lines),"class Solution:
    def deckRevealedIncreasing(self, D: List[int]) -> List[int]:
    	L, Q, _ = len(D)-1, collections.deque(), D.sort()
    	for _ in range(L): Q.appendleft(D.pop()), Q.appendleft(Q.pop())
    	return D + list(Q)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
951,https://leetcode.com/problems/flip-equivalent-binary-trees/discuss/1985423/Python-oror-4-line-93,"class Solution:
    def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        if not root1 or not root2:
            return not root1 and not root2
        if root1.val != root2.val: return False
        return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)) or (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left))",gulugulugulugulu
952,https://leetcode.com/problems/largest-component-size-by-common-factor/discuss/1546345/Python3-union-find,"class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        m = max(nums)
        uf = UnionFind(m+1)
        for x in nums: 
            for p in range(2, int(sqrt(x))+1): 
                if x%p == 0: 
                    uf.union(x, p)
                    uf.union(x, x//p)
        freq = Counter(uf.find(x) for x in nums)
        return max(freq.values())",ye15
953,https://leetcode.com/problems/verifying-an-alien-dictionary/discuss/1370816/Python3-fast-and-easy-to-understand-28-ms-faster-than-96.25,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        hm = {ch: i for i, ch in enumerate(order)}

        prev_repr = list(hm[ch] for ch in words[0])
        for i in range(1, len(words)):
            cur_repr = list(hm[ch] for ch in words[i])

            if cur_repr < prev_repr:
                return False

            prev_repr = cur_repr

        return True",MihailP
954,https://leetcode.com/problems/array-of-doubled-pairs/discuss/1840844/python-3-oror-O(nlogn),"class Solution:
    def canReorderDoubled(self, arr: List[int]) -> bool:
        count = collections.Counter(arr)
        for n in sorted(arr, key=abs):
            if count[n] == 0:
                continue
            if count[n * 2] == 0:
                return False
            count[n] -= 1
            count[n * 2] -= 1
        
        return True",dereky4
955,https://leetcode.com/problems/delete-columns-to-make-sorted-ii/discuss/844457/Python-3-or-Greedy-DP-(28-ms)-or-Explanation,"class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        m, n = len(A), len(A[0])
        ans, in_order = 0, [False] * (m-1)
        for j in range(n):
            tmp_in_order = in_order[:]
            for i in range(m-1):
				# previous step, rows are not in order; and current step rows are not in order, remove this column
                if not in_order[i] and A[i][j] > A[i+1][j]: ans += 1; break  
				# previous step, rows are not in order, but they are in order now
                elif A[i][j] < A[i+1][j] and not in_order[i]: tmp_in_order[i] = True
			# if column wasn't removed, update the row order information
            else: in_order = tmp_in_order  
            # not necessary, but speed things up
            if all(in_order): return ans   
        return ans",idontknoooo
956,https://leetcode.com/problems/tallest-billboard/discuss/1561795/Python3-dp-and-binary-search,"class Solution:
    def tallestBillboard(self, rods: List[int]) -> int:
        dp = {0: 0}
        for x in rods: 
            for k, v in dp.copy().items(): 
                dp[k+x] = max(dp.get(k+x, 0), v)
                if k >= x: dp[k-x] = max(dp.get(k-x, 0), v+x)
                else: dp[x-k] = max(dp.get(x-k, 0), v+k)
        return dp[0]",ye15
957,https://leetcode.com/problems/prison-cells-after-n-days/discuss/347500/Python3-Prison-Cells-After-N-days%3A-dictionary-to-store-pattern,"class Solution:
    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:
        def nextday(cells):
            next_day_cells = [0] *len(cells)
            for i in range(1,len(cells)-1):
                if cells[i-1] == cells[i+1]: 
                        next_day_cells[i] = 1
                else:
                        next_day_cells[i] = 0
            return next_day_cells
        
        seen = {}
        while N > 0:
            c = tuple(cells)
            if c in seen:
                N %= seen[c] - N
            seen[c] = N

            if N >= 1:
                N -= 1
                cells = nextday(cells)

        return cells",zhanweiting
958,https://leetcode.com/problems/check-completeness-of-a-binary-tree/discuss/2287813/Python3-oror-bfs-8-lines-w-explanation-oror-TM%3A-9797,"class Solution:
    def isCompleteTree(self, root: TreeNode) -> bool:
                        # The criteria for an n-level complete tree:
                        #
                        #    The first n-1 rows have no null nodes.
                        #
                        #    The nth row has no non-null nodes to the right of the left-most null
                        #     node encountered (if it exists).
                        #
                        # The plan is to bfs the tree, left to right, level by level. We mark the
                        # instance of the first null popped from the queue and then ensure the remaining
                        # queue is only null nodes. If so, both criteria are satisfied and True is
                        # returned. If not, False is returned.

        queue = deque([root])                       #   <-- initialize the queue

        while queue[0]:                             #   <-- if and while top queue node is not null, pop   
            node = queue.popleft()                  #       it and then push its left child and right  
            queue.extend([node.left, node.right])   #       child onto the queue.

        while queue and not queue[0]:               #   <-- if and while top queue node is null, pop it. 
            queue.popleft()                         #        

        if queue: return False                      #   <-- If the queue is not empty, it must be non-null, so 
        return True                                 #       return False; if the queue is empty, return True.",warrenruud
959,https://leetcode.com/problems/regions-cut-by-slashes/discuss/205674/DFS-on-upscaled-grid,"class Solution:
    def regionsBySlashes(self, grid: List[str]) -> int:
        def dfs(i: int, j: int) -> int:
            if min(i, j) < 0 or max(i, j) >= len(g) or g[i][j] != 0:
                return 0
            g[i][j] = 1
            return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)
        n, regions  = len(grid), 0
        g = [[0] * n * 3 for i in range(n * 3)]
        for i in range(n):
            for j in range(n):
                if grid[i][j] == '/':
                    g[i * 3][j * 3 + 2] = g[i * 3 + 1][j * 3 + 1] = g[i * 3 + 2][j * 3] = 1
                elif grid[i][j] == '\\':
                    g[i * 3][j * 3] = g[i * 3 + 1][j * 3 + 1] = g[i * 3 + 2][j * 3 + 2] = 1
        for i in range(n * 3):
            for j in range(n * 3):
                regions += 1 if dfs(i, j) > 0 else 0
        return regions",votrubac
960,https://leetcode.com/problems/delete-columns-to-make-sorted-iii/discuss/1258211/Python3-top-down-dp,"class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        m, n = len(strs), len(strs[0]) # dimensions
        
        @cache 
        def fn(k, prev):
            """"""Return min deleted columns to make sorted.""""""
            if k == n: return 0 
            ans = 1 + fn(k+1, prev) # delete kth column
            if prev == -1 or all(strs[i][prev] <= strs[i][k] for i in range(m)): 
                ans = min(ans, fn(k+1, k)) # retain kth column
            return ans 
        
        return fn(0, -1)",ye15
961,https://leetcode.com/problems/n-repeated-element-in-size-2n-array/discuss/1337509/PYTHON-3-%3A-SUPER-EASY-99.52-FASTER,"class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        
        list1 = []
        for i in nums :
            if i in list1 :
                return i
            else :
                list1.append(i)",rohitkhairnar
962,https://leetcode.com/problems/maximum-width-ramp/discuss/977244/Python3-binary-search-O(NlogN)-and-stack-O(N),"class Solution:
    def maxWidthRamp(self, A: List[int]) -> int:
        ans = 0
        stack = []
        for i in range(len(A)): 
            if not stack or A[stack[-1]] > A[i]: stack.append(i)
            else: 
                lo, hi = 0, len(stack)
                while lo < hi: 
                    mid = lo + hi >> 1
                    if A[stack[mid]] <= A[i]: hi = mid
                    else: lo = mid + 1
                ans = max(ans, i - stack[lo])
        return ans",ye15
963,https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/980956/Python3-center-point-O(N2),"class Solution:
    def minAreaFreeRect(self, points: List[List[int]]) -> float:
        ans = inf
        seen = {}
        for i, (x0, y0) in enumerate(points):
            for x1, y1 in points[i+1:]:
                cx = (x0 + x1)/2
                cy = (y0 + y1)/2
                d2 = (x0 - x1)**2 + (y0 - y1)**2
                for xx, yy in seen.get((cx, cy, d2), []): 
                    area = sqrt(((x0-xx)**2 + (y0-yy)**2) * ((x1-xx)**2 + (y1-yy)**2))
                    ans = min(ans, area)
                seen.setdefault((cx, cy, d2), []).append((x0, y0))
        return ans if ans < inf else 0",ye15
964,https://leetcode.com/problems/least-operators-to-express-number/discuss/1367268/Python3-top-down-dp,"class Solution:
    def leastOpsExpressTarget(self, x: int, target: int) -> int:
        
        @cache
        def fn(val): 
            """"""Return min ops to express val.""""""
            if val < x: return min(2*val-1, 2*(x-val))
            k = int(log(val)//log(x))
            ans = k + fn(val - x**k)
            if x**(k+1) < 2*val: 
                ans = min(ans, k + 1 + fn(x**(k+1) - val))
            return ans 
        
        return fn(target)",ye15
965,https://leetcode.com/problems/univalued-binary-tree/discuss/1569046/python-dfs-recursion-faster-than-97,"class Solution:
    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:
        val = root.val
        
        def helper(root):
            return root is None or (root.val == val and helper(root.left) and helper(root.right))
        
        return helper(root)",dereky4
966,https://leetcode.com/problems/vowel-spellchecker/discuss/1121773/Python-One-Case-At-A-Time,"class Solution:
    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
        
        # Convert words and vowels to sets for O(1) lookup times
        words = set(wordlist)
        vowels = set('aeiouAEIOU')
        
        # Create two maps.  
        # One for case insensitive word to all words that match ""key"" -> [""Key"", ""kEy"", ""KEY""]
        # The other for vowel insensitive words ""k*t*"" -> [""Kite"", ""kato"", ""KUTA""]
        case_insensitive = collections.defaultdict(list)            
        vowel_insensitive = collections.defaultdict(list)
        for word in wordlist:
            case_insensitive[word.lower()].append(word)
            key = ''.join(char.lower() if char not in vowels else '*' for char in word)
            vowel_insensitive[key].append(word)

        res = []
        for word in queries:

            # Case 1: When query exactly matches a word
            if word in words:
                res.append(word)
                continue

            # Case 2: When query matches a word up to capitalization
            low = word.lower()
            if low in case_insensitive:
                res.append(case_insensitive[low][0])
                continue

            # Case 3: When query matches a word up to vowel errors
            key = ''.join(char.lower() if char not in vowels else '*' for char in word)
            if key in vowel_insensitive:
                res.append(vowel_insensitive[key][0])
                continue

            res.append('')

        return res",rowe1227
967,https://leetcode.com/problems/numbers-with-same-consecutive-differences/discuss/2521416/44ms-PYTHON-91-Faster-93-Memory-Efficient-Solution-MULTIPLE-APPROACHES,"class Solution:
	def numsSameConsecDiff(self, n: int, k: int) -> List[int]:
		graph = defaultdict(list)
		for i in range(0, 10):
			if i-k >= 0:
				graph[i].append(i-k)
			if i +k < 10:
				graph[i].append(i+k)
		start = [i for i in graph if i!= 0]
		for j in range(n-1):
			new = set()
			for i in start:
				last = i%10
				for k in graph[last]:
					new.add(i*10 + k)
			start = new
		return list(start)",anuvabtest
968,https://leetcode.com/problems/binary-tree-cameras/discuss/2160386/Python-Making-a-Hard-Problem-Easy!-Postorder-Traversal-with-Explanation,"class Solution:
    def minCameraCover(self, root: TreeNode) -> int:
        # set the value of camera nodes to 1
        # set the value of monitored parent nodes to 2
        def dfs(node: Optional[TreeNode]) -> int:
            if not node:
                return 0
            res = dfs(node.left)+dfs(node.right)
            # find out if current node is a root node / next node in line to be monitored
            curr = min(node.left.val if node.left else float('inf'), node.right.val if node.right else float('inf'))
            if curr == 0:
                # at least one child node requires monitoring, this node must have a camera
                node.val = 1
                res += 1
            elif curr == 1:
                # at least one child node is a camera, this node is already monitored
                node.val = 2
            # if curr == float('inf'), the current node is a leaf node; let the parent node monitor this node
            # if curr == 2, all child nodes are being monitored; treat the current node as a leaf node
            return res
        # ensure that root node is monitored, otherwise, add a camera onto root node
        return dfs(root)+(root.val == 0)",zayne-siew
969,https://leetcode.com/problems/pancake-sorting/discuss/2844744/Kind-of-a-simulation-solution,"class Solution:
    def pancakeSort(self, arr: List[int]) -> List[int]:

        if arr == sorted(arr):
            return []
        
        flips = []
        end = len(arr) - 1
        
        # find the max flip all the numbers from the first position to the max position 
        # ==> from 0 to max_position = k
        # ==> if max not at the end : flip again until the max is at the end of the array 
        # ==> from 0 to max_position = k
        # end = end - 1
        # repeat previous steps

        while end > 0:
            
            max_num = max(arr[:end+1])
            index_num = arr.index(max_num)
            
            if index_num != end:
                k = index_num + 1
                arr = arr[0:k][::-1] + arr[k:]
                flips.append(k)
                arr = arr[:end+1][::-1] + arr[end+1:]
                flips.append(end+1)
            else:
                k = end
                arr = arr[0:k][::-1] + arr[k:]
                flips.append(k)
            
            end -= 1

        return flips",khaled_achech
971,https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/discuss/1343381/Elegant-Python-Iterative-and-Recursive-Preorder-Traversals,"class Solution:
    def __init__(self):
        self.flipped_nodes = []
        self.index = 0
        
    def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:
        queue = deque([root])
        while queue:
            node = queue.pop()
            if not node: continue
            if node.val != voyage[self.index]: return [-1]
            self.index += 1
            if node.left and node.left.val != voyage[self.index]:
                self.flipped_nodes.append(node.val)
                node.left, node.right = node.right, node.left
            queue.append(node.right), queue.append(node.left)
        return self.flipped_nodes",soma28
972,https://leetcode.com/problems/equal-rational-numbers/discuss/405505/Python-3-(beats-~99)-(six-lines),"class Solution:
    def isRationalEqual(self, S: str, T: str) -> bool:
        L, A = [len(S), len(T)], [S,T]
        for i,p in enumerate([S,T]):
            if '(' in p:
                I = p.index('(')
                A[i] = p[0:I] + 7*p[I+1:L[i]-1]
        return abs(float(A[0])-float(A[1])) < 1E-7
		
		
- Junaid Mansuri",junaidmansuri
973,https://leetcode.com/problems/k-closest-points-to-origin/discuss/1647325/Python3-ONE-LINER-Explained,"class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        return sorted(points, key = lambda p: p[0]**2 + p[1]**2)[0:k]",artod
974,https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/1060120/Python3-O(N)-HashMap-and-Prefix-Sum,"class Solution:
    def subarraysDivByK(self, A: List[int], k: int) -> int:
        dic = collections.defaultdict(int)
        dic[0] = 1
        ans = 0
        presum = 0
        for num in A:
            presum += num
            ans += dic[presum%k]
            dic[presum%k] += 1
        return ans
	```",coffee90
975,https://leetcode.com/problems/odd-even-jump/discuss/1293059/Python-O(nlogn)-bottom-up-DP-easy-to-understand-260ms,"class Solution:
    def oddEvenJumps(self, A: List[int]) -> int:
        
		# find next index of current index that is the least larger/smaller
        def getNextIndex(sortedIdx):
            stack = []
            result = [None] * len(sortedIdx)
        
            for i in sortedIdx:
                while stack and i > stack[-1]:
                    result[stack.pop()] = i
                stack.append(i)
            return result
        
        sortedIdx = sorted(range(len(A)), key= lambda x: A[x])
        oddIndexes = getNextIndex(sortedIdx)
        sortedIdx.sort(key=lambda x: -A[x])
        evenIndexes = getNextIndex(sortedIdx)
        
		# [odd, even], the 0th jump is even
        dp = [[0,1] for _ in range(len(A))]
        
        for i in range(len(A)):
            if oddIndexes[i] is not None:
                dp[oddIndexes[i]][0] += dp[i][1]
            if evenIndexes[i] is not None:
                dp[evenIndexes[i]][1] += dp[i][0]
				
        return dp[-1][0] + dp[-1][1]",ScoutBoi
976,https://leetcode.com/problems/largest-perimeter-triangle/discuss/915905/Python-3-98-better-explained-with-simple-logic,"class Solution:
    def largestPerimeter(self, A: List[int]) -> int:
        A.sort(reverse = True)
        for i in range(3,len(A)+1):
            if(A[i-3] < A[i-2] + A[i-1]):
                return sum(A[i-3:i])
        return 0",apurva_101
977,https://leetcode.com/problems/squares-of-a-sorted-array/discuss/310865/Python%3A-A-comparison-of-lots-of-approaches!-Sorting-two-pointers-deque-iterator-generator,"class Solution:
    def sortedSquares(self, A: List[int]) -> List[int]:
        return_array = [0] * len(A)
        write_pointer = len(A) - 1
        left_read_pointer = 0
        right_read_pointer = len(A) - 1
        left_square = A[left_read_pointer] ** 2
        right_square = A[right_read_pointer] ** 2
        while write_pointer >= 0:
            if left_square > right_square:
                return_array[write_pointer] = left_square
                left_read_pointer += 1
                left_square = A[left_read_pointer] ** 2
            else:
                return_array[write_pointer] = right_square
                right_read_pointer -= 1
                right_square = A[right_read_pointer] ** 2
            write_pointer -= 1
        return return_array",Hai_dee
978,https://leetcode.com/problems/longest-turbulent-subarray/discuss/1464950/Python3-Longest-Turbulent-Subarray-O(n)-(one-pass),"class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -> int:
        cur, mx, t = 1, 1, None
        for i in range(1, len(arr)):
            # Start of subarray
            if t == None:
                if arr[i] != arr[i-1]: 
                    cur = 2
                    t = arr[i] > arr[i-1]
            # Valid element in subarray, continue cur subarray
            elif (t and arr[i] < arr[i-1]) or (not t and arr[i] > arr[i-1]):
                cur += 1; t = not t
            # Invalid element in subarray, start new subarray
            else:
                if arr[i] == arr[i-1]: t = None
                mx = max(mx, cur)
                cur = 2
        
        return max(mx, cur)",vscala
979,https://leetcode.com/problems/distribute-coins-in-binary-tree/discuss/2797049/Very-short-concise-Python-solution-with-DFS,"class Solution:
    def distributeCoins(self, v: Optional[TreeNode], parent=None) -> int:
        if v is None:
            return 0
        m = self.distributeCoins(v.left, v) + self.distributeCoins(v.right, v)
        if v.val != 1:
            parent.val += v.val - 1
            m += abs(v.val - 1)
        return m",metaphysicalist
980,https://leetcode.com/problems/unique-paths-iii/discuss/1535158/Python-Backtracking%3A-Easy-to-understand-with-Explanation,"class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
		# first, prepare the starting and ending points
		# simultaneously, record all the non-obstacle coordinates
        start = end = None
        visit = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 0:
                    visit.add((i, j))
                elif grid[i][j] == 1:
                    start = (i, j)
                elif grid[i][j] == 2:
                    end = (i, j)
                    visit.add((i, j))
        
        def backtrack(x, y, visit):
            if (x, y) == end:
				# implement success condition: valid only if there are no more coordinates to visit
                return len(visit) == 0
            result = 0  # assume no valid paths by default
			
			# we need to try every possible path from this coordinate
            if (x-1, y) in visit:
				# the coordinate directly above this one is non-obstacle, try that path
                visit.remove((x-1, y))  # first, note down the 'visited status' of the coordinate
                result += backtrack(x-1, y, visit)  # then, DFS to find all valid paths from that coordinate
                visit.add((x-1, y))  # last, reset the 'visited status' of the coordinate
            if (x+1, y) in visit:
				# the coordinate directly below this one is non-obstacle, try that path
                visit.remove((x+1, y))
                result += backtrack(x+1, y, visit)
                visit.add((x+1, y))
            if (x, y-1) in visit:
				# the coordinate directly to the left of this one is non-obstacle, try that path
                visit.remove((x, y-1))
                result += backtrack(x, y-1, visit)
                visit.add((x, y-1))
            if (x, y+1) in visit:
				# the coordinate directly to the right of this one is non-obstacle, try that path
                visit.remove((x, y+1))
                result += backtrack(x, y+1, visit)
                visit.add((x, y+1))
            return result
        
        return backtrack(start[0], start[1], visit)  # we start from the starting point, backtrack all the way back, and consolidate the result",zayne-siew
982,https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/discuss/1257470/Python3-hash-table,"class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for x in nums: 
            for y in nums: 
                freq[x&amp;y] += 1
        
        ans = 0
        for x in nums: 
            mask = x = x ^ 0xffff
            while x: 
                ans += freq[x]
                x = mask &amp; (x-1)
            ans += freq[0]
        return ans",ye15
983,https://leetcode.com/problems/minimum-cost-for-tickets/discuss/1219272/Python-O(N)-Runtime-O(N)-with-explanation,"class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
		#create the total costs for the days 
        costForDays = [0 for _ in range(days[-1] + 1) ]
		#since days are sorted in ascending order, we only need the index of the days we haven't visited yet
        curIdx = 0
		
        for d in range(1, len(costForDays)):
			#if we do not need to travel that day
			#we don't need to add extra costs
            if d < days[curIdx]:
                costForDays[d] = costForDays[d - 1]
                continue
            
			#else this means we need to travel this day
			#find the cost if we were to buy a 1-day pass, 7-day pass and 30-day pass
            costs_extra_1 = costForDays[d - 1] + costs[0]
            costs_extra_7 = costForDays[max(0, d - 7)] + costs[1] 
            costs_extra_30 = costForDays[max(0, d - 30)] + costs[2]
            
			#get the minimum value
            costForDays[d] = min(costs_extra_1, costs_extra_7, costs_extra_30)
			
			#update the index to the next day we need to travel
            curIdx += 1
			
        return costForDays[-1]",sherlockieee
984,https://leetcode.com/problems/string-without-aaa-or-bbb/discuss/1729883/Python-beats-91,"class Solution:
    def strWithout3a3b(self, a: int, b: int) -> str:
        res = []
        while a + b > 0:
            if len(res) >= 2 and res[-2:] == ['a', 'a']:
                res.append('b')
                b-=1
            elif len(res) >= 2 and res[-2:] == ['b', 'b']:
                res.append('a')
                a-=1
            elif a > b:
                res.append('a')
                a-=1
            else:
                res.append('b')
                b-=1
            
        return ''.join(res)",leopardcoderd
985,https://leetcode.com/problems/sum-of-even-numbers-after-queries/discuss/2603372/LeetCode-The-Hard-Way-Explained-Line-By-Line,"class Solution:
    # the idea is we don't calculate the even sum from scratch for each query
    # instead, we calculate it at the beginning
    # since each query only updates one value, 
    # so we can adjust the even sum base on the original value and new value
    def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        # calculate the sum of all even numbers
        evenSum = sum(x for x in nums if x % 2 == 0)
        ans = []
        for val, idx in queries:
            # if original nums[idx] is even, then we deduct it from evenSum
            if nums[idx] % 2 == 0: evenSum -= nums[idx]
            # in-place update nums
            nums[idx] += val
            # check if we need to update evenSum for the new value
            if nums[idx] % 2 == 0: evenSum += nums[idx]
            # then we have evenSum after this query, push it to ans 
            ans.append(evenSum)
        return ans",wingkwong
986,https://leetcode.com/problems/interval-list-intersections/discuss/646939/Python-O(m%2Bn)-by-two-pointers.w-Graph,"class Solution:
    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        
        idx_a, idx_b = 0, 0
        size_a, size_b = len(A), len(B)
        
        intersection = []
        
        # Scan each possible interval pair
        while idx_a < size_a and idx_b < size_b :
            
            # Get start-time as well as end-time
            start_a, end_a = A[idx_a]
            start_b, end_b = B[idx_b]
            
            
            # Compute common start time and end time for current interval pair
            common_start = max( start_a, start_b )
            common_end = min( end_a, end_b )
            
            if common_start <= common_end:
                # Find one common overlapped interval
                intersection.append( [common_start, common_end] )
                
            if end_a <= end_b:
                # Try next interval of A
                idx_a += 1
                
            else:
                # Try next interval of B
                idx_b += 1
        
        return intersection",brianchiang_tw
987,https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/discuss/2526928/Python-BFS-%2B-Hashmap,"class Solution:
    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:
        results = defaultdict(list)
        
        queue = [ (root, 0, 0) ]
        
        while queue:
            node, pos, depth = queue.pop(0)
            if not node: continue
            results[(pos,depth)].append(node.val)
            results[(pos,depth)].sort()
            queue.extend( [ (node.left, pos-1, depth+1), (node.right, pos+1, depth+1) ] )
            
            
        res = defaultdict(list)
        keys = sorted(list(results.keys()), key=lambda x: (x[0], x[1]))
        
        
        for k in keys:
            pos, depth = k
            res[pos].extend(results[k])

        return res.values()",complete_noob
988,https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/422855/Python-readable.-44ms-99.7-14MB-100,"class Solution:
    res = 'z' * 13           # init max result, tree depth,  12< log2(8000) < 13
    
    def smallestFromLeaf(self, root: TreeNode) -> str:
        
        def helper(node: TreeNode, prev):
            prev = chr(97 + node.val) + prev
            
            if not node.left and not node.right:
                self.res = min(self.res, prev)
                return
            
            if node.left:
                helper(node.left, prev)
            if node.right:
                helper(node.right, prev)
        
        helper(root, """")
        return self.res",lsy7905
989,https://leetcode.com/problems/add-to-array-form-of-integer/discuss/2037608/Python3-or-One-line-solution,"class Solution:
    def addToArrayForm(self, num: List[int], k: int) -> List[int]:
        return list(str(int("""".join([str(x) for x in num])) + k))",manfrommoon
990,https://leetcode.com/problems/satisfiability-of-equality-equations/discuss/2624938/python3-oror-13-lines-sets-oror-1-TM%3A-8967,"class Solution:     # Here's the plan:
                    #   1) We make an undirected graph in which the nodes are integers
                    #      (as lower-case letters) and each edge connects integers
                    #      that are equal.
                    #   2) We use a union-find process to determine the connected graphs
                    #   3) We keep track of the pairs (a,b) such that a =! b. If the any
                    #      such pair are in the same connected graph, then return False,
                    #      otherwise return True.
    def equationsPossible(self, equations: List[str]) -> bool:
        parent, diff = {}, []

        def find(x):
            if x not in parent: return x
            else: return find(parent[x])

        for s in equations:                 # <-- 1)
            a, b = s[0], s[3]

            if s[1]== ""="":                  # <-- 2)
                x, y = find(a), find(b)
                if x!=y:
                    parent[y] = x
            else:    
                diff.append((a,b))          # <-- 3)

        return all(find(a)!=find(b) for a, b in diff)",warrenruud
991,https://leetcode.com/problems/broken-calculator/discuss/1033822/Easy-and-Clear-Solution-Python-3,"class Solution:
    def brokenCalc(self, x: int, y: int) -> int:
        if y<=x:
            return x-y
        else:
            res=0
            while x<y:
                if y%2==1:
                    y+=1
                else:
                    y=y//2
                res+=1
            res+=(x-y)
            return res",moazmar
992,https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/1215277/Python-Sliding-Window-or-Set-%2B-HashMap,"class Solution:
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        
        def window(nums, k):
            left = 0
            right = 0

            res = 0
            in_set = set()
            hash_map = collections.Counter()

            while right < len(nums):
                in_set.add(nums[right])
                hash_map[nums[right]] += 1

                while len(in_set) > k:
                    hash_map[nums[left]] -= 1
                    if hash_map[nums[left]] == 0:
                        in_set.remove(nums[left])
                    left += 1

                res += (right - left + 1)

                right += 1
            return res
    
       return window(nums, k) - window(nums, k - 1)",Sai-Adarsh
993,https://leetcode.com/problems/cousins-in-binary-tree/discuss/1527334/Python-BFS%3A-Easy-to-understand-solution-w-Explanation,"class Solution:
    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:
		# Check if root node is x or y
        if root.val == x or root.val == y:
            return False
		# Prepare for BFS, initialise variables
        curr, flag = [root.left, root.right], False
		
        while curr:
            tmp = []
			# Check nodes two-by-two
            for i in range(0, len(curr), 2):
				# Case 1: x and y are both found
				# This indicates that they have the same parent
                if curr[i] and curr[i+1] and \
                       ((curr[i].val == x and curr[i+1].val == y) or \
                       (curr[i+1].val == x and curr[i].val == y)):
                    return False
				# Case 2: Either one of x or y is found
                elif (curr[i] and (curr[i].val == x or curr[i].val == y)) or \
                        (curr[i+1] and (curr[i+1].val == x or curr[i+1].val == y)):
                    if flag:
						# Previously, the other node has been found in the same depth
						# This is our success condition, return True
                        return True
					# Otherwise, this is the first node in the current depth to be found
                    flag = True
				
				# Simultaneously, we can prepare the nodes for the subsequent depth
				# Note to append both left and right regardless of existence
                if curr[i]:
                    tmp.append(curr[i].left)
                    tmp.append(curr[i].right)
                if curr[i+1]:
                    tmp.append(curr[i+1].left)
                    tmp.append(curr[i+1].right)
			
			# Before we proceed to the next depth, check:
            if flag:
				# One of the nodes has already been found
				# This means that the other node cannot be of the same depth
				# By definition, this means that the two nodes are not cousins
                return False
            curr = tmp  # Assign the new nodes as the current ones
		
		# The program will never reach here since x and y are guaranteed to be found
		# But you can return False if you want",zayne-siew
994,https://leetcode.com/problems/rotting-oranges/discuss/1546489/Python-BFS%3A-Easy-to-understand-with-Explanation,"class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        visit, curr = set(), deque()
		# find all fresh and rotten oranges
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    visit.add((i, j))
                elif grid[i][j] == 2:
                    curr.append((i, j))
        result = 0
        while visit and curr:
			# BFS iteration
            for _ in range(len(curr)):
                i, j = curr.popleft()  # obtain recent rotten orange
                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):
                    if coord in visit:  # check if adjacent orange is fresh
                        visit.remove(coord)
                        curr.append(coord)
            result += 1
		# check if fresh oranges remain and return accordingly
        return -1 if visit else result",zayne-siew
998,https://leetcode.com/problems/maximum-binary-tree-ii/discuss/2709985/Python-short-python-solution,"class Solution:
    def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root: return TreeNode(val)
        if val > root.val: return TreeNode(val, root)
        root.right = self.insertIntoMaxTree(root.right, val)
        return root",scrptgeek
999,https://leetcode.com/problems/available-captures-for-rook/discuss/356593/Solution-in-Python-3-(beats-~97)-(three-lines),"class Solution:
    def numRookCaptures(self, b: List[List[str]]) -> int:
        I, J = divmod(sum(b,[]).index('R'),8)
        C = """".join([i for i in [b[I]+['B']+[b[i][J] for i in range(8)]][0] if i != '.'])
        return C.count('Rp') + C.count('pR')
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
1000,https://leetcode.com/problems/minimum-cost-to-merge-stones/discuss/1465680/Python3-dp,"class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:
        if (len(stones)-1) % (k-1): return -1 # impossible
        
        prefix = [0]
        for x in stones: prefix.append(prefix[-1] + x)
        
        @cache
        def fn(lo, hi): 
            """"""Return min cost of merging stones[lo:hi].""""""
            if hi - lo < k: return 0 # not enough stones
            ans = inf 
            for mid in range(lo+1, hi, k-1): 
                ans = min(ans, fn(lo, mid) + fn(mid, hi))
            if (hi-lo-1) % (k-1) == 0: ans += prefix[hi] - prefix[lo]
            return ans 
        
        return fn(0, len(stones))",ye15
1001,https://leetcode.com/problems/grid-illumination/discuss/1233528/Python-or-HashMap-or-O(L%2BQ)-or-928ms,"class Solution:
    def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:
        lamps = {(r, c) for r, c in lamps}
        
        row, col, left, right = dict(), dict(), dict(), dict()
        for r, c in lamps:
            row[r] = row.get(r, 0) + 1
            col[c] = col.get(c, 0) + 1
            left[r - c] = left.get(r - c, 0) + 1
            right[r + c] = right.get(r + c, 0) + 1

        res = list()
        for qr, qc in queries:
            if row.get(qr, 0) or col.get(qc, 0) or left.get(qr - qc, 0) or right.get(qr + qc, 0):
                res.append(1)
            else:
                res.append(0)

            for r, c in product(range(qr - 1, qr + 2), range(qc - 1, qc + 2)):
                if (r, c) in lamps:
                    lamps.remove((r, c))
                    row[r] -= 1
                    col[c] -= 1
                    left[r - c] -= 1
                    right[r + c] -= 1

        return res",PuneethaPai
1002,https://leetcode.com/problems/find-common-characters/discuss/721548/Python-Faster-than-77.67-and-Better-Space-than-86.74,"class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        alphabet = string.ascii_lowercase
        d = {c: 0 for c in alphabet}
        
        for k, v in d.items():
            d[k] = min([word.count(k) for word in A])

        res = []
        for c, n in d.items():
            if n > 0:
                res += [c] * n
        return res",parkershamblin
1003,https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/discuss/1291378/python-solution-using-stack,"class Solution:
    def isValid(self, s: str) -> bool:
        stack=[]
        for i in s:
            if i == 'a':stack.append(i)
            elif i=='b':
                if not stack:return False
                else:
                    if stack[-1]=='a':stack.pop()
                    else:return False
                    stack.append(i)
            else:
                if not stack:return False
                else:
                    if stack[-1]=='b':stack.pop()
                    else:return False

        return len(stack)==0",chikushen99
1004,https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1793625/Python-3-Very-typical-sliding-window-%2B-hashmap-problem.,"class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        left = 0
        answer = 0
        counts = {0: 0, 1: 0}
        
        for right, num in enumerate(nums):
            counts[num] += 1
            
            while counts[0] > k:
                counts[nums[left]] -= 1
                left += 1
                
            curr_window_size = right - left + 1
            answer = max(answer, curr_window_size)
            
        return answer",seankala
1005,https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/discuss/1120243/WEEB-EXPLAINS-PYTHON-SOLUTION,"class Solution:
	def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
		A.sort()
		i = 0
		while i < len(A) and K>0:
			if A[i] < 0: # negative value
				A[i] = A[i] * -1 # update the list, change negative to positive
				K-=1

			elif A[i] > 0: # positive value
				if K % 2 == 0: # let K==2(must be even value), this means -1*-1==1 so it has no effect on sum
					return sum(A)
				else: return sum(A) - 2 * min(A) # let A==[1,2,3],K=1, so equation is 6-2(1)==4, same as -1+2+3=4 after taking the minimum in the list to give the largest possible sum required in the question

			else: return sum(A) # if A[i]==0,just sum cuz 0 is neutral: 1-0==1 or 1+0==1 thus no change just sum

			i+=1

		if K > len(A): # that means we have changed all values to positive
			A.sort() # cuz now its the opposite let A = [-4,-2,-3], K = 8, now flipping all negatives to positives, we have a new minimum which is 2
			if K % 2 == 0: # Here onwards is basically the same thing from before
				return sum(A)
			else: return sum(A) - 2 * min(A)

		return sum(A)",Skywalker5423
1006,https://leetcode.com/problems/clumsy-factorial/discuss/395085/Three-Solutions-in-Python-3-(beats-~99)-(one-line),"class Solution:
    def clumsy(self, N: int) -> int:
    	return N + ([1,2,2,-1][N % 4] if N > 4 else [0,0,0,3,3][N])",junaidmansuri
1007,https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/discuss/1865333/Python3-UNPRECENDENT-NUMBER-OF-COUNTERS-o()o-Explained,"class Solution:
    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:
        total = len(tops)
        top_fr, bot_fr, val_total = [0]*7, [0]*7, [total]*7
        for top, bot in zip(tops, bottoms):
            if top == bot:
                val_total[top] -= 1
            else:
                top_fr[top] += 1
                bot_fr[bot] += 1
                
        for val in range(1, 7):
            if (val_total[val] - top_fr[val]) == bot_fr[val]:
                return min(top_fr[val], bot_fr[val])
            
        return -1",artod
1008,https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/649369/Python.-No-recursion.,"class Solution:
    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        node_stack = []
        node = root = TreeNode(preorder[0])
        for n in preorder[1:]:
            if n <= node.val:
                node.left = TreeNode(n)
                node_stack.append(node)
                node = node.left
            else:
                while node_stack and n > node_stack[-1].val:
                    node = node_stack.pop()
                node.right = TreeNode(n)
                node = node.right
        return root",techrabbit58
1009,https://leetcode.com/problems/complement-of-base-10-integer/discuss/1666811/Python-Simple-Solution-with-Detail-Explanation-%3A-O(log-n),"class Solution:
    def bitwiseComplement(self, n: int) -> int:
        if n == 0:
            return 1
        else:
            result = 0
            factor = 1
            
            while(n > 0):
                result += factor * (1 if n%2 == 0 else 0)
                factor *= 2
                n //= 2
            return result",yashitanamdeo
1010,https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/discuss/422213/Python-O(n)-6-Lines-beats-86-time,"class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        res  , count  = 0,  [0] * 60
        for one in range(len(time)):
            index = time[one] % 60
            res += count[(60 - index)%60] # %60 is for index==0
            count[index] += 1
        return res",macqueen
1011,https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/1581292/Well-Explained-oror-Thought-process-oror-94-faster,"class Solution:
def shipWithinDays(self, weights: List[int], D: int) -> int:
    
    def feasible(capacity):
        days = 1
        local = 0
        for w in weights:
            local+=w
            if local>capacity:
                local = w
                days+=1
                if days>D:
                    return False
        return True
            
                
    left, right = max(weights), sum(weights)
    while left < right:
        mid = left + (right-left)//2
        if feasible(mid):
            right = mid
        else:
            left = mid + 1
            
    return left",abhi9Rai
1012,https://leetcode.com/problems/numbers-with-repeated-digits/discuss/332462/Solution-in-Python-3-(beats-~99),"class Solution:
    def numDupDigitsAtMostN(self, N: int) -> int:
    	T = [9,261,4725,67509,831429,9287109,97654149,994388229]
    	t = [99,999,9999,99999,999999,9999999,99999999,999999999]
    	if N < 10:
    		return 0
    	L = len(str(N))
    	m, n = [1], []
    	g = 11-L
    	for i in range(L):
    		n.append(int(str(N)[i]))
    		m.append(g)
    		g = g*(12-L+i)
    	S = 0
    	for i in range(L):
    		if len(set(n[:L-i-1])) != len(n)-i-1:
    			continue
    		k = 0
    		for j in range(10):
    			if j not in n[:L-i-1] and j > n[L-i-1]:
    				k += 1
    		S += k*m[i]
    	return(T[L-2]-(t[L-2]-N-S))
	
- Python 3
- Junaid Mansuri",junaidmansuri
1013,https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/discuss/352417/Solution-in-Python-3-(beats-~99)-(With-Detailed-Explanation)-(-O(n)-time-)-(-O(1)-space-),"class Solution:
    def canThreePartsEqualSum(self, A: List[int]) -> bool:
    	S = sum(A)
    	if S % 3 != 0: return False
    	g, C, p = S//3, 0, 0
    	for a in A[:-1]:
    		C += a
    		if C == g:
    			if p == 1: return True
    			C, p = 0, 1
    	return False",junaidmansuri
1014,https://leetcode.com/problems/best-sightseeing-pair/discuss/1521786/oror-Very-easy-explanation-oror-DP-oror-Complexity-Analysis-oror-Python,"class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:      
      dp = [0]*(len(values))
      dp[0] = values[0]
      maxVal = 0
      
      for i in range(1, len(values)):
        dp[i] = max(dp[i-1], values[i-1]+i-1)
        maxVal = max(maxVal, dp[i]+values[i]-i)
      
      return maxVal",siddp6
1016,https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/discuss/1106296/Python3-2-approaches,"class Solution:
    def queryString(self, S: str, N: int) -> bool:
        for x in range(N, 0, -1):
            if bin(x)[2:] not in S: return False 
        return True",ye15
1017,https://leetcode.com/problems/convert-to-base-2/discuss/2007392/PYTHON-SOL-oror-EASY-oror-BINARY-CONVERSION-oror-WELL-EXPLAINED-oror,"class Solution:
    def baseNeg2(self, n: int) -> str:
        ans = """"
        while n != 0:
            if n%-2 != 0 :
                ans = '1' + ans
                n = (n-1)//-2
            else:
                ans = '0' + ans
                n = n//-2
        return ans if ans !="""" else '0'",reaper_27
1018,https://leetcode.com/problems/binary-prefix-divisible-by-5/discuss/356289/Solution-in-Python-3-(beats-~98)-(three-lines)-(-O(1)-space-),"class Solution:
    def prefixesDivBy5(self, A: List[int]) -> List[bool]:
    	n = 0
    	for i in range(len(A)): A[i], n = (2*n + A[i]) % 5 == 0, (2*n + A[i]) % 5
    	return A
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
1019,https://leetcode.com/problems/next-greater-node-in-linked-list/discuss/283607/Clean-Python-Code,"class Solution:
    def nextLargerNodes(self, head: ListNode) -> List[int]:
        result = []
        stack = []
        for i, current in enumerate(self.value_iterator(head)):
            result.append(0)
            while stack and stack[-1][0] < current:
                _, index = stack.pop()
                result[index] = current
            stack.append((current, i))
        return result

    def value_iterator(self, head: ListNode):
        while head is not None:
            yield head.val
            head = head.next",aquafie
1020,https://leetcode.com/problems/number-of-enclaves/discuss/1040282/Python-BFS-and-DFS-by-yours-truly,"class Solution:
def numEnclaves(self, A: List[List[int]]) -> int:
    row, col = len(A), len(A[0])
    
    if not A or not A[0]:
        return 0
    
    boundary1 = deque([(i,0) for i in range(row) if A[i][0]==1]) + deque([(i,col-1) for i in range(row) if A[i][col-1]==1])
    boundary2 = deque([(0,i) for i in range(1,col-1) if A[0][i]==1]) + deque([(row-1,i) for i in range(1,col-1) if A[row-1][i]==1])
        
    queue = boundary1+boundary2
    
    
    def bfs(queue,A):
        visited = set()
        while queue:
            x,y = queue.popleft()
            A[x][y] = ""T""
            if (x,y) in visited: continue
            visited.add((x,y))
            for nx,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:
                if 0<=nx<row and 0<=ny<col and A[nx][ny]==1:
                    A[nx][ny] = ""T""
                    queue.append((nx,ny))
        return A
    
    bfs(queue,A)
    
    count = 0
    for x in range(row):
        for y in range(col):
            if A[x][y] == 1:
                count+=1
    return count",Skywalker5423
1021,https://leetcode.com/problems/remove-outermost-parentheses/discuss/1162269/Python-Simplest-Solution,"class Solution:
    def removeOuterParentheses(self, S: str) -> str:
        
        stack=[]
        counter=0
        for i in S:
            if i=='(':
                counter=counter+1
                if counter==1:
                    pass
                else:
                    stack.append(i)
            else:
                counter=counter-1
                if counter == 0:
                    pass
                else:
                    stack.append(i)
        return (''.join(stack))",aishwaryanathanii
1022,https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/1681647/Python3-5-LINES-(-)-Explained,"class Solution:
    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
        def dfs(node, path):
            if not node: return 0

            path = (path << 1) + node.val
			
            if not node.left and not node.right:
                return path
            
            return dfs(node.left, path) + dfs(node.right, path)
            
        return dfs(root, 0)",artod
1023,https://leetcode.com/problems/camelcase-matching/discuss/488216/Python-Two-Pointer-Memory-usage-less-than-100,"class Solution:
    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
        
        def match(p, q):
            i = 0
            for j, c in enumerate(q):
                if i < len(p) and p[i] == q[j]: i += 1
                elif q[j].isupper(): return False
            return i == len(p)
        
        return [True if match(pattern, s) else False for s in queries]",mmbhatk
1024,https://leetcode.com/problems/video-stitching/discuss/2773366/greedy,"class Solution:
    def videoStitching(self, clips: List[List[int]], T: int) -> int:
        end, end2, res = -1, 0, 0
        for i, j in sorted(clips):
            if end2 >= T or i > end2:
                break
            elif end < i <= end2:
                res, end = res + 1, end2
            end2 = max(end2, j)
        return res if end2 >= T else -1",yhu415
1025,https://leetcode.com/problems/divisor-game/discuss/382233/Solution-in-Python-3-(With-Detailed-Proof),"class Solution:
    def divisorGame(self, N: int) -> bool:
        return N % 2 == 0
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
1026,https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/discuss/1657537/Python3-Simplifying-Tree-to-Arrays-oror-Detailed-Explanation-%2B-Intuition-oror-Preorder-DFS,"class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        def dfs(root, mn, mx):
            # Base Case: If we reach None, just return 0 in order not to affect the result
            if not root: return 0
            
			# The best difference we can do using the current node can be found:
            res = max(abs(root.val - mn), abs(root.val - mx))
			
			# Recompute the new minimum and maximum taking into account the current node
            mn, mx = min(mn, root.val), max(mx, root.val)
			
			# Recurse left and right using the newly computated minimum and maximum
            return max(res, dfs(root.left, mn, mx), dfs(root.right, mn, mx))
        
        # Initialize minimum `mn` and maximum `mx` equals value of given root
        return dfs(root, root.val, root.val)",PatrickOweijane
1027,https://leetcode.com/problems/longest-arithmetic-subsequence/discuss/415281/Python-DP-solution,"class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        dp = {}
        for i, a2 in enumerate(A[1:], start=1):
            for j, a1 in enumerate(A[:i]):
                d = a2 - a1
                if (j, d) in dp:
                    dp[i, d] = dp[j, d] + 1
                else:
                    dp[i, d] = 2
        return max(dp.values())",yasufumy
1028,https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/discuss/1179506/Python3-stack,"class Solution:
    def recoverFromPreorder(self, S: str) -> TreeNode:
        stack = []
        depth, val = 0, """"
        for i, x in enumerate(S): 
            if x == ""-"": 
                depth += 1
                val = """"
            else: 
                val += S[i]
                if i+1 == len(S) or S[i+1] == ""-"": 
                    node = TreeNode(int(val))
                    while len(stack) > depth: stack.pop()
                    if stack:
                        if not stack[-1].left: stack[-1].left = node
                        else: stack[-1].right = node
                    stack.append(node)
                    depth = 0
        return stack[0]",ye15
1029,https://leetcode.com/problems/two-city-scheduling/discuss/297143/Python-faster-than-93-28-ms,"class Solution(object):
    def twoCitySchedCost(self, costs):
        """"""
        :type costs: List[List[int]]
        :rtype: int
        """"""
        a = sorted(costs, key=lambda x: x[0]-x[1])
        Sa = 0
        Sb = 0
        for i in range(len(a)//2):
            Sa += a[i][0]
            
        for i in range(len(a)//2, len(a)):
            Sb += a[i][1]
        return Sa + Sb",il_buono
1030,https://leetcode.com/problems/matrix-cells-in-distance-order/discuss/1202122/Python3-simple-solution-using-dictionary,"class Solution:
    def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:
        d = {}
        for i in range(R):
            for j in range(C):
                d[(i,j)] = d.get((i,j),0) + abs(r0-i) + abs(c0-j)
        return [list(i) for i,j in sorted(d.items(), key = lambda x : x[1])]",EklavyaJoshi
1031,https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/1012572/Python3-dp-(prefix-sum),"class Solution:
    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
        prefix = [0]
        for x in A: prefix.append(prefix[-1] + x) # prefix sum w/ leading 0
        ans = lmx = mmx = -inf 
        for i in range(M+L, len(A)+1): 
            lmx = max(lmx, prefix[i-M] - prefix[i-L-M])
            mmx = max(mmx, prefix[i-L] - prefix[i-L-M])
            ans = max(ans, lmx + prefix[i] - prefix[i-M], mmx + prefix[i] - prefix[i-L])
        return ans",ye15
1033,https://leetcode.com/problems/moving-stones-until-consecutive/discuss/283466/Clean-Python-beats-100,"class Solution:
    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
        x, y, z = sorted([a, b, c])
        if x + 1 == y == z - 1:
            min_steps = 0
        elif y - x > 2 and z - y > 2:
            min_steps = 2
        else:
            min_steps = 1
        max_steps = z - x - 2
        return [min_steps, max_steps]",aquafie
1034,https://leetcode.com/problems/coloring-a-border/discuss/2329163/Python-DFS-and-Border-Co-ordinates,"class Solution:
    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:
        
        rows, cols = len(grid), len(grid[0])
        border_color = grid[row][col]
        border = []
        
		# Check if a node is a border node or not
        def is_border(r, c):
            if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:
                return True

            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                nr, nc = r + dr, c + dc
                if grid[nr][nc] != border_color:
                    return True
            return False                
        
        def dfs(r, c):
            if r < 0 or c < 0 or r == rows or c == cols or (r, c) in visited or grid[r][c] != border_color:
                return
            visited.add((r, c))
            
            if is_border(r, c):
                border.append((r, c))
            
            dfs(r + 1, c)
            dfs(r - 1, c)
            dfs(r, c + 1)
            dfs(r, c - 1)
        
        visited = set()
        dfs(row, col)
        for r, c in border:
            grid[r][c] = color
        return grid",tejeshreddy111
1035,https://leetcode.com/problems/uncrossed-lines/discuss/1502848/Python3-or-Memoization%2BRecursion,"class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        e1=len(nums1)
        e2=len(nums2)
        @lru_cache(None,None)
        def dfs(s1,s2):
            best=-float('inf')
            if s1>=e1 or s2>=e2:
                return 0
            temp=[]
            op1=0
			#finding element in array2 which is equal to element in array1 from where we want to draw line
            for idx in range(s2,e2):
                if nums2[idx]==nums1[s1]:
                    temp.append(idx)
			#drawing line to all those element and checking which gives maximum value
            for j in temp:
                op1=1+dfs(s1+1,j+1)
                best=max(op1,best)
			#choosing to not draw line from current element of array1
            op2=dfs(s1+1,s2)
			#returning max of both options.
            return max(op2,best)
        return dfs(0,0)",swapnilsingh421
1036,https://leetcode.com/problems/escape-a-large-maze/discuss/1292945/Python3-bfs-and-dfs,"class Solution:
    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        blocked = set(map(tuple, blocked))
        
        def fn(x, y, tx, ty): 
            """"""Return True if (x, y) is not looped from (tx, ty).""""""
            seen = {(x, y)}
            queue = [(x, y)]
            level = 0 
            while queue: 
                level += 1
                if level > 200: return True 
                newq = []
                for x, y in queue: 
                    if (x, y) == (tx, ty): return True 
                    for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): 
                        if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: 
                            seen.add((xx, yy))
                            newq.append((xx, yy))
                queue = newq
            return False 
        
        return fn(*source, *target) and fn(*target, *source)",ye15
1037,https://leetcode.com/problems/valid-boomerang/discuss/1985698/Python-3-Triangle-Area,"class Solution:
    def isBoomerang(self, points: List[List[int]]) -> bool:
        x1, y1 = points[0]
        x2, y2 = points[1]
        x3, y3 = points[2]
        
        area = abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2
        return area != 0",hari19041
1038,https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/discuss/1270148/Recursive-approch-99.88-accuracy-Python,"class Solution:
    def bstToGst(self, root: TreeNode) -> TreeNode:
        s = 0
        def f(root):
            if root is None: return
            nonlocal s
            f(root.right)
            #print(s,root.val)
            s = s + root.val
            root.val = s
            f(root.left)
        f(root)
        return root",rstudy211
1039,https://leetcode.com/problems/minimum-score-triangulation-of-polygon/discuss/391440/Two-Solutions-in-Python-3-(DP)-(Top-Down-and-Bottom-Up),"class Solution:
    def minScoreTriangulation(self, A: List[int]) -> int:
    	SP, LA = [[0]*50 for i in range(50)], len(A)
    	def MinPoly(a,b):
    		L, m = b - a + 1, math.inf; 
    		if SP[a][b] != 0 or L < 3: return SP[a][b]
    		for i in range(a+1,b): m = min(m, A[a]*A[i]*A[b] + MinPoly(a,i) + MinPoly(i,b))
    		SP[a][b] = m; return SP[a][b]
    	return MinPoly(0,LA-1)",junaidmansuri
1040,https://leetcode.com/problems/moving-stones-until-consecutive-ii/discuss/1488487/Python-Sliding-window-with-detailed-expalanation,"class Solution:
    def numMovesStonesII(self, stones: list[int]) -> list[int]:
        """"""
        1. For the higher bound, it is determined by either moving the leftmost
            to the right side, or by moving the rightmost to the left side:
            1.1 If moving leftmost to the right side, the available moving
                positions are A[n - 1] - A[1] + 1 - (n - 1) = 
                A[n - 1] - A[1] - n + 2
            1.2 If moving rightmost to the left side, the available moving
                positions are A[n - 2] - A[0] + 1 - (n - 1) = 
                A[n - 2] - A[0] - n + 2.
        2. For the lower bound, we could use sliding window to find a window
            that contains the most consecutive stones (A[i] - A[i - 1] = 1):
            2.1 Generally the moves we need are the same as the number of
                missing stones in the current window.
            2.3 When the window is already consecutive and contains all the
                n - 1 stones, we need at least 2 steps to move the last stone
                into the current window. For example, 1,2,3,4,10:
                2.3.1 We need to move 1 to 6 first as we are not allowed to
                    move 10 to 5 as it will still be an endpoint stone.
                2.3.2 Then we need to move 10 to 5 and now the window becomes
                    2,3,4,5,6.
        """"""
        A, N = sorted(stones), len(stones)
        maxMoves = max(A[N - 1] - A[1] - N + 2, A[N - 2] - A[0] - N + 2)
        minMoves = N

        # Calculate minimum moves through sliding window.
        start = 0
        for end in range(N):
            while A[end] - A[start] + 1 > N:
                start += 1

            if end - start + 1 == N - 1 and A[end] - A[start] + 1 == N - 1:
                # Case: N - 1 stones with N - 1 positions.
                minMoves = min(minMoves, 2)
            else:
                minMoves = min(minMoves, N - (end - start + 1))

        return [minMoves, maxMoves]",eroneko
1041,https://leetcode.com/problems/robot-bounded-in-circle/discuss/1676693/Python3-Simple-4-Loops-or-O(n)-Time-or-O(1)-Space,"class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
        x = y = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        i = 0
        while True:
            for do in instructions:
                if do == 'G':
                    x += directions[i][0]
                    y += directions[i][1]
                elif do == 'R':
                    i = (i + 1) % 4
                else:
                    i = (i - 1) % 4
                    
            if i == 0:
                return x == 0 and y == 0",PatrickOweijane
1042,https://leetcode.com/problems/flower-planting-with-no-adjacent/discuss/557619/**Python-Simple-DFS-solution-70-80-**,"class Solution:
    def gardenNoAdj(self, N: int, paths: List[List[int]]) -> List[int]:
        G = defaultdict(list)
        for path in paths:
            G[path[0]].append(path[1])
            G[path[1]].append((path[0]))
        colored = defaultdict()

        def dfs(G, V, colored):
            colors = [1, 2, 3, 4]
            for neighbour in G[V]:
                if neighbour in colored:
                    if colored[neighbour] in colors:
                        colors.remove(colored[neighbour])
            colored[V] = colors[0]

        for V in range(1, N + 1):
            dfs(G, V, colored)

        ans = []
        for V in range(len(colored)):
            ans.append(colored[V + 1])

        return ans",art35part2
1043,https://leetcode.com/problems/partition-array-for-maximum-sum/discuss/1621079/Python-Easy-DP-with-Visualization-and-examples,"class Solution:
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        n = len(arr)
        dp = [0]*n
        
        # handle the first k indexes differently
        for j in range(k): dp[j]=max(arr[:j+1])*(j+1)
        
        # we can get rid of index i by running i times
        for j in range(k,n):
            curr = []
            for m in range(k):
                curr.append(dp[j-m-1] + max(arr[(j-m):(j+1)]) * (m+1))
            dp[j] = max(curr)

        return dp[-1]",sashaxx
1044,https://leetcode.com/problems/longest-duplicate-substring/discuss/2806471/Python-Easy-or-Simple-or-Binary-Solution,"class Solution:
    def longestDupSubstring(self, s: str) -> str:
        length = len(s)
        l,r = 0, length-1        
        result = []
        while l<r:
            mid = (l+r)//2
            d = {}
            max_string = """"
            for i in range(length-mid):
                    if d.get(s[i:i+mid+1],0):
                        max_string = s[i:i+mid+1]
                        break
                    d[s[i:i+mid+1]] = 1
            if max_string:
                l = mid+1
                result.append(max_string)
            else:
                r = mid
        return max(result,key=len) if result else """"",girraj_14581
1046,https://leetcode.com/problems/last-stone-weight/discuss/1921241/Python-Beginner-friendly-Optimisation-Process-with-Explanation,"class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones.sort()
        while stones:
            s1 = stones.pop()  # the heaviest stone
            if not stones:  # s1 is the remaining stone
                return s1
            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1
            if s1 > s2:
                # we need to insert the remaining stone (s1-s2) into the list
                pass
            # else s1 == s2; both stones are destroyed
        return 0  # if no more stones remain",zayne-siew
1047,https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/discuss/1291694/Easy-Python-Solution(89.05),"class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack=[s[0]]
        for i in range(1,len(s)):
            if(stack and stack[-1]==s[i]):
                stack.pop()
            else:
                stack.append(s[i])
        return """".join(stack)",Sneh17029
1048,https://leetcode.com/problems/longest-string-chain/discuss/2152864/PYTHON-oror-EXPLAINED-oror,"class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        
        words.sort(key=len)
        dic = {}
        
        for i in words:
            dic[ i ] = 1
            
            for j in range(len(i)):
                
                # creating words by deleting a letter
                successor = i[:j] + i[j+1:]
                if successor in dic:
                    dic[ i ] = max (dic[i], 1 + dic[successor])
        
        res = max(dic.values())
        return res",karan_8082
1049,https://leetcode.com/problems/last-stone-weight-ii/discuss/1013873/Python3-top-down-dp,"class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        
        @lru_cache(None)
        def fn(i, v): 
            """"""Return minimum weight of stones[i:] given existing weight.""""""
            if i == len(stones): return abs(v)
            return min(fn(i+1, v - stones[i]), fn(i+1, v + stones[i]))
        
        return fn(0, 0)",ye15
1051,https://leetcode.com/problems/height-checker/discuss/429670/Python-3-O(n)-Faster-than-100-Memory-usage-less-than-100,"class Solution:
    def heightChecker(self, heights: List[int]) -> int:
   
        max_val = max(heights)
        
        # Create frequency table
        freq = [0] * (max_val + 1)
        for num in heights: freq[num] += 1
        for num in range(1, len(freq)): freq[num] += freq[num-1]

        # Create places table
        places = [0] * len(heights)
        for num in heights:
            places[freq[num]-1] = num
            freq[num] -= 1

        return sum([a!=b for a, b in zip(heights, places)])",mmbhatk
1052,https://leetcode.com/problems/grumpy-bookstore-owner/discuss/441491/Python-(97)-Easy-to-understand-Sliding-Window-with-comments,"class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:
        # a sliding window approach
        currsum = 0
        # first store the sum as if the owner has no super power
        for i in range(len(grumpy)):
            if not grumpy[i]:
                currsum += customers[i]
        
        # now assuming he has the power, take the first window 
        # and add to the previous sum
        for i in range(X):
            if grumpy[i]:
                currsum += customers[i]
        
        maxsum = currsum
        
        # Now the sliding window starts
        # i and j are the two opposite ends of the window
        i = 0
        j = X
        while j < len(customers):
            if grumpy[j]:
                currsum += customers[j]
            if grumpy[i]:
                currsum -= customers[i]
			# we subtract above as the window has already passed over that customer
            if currsum > maxsum:
                maxsum = currsum
            i += 1
            j += 1
        return maxsum",vdhyani96
1053,https://leetcode.com/problems/previous-permutation-with-one-swap/discuss/1646525/python-O(n)-time-O(1)-space-with-explanation,"class Solution:
	 def prevPermOpt1(self, nums: List[int]) -> List[int]:
		n = len(nums)-1
		left = n

    // find first non-decreasing number
    while left >= 0 and nums[left] >= nums[left-1]:
        left -= 1
        
	// if this hits, it means we have the smallest possible perm 
    if left <= 0:
        return nums
	
	// the while loop above lands us  at +1, so k is the actual value
    k = left - 1
    
    // find the largest number that's smaller than k 
    // while skipping duplicates
    right = n
    while right >= left:
        if nums[right] < nums[k] and nums[right] != nums[right-1]:
            nums[k], nums[right] = nums[right], nums[k]
            return nums
            
        right -= 1
   
    return nums",uzumaki01
1054,https://leetcode.com/problems/distant-barcodes/discuss/411386/Two-Solutions-in-Python-3-(six-lines)-(beats-~95),"class Solution:
    def rearrangeBarcodes(self, B: List[int]) -> List[int]:
        L, A, i = len(B), [0]*len(B), 0
        for k,v in collections.Counter(B).most_common():
            for _ in range(v):
                A[i], i = k, i + 2
                if i >= L: i = 1
        return A



class Solution:
    def rearrangeBarcodes(self, B: List[int]) -> List[int]:
        L, C = len(B), collections.Counter(B)
        B.sort(key = lambda x: (C[x],x))
        B[1::2], B[::2] = B[:L//2], B[L//2:]
        return B
		
		
- Junaid Mansuri",junaidmansuri
1071,https://leetcode.com/problems/greatest-common-divisor-of-strings/discuss/860984/Python-3-or-GCD-1-liner-or-Explanation,"class Solution:
    def gcdOfStrings(self, s1: str, s2: str) -> str:
        return s1[:math.gcd(len(s1), len(s2))] if s1 + s2 == s2 + s1 else ''",idontknoooo
1072,https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/discuss/1440662/97-faster-oror-Well-Explained-with-example-oror-Easy-Approach,"class Solution:
def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
    
    dic = defaultdict(int)
    for row in matrix:
        local=[]
        for c in row:
            local.append(c^row[0])
        dic[tuple(local)]+=1
    
    return max(dic.values())",abhi9Rai
1073,https://leetcode.com/problems/adding-two-negabinary-numbers/discuss/1384126/Python-3-or-Math-Two-Pointers-or-Explanation,"class Solution:
    def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:
        ans = list()
        m, n = len(arr1), len(arr2)
        i, j = m-1, n-1
        def add(a, b):                                         # A helper function to add -2 based numbers
            if a == 1 and b == 1:
                cur, carry = 0, -1
            elif (a == -1 and b == 0) or (a == 0 and b == -1):    
                cur = carry = 1
            else:    
                cur, carry = a+b, 0
            return cur, carry                                  # Return current value and carry
        carry = 0
        while i >= 0 or j >= 0:                                # Two pointers from right side
            cur, carry_1, carry_2 = carry, 0, 0
            if i >= 0:
                cur, carry_1 = add(cur, arr1[i])
            if j >= 0:    
                cur, carry_2 = add(cur, arr2[j])
            carry = carry_1 + carry_2
            ans.append(cur)
            i, j = i-1, j-1
        ans = [1,1] + ans[::-1] if carry == -1 else ans[::-1]  # Add [1, 1] if there is a carry -1 leftover
        for i, v in enumerate(ans):                            # Remove leading zero and return
            if v == 1:
                return ans[i:]
        else:
            return [0]",idontknoooo
1074,https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/2118388/or-PYTHON-SOL-or-EASY-or-EXPLAINED-or-VERY-SIMPLE-or-COMMENTED-or,"class Solution:
    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        # find the rows and columns of the matrix
        n,m = len(matrix) , len(matrix[0])
        # find the prefix sum for each row
        for i in range(n):
            for j in range(1,m):
                matrix[i][j] += matrix[i][j-1]
        ans = 0
        # fix the left boundary of the column
        for start in range(m):
            # fix the right boundary of the column
            for end in range(start,m):
                # a dictionary to map data
                d = defaultdict(lambda:0)
                d[0] = 1
                summ = 0
                # now we do check at each row
                for i in range(n):
                    curr = matrix[i][end]
                    if start > 0: curr -= matrix[i][start-1]
                    summ += curr
                    ans += d[summ - target]
                    d[summ] += 1
        return ans",reaper_27
1078,https://leetcode.com/problems/occurrences-after-bigram/discuss/1443810/Using-stack-for-words-93-speed,"class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        ans, stack = [], []
        for w in text.split():
            if len(stack) > 1 and stack[-2] == first and stack[-1] == second:
                ans.append(w)
            stack.append(w)
        return ans",EvgenySH
1079,https://leetcode.com/problems/letter-tile-possibilities/discuss/774815/Python-3-Backtracking-(no-set-no-itertools-simple-DFS-count)-with-explanation,"class Solution:
    def numTilePossibilities(self, tiles: str) -> int:
        record = [0] * 26
        for tile in tiles: record[ord(tile)-ord('A')] += 1
        def dfs(record):
            s = 0
            for i in range(26):
                if not record[i]: continue
                record[i] -= 1
                s += dfs(record) + 1 
                record[i] += 1
            return s    
        return dfs(record)",idontknoooo
1080,https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/discuss/1350913/Simple-Python-Solution-or-O(N)-or-DFS,"class Solution:
    def sufficientSubset(self, root: TreeNode, limit: int, pathSum = 0) -> TreeNode:
        if not root: return None
        if not root.left and not root.right:
            if pathSum + root.val < limit:
                return None
            return root
        root.left = self.sufficientSubset(root.left, limit, pathSum + root.val)
        root.right = self.sufficientSubset(root.right, limit, pathSum + root.val)
        if not root.left and not root.right:
            return None
        return root",Astomak
1081,https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/discuss/894588/Python3-stack-O(N),"class Solution:
    def smallestSubsequence(self, s: str) -> str:
        loc = {x: i for i, x in enumerate(s)}
        stack = []
        for i, x in enumerate(s): 
            if x not in stack: 
                while stack and x < stack[-1] and i < loc[stack[-1]]: stack.pop()
                stack.append(x)
        return """".join(stack)",ye15
1089,https://leetcode.com/problems/duplicate-zeros/discuss/408059/Python-Simple-Solution,"class Solution:
	def duplicateZeros(self, arr: List[int]) -> None:
		i = 0
		n = len(arr)
		while(i<n):
			if arr[i]==0:
				arr.pop()
				arr.insert(i,0)
				i+=1
			i+=1",saffi
1090,https://leetcode.com/problems/largest-values-from-labels/discuss/1025001/Python3-greedy-O(NlogN),"class Solution:
    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:
        ans = 0
        freq = {}
        for value, label in sorted(zip(values, labels), reverse=True):
            if freq.get(label, 0) < use_limit: 
                ans += value
                num_wanted -= 1
                if not num_wanted: break 
                freq[label] = 1 + freq.get(label, 0)
        return ans",ye15
1091,https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/2043228/Python-Simple-BFS-with-Explanation,"class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        # check if source and target are not clear cells
        if grid[0][0] != 0 or grid[-1][-1] != 0:
            return -1
        
        N = len(grid)            
        # offsets required for all 8 directions
        offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        
        q = deque()
        q.append((0,0)) # starting point
        visited = {(0, 0)}
        
        
        # finds unvisited clear cells using 8 offsets
        def get_neighbours(x,y):
            for x_offset, y_offset in offsets:
                new_row = x + x_offset
                new_col = y + y_offset
                
                if 0 <= new_row < N and 0 <= new_col < N and not grid[new_row][new_col] and (new_row, new_col) not in visited:
                    yield (new_row, new_col)                                                
            
        
        current_distance = 1 # start with one clear cell
        # standard iterative BFS traversal
        while q:
            length = len(q)
            
            # loop through all the cells at the same distance
            for _ in range(length):
                row, col = q.popleft()
                
                if row == N-1 and col==N-1: # reached target
                    return current_distance
                
                # loop though all valid neignbours
                for p in get_neighbours(row, col):
                    visited.add(p)
                    q.append(p)
                                    
            current_distance+=1 # update the level or distance from source
        
        return -1",constantine786
1092,https://leetcode.com/problems/shortest-common-supersequence/discuss/786544/Simple-Python-Accepted-Solution-using-LCS-implementation-faster-than-83-python-users,"class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        n,m = len(str1),len(str2)
        dp = [[0 for j in range(m+1)]for i in range(n+1)]
        for i in range(1,n+1):
            for j in range(1,m+1):
                if str1[i-1] == str2[j-1]:
                    dp[i][j] = 1+dp[i-1][j-1]
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        i,j = n,m
        ans = """"
        while(i>0 and j>0):
            if str1[i-1] == str2[j-1]:
                ans += str1[i-1]
                i -= 1
                j -= 1
            else:
                if(dp[i-1][j] > dp[i][j-1]):
                    ans += str1[i-1]
                    i -= 1
                else:
                    ans += str2[j-1]
                    j -= 1
        while(i>0):
            ans += str1[i-1]
            i -= 1
        while(j>0):
            ans += str2[j-1]
            j -= 1
        return ans[::-1]",theflash007
1093,https://leetcode.com/problems/statistics-from-a-large-sample/discuss/1653119/Python3-one-liner,"class Solution:
    def sampleStats(self, count: List[int]) -> List[float]:
        return [
            #Minimum
            min(i for i,c in enumerate(count) if c != 0),
            #Maximum
            max(i for i,c in enumerate(count) if c != 0),
            #Mean
            sum(i*c for i,c in enumerate(count)) / sum(c for c in count if c != 0),
            #Media
            (lambda total:
                (
                    next(i for i,s in enumerate(itertools.accumulate(count)) if s >= total//2+1)+
                    next(i for i,s in enumerate(itertools.accumulate(count)) if s >= total//2+total%2)
                )/2
            )(sum(c for c in count if c != 0)),
            #Mode
            max(((i,c) for i,c in enumerate(count) if c != 0),key=(lambda x: x[1]))[0]
        ]",pknoe3lh
1094,https://leetcode.com/problems/car-pooling/discuss/1669593/Python3-STRAIGHTFORWARD-()-Explained,"class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        path = [0]*1000
        
        for num, a, b in trips:
            for loc in range (a, b):
                path[loc] += num
                if path[loc] > capacity: return False
                
        return True",artod
1095,https://leetcode.com/problems/find-in-mountain-array/discuss/1290875/Python3-binary-search,"class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        
        def fn(lo, hi, mult): 
            """"""Return index of target between lo (inclusive) and hi (exlusive).""""""
            while lo < hi: 
                mid = lo + hi >> 1
                if mountain_arr.get(mid) == target: return mid 
                elif mountain_arr.get(mid)*mult < target*mult: lo = mid + 1
                else: hi = mid 
            return -1 
        
        lo, hi = 0, mountain_arr.length()
        while lo < hi: 
            mid = lo + hi >> 1
            if mid and mountain_arr.get(mid-1) < mountain_arr.get(mid): lo = mid + 1
            else: hi = mid 
        if (x := fn(0, lo, 1)) != -1: return x 
        if (x := fn(lo, mountain_arr.length(), -1)) != -1: return x 
        return -1",ye15
1096,https://leetcode.com/problems/brace-expansion-ii/discuss/322002/Python3-Concise-iterative-solution-using-stack,"class Solution:
    def braceExpansionII(self, expression: str) -> List[str]:
        stack,res,cur=[],[],[]
        for i in range(len(expression)):
            v=expression[i]
            if v.isalpha():
                cur=[c+v for c in cur or ['']]
            elif v=='{':
                stack.append(res)
                stack.append(cur)
                res,cur=[],[]
            elif v=='}':
                pre=stack.pop()
                preRes=stack.pop()
                cur=[p+c for c in res+cur for p in pre or ['']]
                res=preRes
            elif v==',':
                res+=cur
                cur=[]
        return sorted(set(res+cur))",yuanzhi247012
1103,https://leetcode.com/problems/distribute-candies-to-people/discuss/797848/Solution-or-Python,"class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        # create an array of size num_people and initialize it with 0
        list_people = [0] * num_people
        
        # starting value
        index = 1
        
        # iterate until the number of candies are more than 0
        while candies > 0:
            
            # if candies are more than index value, add the index value to the location 
            if candies > index:
                # we are using mod operation by the num_people to locate the index of the array
                # we are subtracting by 1 because the array index starts at 0
                list_people[(index - 1) % num_people] += index
            else:
                # if candies are less than index value, add all remaining candies to location
                list_people[(index - 1) % num_people] += candies
            
            # subtract the candies with index values
            candies -= index
            
            # increment the index values
            index += 1
        
        # return the resultant array
        return(list_people)",rushirg
1104,https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/discuss/323382/Python-3-easy-explained,"class Solution:
    
    def pathInZigZagTree(self, label: int) -> List[int]:
        rows = [(1, 0)] #row represented by tuple (min_element_in_row, is_neg_order)
        while rows[-1][0]*2 <= label:
            rows.append((rows[-1][0]*2, 1 - rows[-1][1]))
            
        power, negOrder = rows.pop()
        
        res = []
        while label > 1:
            res.append(label)
                
            if negOrder:
                # adjust label position and find parent with division by 2
                # a, b - range of current row 
                a, b = power, power*2 -1
                label = (a + (b - label))//2
            else:
                # divide label by 2 and adjust parent position
                # a, b - range of previous row
                a, b = power//2, power - 1
                label = b - (label//2 - a)
                
            power, negOrder = rows.pop()
            
                          
        res.append(1)
                          
        return res[::-1]",vilchinsky
1105,https://leetcode.com/problems/filling-bookcase-shelves/discuss/1517001/Python-3-or-DP-or-Explanation,"class Solution:
    def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:
        n = len(books)
        dp = [sys.maxsize] * n
        dp[0] = books[0][1]                                # first book will always on it's own row
        for i in range(1, n):                              # for each book
            cur_w, height_max = books[i][0], books[i][1]
            dp[i] = dp[i-1] + height_max                   # initialize result for current book `dp[i]`
            for j in range(i-1, -1, -1):                   # for each previou `book[j]`, verify if it can be placed in the same row as `book[i]`
                if cur_w + books[j][0] > shelfWidth: break
                cur_w += books[j][0]
                height_max = max(height_max, books[j][1])  # update current max height
                dp[i] = min(dp[i], (dp[j-1] + height_max) if j-1 >= 0 else height_max) # always take the maximum heigh on current row
        return dp[n-1]",idontknoooo
1106,https://leetcode.com/problems/parsing-a-boolean-expression/discuss/1582694/One-pass-with-stack-97-speed,"class Solution:
    operands = {""!"", ""&amp;"", ""|"", ""t"", ""f""}
    values = {""t"", ""f""}

    def parseBoolExpr(self, expression: str) -> bool:
        stack = []
        for c in expression:
            if c == "")"":
                val = stack.pop()
                args = set()
                while val in Solution.values:
                    args.add(val)
                    val = stack.pop()
                if val == ""!"":
                    stack.append(""f"" if ""t"" in args else ""t"")
                elif val == ""&amp;"":
                    stack.append(""f"" if ""f"" in args else ""t"")
                elif val == ""|"":
                    stack.append(""t"" if ""t"" in args else ""f"")
            elif c in Solution.operands:
                stack.append(c)
        return stack[0] == ""t""",EvgenySH
1108,https://leetcode.com/problems/defanging-an-ip-address/discuss/1697285/Python-code%3A-Defanging-an-IP-Address,"class Solution:
    def defangIPaddr(self, address: str) -> str:
        address=address.replace(""."",""[.]"")
        return address",Anilchouhan181
1111,https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/2825324/Python-oror-98.06-Faster-oror-Greedy-Approach-oror-O(N)-Solution,"class Solution:
    def maxDepthAfterSplit(self, seq: str) -> List[int]:
        ans=[]
        prev=1
        for i in seq:
            if i=='(':
                if prev==0:
                    ans.append(1)
                else:
                    ans.append(0)
            else:
                ans.append(prev)
            if prev==0:
                prev=1
            else:
                prev=0
        return ans",DareDevil_007
1122,https://leetcode.com/problems/relative-sort-array/discuss/343445/Python3.-Actually-easy-to-understand.-Beats-75-on-speed-and-100-on-memory,"class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
		# initialise a dictionary since we're going to want to count the occurences of each element in arr1
        dic = {}
		# this loop populates the dictionary with the number of occurences for each element
        for elem in arr1:
            if dic.get(elem) is None:
                dic[elem] = 1
            else:
                dic[elem] = dic[elem] + 1
		# initialise a new list to store the values which exist in both arr2 and arr1
        output = []
		# populate output with the elements multiplied by their occurences (e.g. [1]*2 = [1, 1])
        for elem in arr2:
            output += [elem]*dic[elem]
		# initialise a new list to store the elements which are in arr1 but not arr2
        extra_output = []
		# populate extra_output with these elements multiplied by their occurences. 
		# Note: set(arr1)-set(arr2) provides us with the set of numbers which exist in arr1 but not in arr2
        for elem in set(arr1)-set(arr2):
            extra_output += [elem]*dic[elem]
		# return the first list and the sorted second list
        return output + sorted(extra_output)",softbabywipes
1123,https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/discuss/1760394/Python-easy-to-understand-and-read-or-DFS,"class Solution:
    def ht(self, node):
        if not node:
            return 0
        return max(self.ht(node.left), self.ht(node.right)) + 1
    
    def dfs(self, node):
        if not node:
            return None
        left, right = self.ht(node.left), self.ht(node.right)
        if left == right:
            return node
        if left > right:
            return self.dfs(node.left)
        if left < right:
            return self.dfs(node.right)

    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        return self.dfs(root)",sanial2001
1124,https://leetcode.com/problems/longest-well-performing-interval/discuss/1495771/For-Beginners-oror-Well-Explained-oror-97-faster-oror-Easy-to-understand,"class Solution:
def longestWPI(self, hours: List[int]) -> int:
    
    dic = defaultdict(int)
    dummy = [1 if hours[0]>8 else -1]
    for h in hours[1:]:
        c = 1 if h>8 else -1
        dummy.append(dummy[-1]+c)
    
    res = 0
    for i in range(len(dummy)):
        if dummy[i]>0:
            res = max(res,i+1)
        else:
            if dummy[i]-1 in dic:
                res = max(res,i-dic[dummy[i]-1])
            if dummy[i] not in dic:
                dic[dummy[i]] = i
    
    return res",abhi9Rai
1125,https://leetcode.com/problems/smallest-sufficient-team/discuss/334630/Python-Optimized-backtracking-with-explanation-and-code-comments-88-ms,"class Solution:
    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        
        # Firstly, convert all the sublists in people into sets for easier processing.
        for i, skills in enumerate(people):
            people[i] = set(skills)
        
        # Remove all skill sets that are subset of another skillset, by replacing the subset with an
        # empty set. We do this rather than completely removing, so that indexes aren't 
        # disrupted (which is a pain to have to sort out later).
        for i, i_skills in enumerate(people):
            for j, j_skills in enumerate(people):
                if i != j and i_skills.issubset(j_skills):
                    people[i] = set()
        
        # Now build up a dictionary of skills to the people who can perform them. The backtracking algorithm
        # will use this.
        skills_to_people = collections.defaultdict(set)
        for i, skills in enumerate(people):
            for skill in skills:
                skills_to_people[skill].add(i)
            people[i] = set(skills)
        
        # Keep track of some data used by the backtracking algorithm.
        self.unmet_skills = set(req_skills) # Backtracking will remove and readd skills here as needed.
        self.smallest_length = math.inf # Smallest team length so far.
        self.current_team = [] # Current team members.
        self.best_team = [] # Best team we've found, i,e, shortest team that covers skills/
        
		# Here is the backtracking algorithm.
        def meet_skill(skill=0):
			# Base case: All skills are met.
            if not self.unmet_skills:
				# If the current team is smaller than the previous we found, update it.
                if self.smallest_length > len(self.current_team):
                    self.smallest_length = len(self.current_team)
                    self.best_team = self.current_team[::] # In Python, this makes a copy of a list.
                return # So that we don't carry out the rest of the algorithm.
                        
            # If this skill is already met, move onto the next one.
            if req_skills[skill] not in self.unmet_skills:
                return meet_skill(skill + 1)
				# Note return is just to stop rest of code here running. Return values
				# are not caught and used.
            
            # Otherwise, consider all who could meet the current skill.
            for i in skills_to_people[req_skills[skill]]:
                
				# Add this person onto the team by updating the backtrading data.
                skills_added_by_person = people[i].intersection(self.unmet_skills)
                self.unmet_skills = self.unmet_skills - skills_added_by_person
                self.current_team.append(i)
                
				# Do the recursive call to further build the team.
                meet_skill(skill + 1)
                
                # Backtrack by removing the person from the team again.
                self.current_team.pop()
                self.unmet_skills = self.unmet_skills.union(skills_added_by_person)
        
		# Kick off the algorithm.
        meet_skill()        
        return self.best_team",Hai_dee
1128,https://leetcode.com/problems/number-of-equivalent-domino-pairs/discuss/405437/Python3-Concise-and-Efficient,"class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        m = collections.defaultdict(int)
        ans = 0
        for a, b in dominoes:
            if a > b: a, b = b, a
            v = 10*a + b
            if v in m:
                ans += m[v]
            m[v] += 1
        return ans",luojl
1129,https://leetcode.com/problems/shortest-path-with-alternating-colors/discuss/712063/Python-DFS,"class Solution:
    def shortestAlternatingPaths(self, n, red_edges, blue_edges):
        neighbors = [[[], []] for _ in range(n)]
        ans = [[0, 0]]+[[2*n, 2*n] for _ in range(n-1)]
        for u, v in red_edges: neighbors[u][0].append(v)
        for u, v in blue_edges: neighbors[u][1].append(v)
        
        def dfs(u, c, dist):
            for v in neighbors[u][c]:
                if dist+1<ans[v][c]:
                    ans[v][c] = dist+1
                    dfs(v, 1-c, dist+1)
                    
        dfs(0, 0, 0)
        dfs(0, 1, 0)
        return [x if x<2*n else -1 for x in map(min, ans)]",stuxen
1130,https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/1510611/Greedy-Approach-oror-97-faster-oror-Well-Explained,"class Solution:
def mctFromLeafValues(self, arr: List[int]) -> int:
    
    arr = [float('inf')] + arr + [float('inf')]
    n, res = len(arr), 0
    
    while n>3:
        mi = min(arr)
        ind = arr.index(mi)
        
        if arr[ind-1]<arr[ind+1]:
            res+=arr[ind-1]*arr[ind]
        else:
            res+=arr[ind+1]*arr[ind]
        
        arr.remove(mi)
        n = len(arr)
    
    return res",abhi9Rai
1131,https://leetcode.com/problems/maximum-of-absolute-value-expression/discuss/1835078/Python-3-or-O(n)O(1),"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        minA = minB = minC = minD = math.inf
        maxA = maxB = maxC = maxD = -math.inf

        for i, (num1, num2) in enumerate(zip(arr1, arr2)):
            minA = min(minA, i + num1 + num2)
            maxA = max(maxA, i + num1 + num2)
            minB = min(minB, i + num1 - num2)
            maxB = max(maxB, i + num1 - num2)
            minC = min(minC, i - num1 + num2)
            maxC = max(maxC, i - num1 + num2)
            minD = min(minD, i - num1 - num2)
            maxD = max(maxD, i - num1 - num2)
        
        return max(maxA - minA, maxB - minB,
                   maxC - minC, maxD - minD)",dereky4
1137,https://leetcode.com/problems/n-th-tribonacci-number/discuss/350547/Solution-in-Python-3-(beats-~100),"class Solution:
    def tribonacci(self, n: int) -> int:
    	a, b, c = 0, 1, 1
    	for i in range(n): a, b, c = b, c, a + b + c
    	return a
		
		
- Junaid Mansuri",junaidmansuri
1138,https://leetcode.com/problems/alphabet-board-path/discuss/837601/Python-3-or-Straight-forward-solution-or-Explanations,"class Solution:
    def __init__(self):
        board = [""abcde"", ""fghij"", ""klmno"", ""pqrst"", ""uvwxy"", ""z""]
        self.d = {c:(i, j) for i, row in enumerate(board) for j, c in enumerate(row)}
                
    def alphabetBoardPath(self, target: str) -> str:
        ans, prev = '', (0, 0)
        for c in target:
            cur = self.d[c]
            delta_x, delta_y = cur[0]-prev[0], cur[1]-prev[1]
            h = 'R'*delta_y if delta_y > 0 else 'L'*(-delta_y)                    
            v = 'D'*delta_x if delta_x > 0 else 'U'*(-delta_x)                    
            ans += (h+v if cur == (5,0) else v+h) + '!'
            prev = cur
        return ans",idontknoooo
1139,https://leetcode.com/problems/largest-1-bordered-square/discuss/1435087/Python-3-or-Prefix-sum-DP-O(N3)-or-Explanation,"class Solution:
    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[(0, 0)] * (n) for _ in range((m))] 
        for i in range(m):                      # calculate prefix-sum as `hint` section suggested
            for j in range(n):
                if not grid[i][j]:
                    continue
                dp[i][j] = (dp[i][j][0] + dp[i-1][j][0] + 1, dp[i][j][1] + dp[i][j-1][1] + 1)
        for win in range(min(m, n)-1, -1, -1):  # for each window size
            for i in range(m-win):              # for each x-axis
                for j in range(n-win):          # for each y-axis
                    if not grid[i][j]: continue # determine whether square of (i, j), (i+win, j+win) is 1-boarded
                    x1, y1 = dp[i+win][j+win]   # bottom-right corner
                    x2, y2 = dp[i][j+win]       # upper-right corner
                    x3, y3 = dp[i+win][j]       # bottom-left corner
                    x4, y4 = dp[i][j]           # upper-left corner
                    if y1 - y3 == x1 - x2 == y2 - y4 == x3 - x4 == win:
                        return (win+1) * (win+1)
        return 0",idontknoooo
1140,https://leetcode.com/problems/stone-game-ii/discuss/793881/python-DP-Thought-process-explained,"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        suffix_sum = self._suffix_sum(piles)

        @lru_cache(None)
        def dfs(pile: int, M: int, turn: bool) -> Tuple[int, int]:
            # turn: true - alex, false - lee
            sum_alex, sum_lee = suffix_sum[pile], suffix_sum[pile]

            for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):
                sum_alex_next, sum_lee_next = dfs(
                    next_pile, max(M, next_pile - pile), not turn
                )
                range_sum = suffix_sum[pile] - suffix_sum[next_pile]

                if turn:
                    if sum_lee_next < sum_lee:
                        sum_alex = sum_alex_next + range_sum
                        sum_lee = sum_lee_next
                else:
                    if sum_alex_next < sum_alex:
                        sum_alex = sum_alex_next
                        sum_lee = sum_lee_next + range_sum

            return sum_alex, sum_lee

        return dfs(0, 1, True)[0]",omgitspavel
1143,https://leetcode.com/problems/longest-common-subsequence/discuss/2331817/Python3-or-Java-or-C%2B%2B-or-DP-or-O(nm)-or-BottomUp-(Tabulation),"class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        
        dp = []
        
        # Fill the matrix
        for _ in range(len(text1)+1):
            row = []
            for _ in range(len(text2)+1):
                row.append(0)
            
            dp.append(row)
        
        
        longest_length = 0
        
        # Start looping throught the text1 and text2
        for i in range(1, len(text1)+1):
            for j in range(1, len(text2)+1):
                
                # If characters match
				# fill the current cell by adding one to the diagonal value
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    # If characters do not match
					# Fill the cell with max value of previous row and column
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                
                # Keep track of the MAXIMUM value in the matrix
                longest_length = max(longest_length, dp[i][j])
        
        return longest_length",khaydaraliev99
1144,https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/discuss/891850/Python-3-or-Greedy-Two-pass-or-Explanation,"class Solution:
    def movesToMakeZigzag(self, nums: List[int]) -> int:
        def greedy(nums, small_first=True):
            if n <= 1: return 0
            ans = 0
            for i in range(n-1):
                if small_first and nums[i] >= nums[i+1]:
                    ans += nums[i] - (nums[i+1]-1)
                    nums[i] = nums[i+1] - 1
                elif not small_first and nums[i] <= nums[i+1]:
                    ans += nums[i+1] - (nums[i]-1)
                    nums[i+1] = nums[i] - 1
                small_first = not small_first
            return ans    
        n = len(nums)
        return min(greedy(nums[:], True), greedy(nums[:], False))",idontknoooo
1145,https://leetcode.com/problems/binary-tree-coloring-game/discuss/797574/Python-3-or-DFS-or-One-pass-and-Three-pass-or-Explanation,"class Solution:
    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:
        first = None
        def count(node):
            nonlocal first
            total = 0
            if node: 
                if node.val == x: first = node
                total += count(node.left) + count(node.right) + 1
            return total
        
        s = count(root) # Get total number of nodes, and x node (first player's choice)
        l = count(first.left) # Number of nodes on left branch 
        r = count(first.right) # Number of nodes on right branch 
        p = s-l-r-1 # Number of nodes on parent branch (anything else other than node, left subtree of node or right subtree of node)
        return l+r < p or l+p < r or r+p < l",idontknoooo
1147,https://leetcode.com/problems/longest-chunked-palindrome-decomposition/discuss/350711/Close-to-O(n)-Python-Rabin-Karp-Algorithm-with-two-pointer-technique-with-explanation-(~40ms),"class Solution:
    def longestDecomposition(self, text: str) -> int:
        
		# Used a prime number generator on the internet to grab a prime number to use.
        magic_prime = 32416189573
        
		# Standard 2 pointer technique variables.
        low = 0
        high = len(text) - 1
        
		# These are the hash tracking variables.
		cur_low_hash = 0
        cur_high_hash = 0
        cur_hash_length = 0
        
		# This is the number of parts we've found, i.e. the k value we need to return.
		k = 0
        
        while low < high:
            
			# To put the current letter onto our low hash (i.e. the one that goes forward from
			# the start of the string, we shift up the existing hash by multiplying by the base
			# of 26, and then adding on the new character by converting it to a number from 0 - 25.
            cur_low_hash *= 26 # Shift up by the base of 26.
            cur_low_hash += ord(text[low]) - 97 # Take away 97 so that it's between 0 and 25.
            
			
			# The high one, i.e. the one backwards from the end is a little more complex, as we want the 
			# hash to represent the characters in forward order, not backwards. If we did the exact same
			# thing we did for low, the string abc would be represented as cba, which is not right.	
			
			# Start by getting the character's 0 - 25 number.
			high_char = ord(text[high]) - 97
			
			# The third argument to pow is modular arithmetic. It says to give the answer modulo the
			# magic prime (more on that below). Just pretend it isn't doing that for now if it confuses you. 
            # What we're doing is making an int that puts the high character at the top, and then the 
			# existing hash at the bottom.
			cur_high_hash = (high_char * pow(26, cur_hash_length, magic_prime)) + cur_high_hash            
            
			# Mathematically, we can safely do this. Impressive, huh? I'm not going to go into here, but
			# I recommend studying up on modular arithmetic if you're confused.
			# The algorithm would be correct without doing this, BUT it'd be very slow as the numbers could
			# become tens of thousands of bits long. The problem with that of course is that comparing the
			# numbers would no longer be O(1) constant. So we need to keep them small.
			cur_low_hash %= magic_prime 
            cur_high_hash %= magic_prime
            
			# And now some standard 2 pointer technique stuff.
            low += 1
            high -= 1
            cur_hash_length += 1
            
			# This piece of code checks if we currently have a match.
            # This is actually probabilistic, i.e. it is possible to get false positives.
            # For correctness, we should be verifying that this is actually correct.
            # We would do this by ensuring the characters in each hash (using
			# the low, high, and length variables we've been tracking) are
			# actually the same. But here I didn't bother as I figured Leetcode
			# would not have a test case that broke my specific prime.
			if cur_low_hash == cur_high_hash:
                k += 2 # We have just added 2 new strings to k.
                # And reset our hashing variables.
				cur_low_hash = 0
                cur_high_hash = 0
                cur_hash_length = 0
        
		# At the end, there are a couple of edge cases we need to address....
		# The first is if there is a middle character left.
		# The second is a non-paired off string in the middle.
        if (cur_hash_length == 0 and low == high) or cur_hash_length > 0:
            k += 1
        
        return k",Hai_dee
1154,https://leetcode.com/problems/day-of-the-year/discuss/449866/Python-3-Four-liner-Simple-Solution,"class Solution:
    def dayOfYear(self, date: str) -> int:
        y, m, d = map(int, date.split('-'))
        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        if (y % 400) == 0 or ((y % 4 == 0) and (y % 100 != 0)): days[1] = 29
        return d + sum(days[:m-1])",mmbhatk
1155,https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/discuss/822515/Python-3-or-DP-or-Explanation,"class Solution:
    def numRollsToTarget(self, d: int, f: int, target: int) -> int:
        if d*f < target: return 0        # Handle special case, it speed things up, but not necessary
        elif d*f == target: return 1     # Handle special case, it speed things up, but not necessary
        mod = int(10**9 + 7)
        dp = [[0] * (target+1) for _ in range(d+1)] 
        for j in range(1, min(f+1, target+1)): dp[1][j] = 1
        for i in range(2, d+1):
            for j in range(1, target+1):
                for k in range(1, f+1):
                    if j - k >= 0: dp[i][j] += dp[i-1][j-k]
                dp[i][j] %= mod        
        return dp[-1][-1]",idontknoooo
1156,https://leetcode.com/problems/swap-for-longest-repeated-character-substring/discuss/2255000/PYTHON-or-AS-INTERVIEWER-WANTS-or-WITHOUT-ITERTOOLS-or-WELL-EXPLAINED-or,"class Solution:
    def maxRepOpt1(self, text: str) -> int:
        first_occurence,last_occurence = {},{}
        ans,prev,count = 1,0,0
        n = len(text)
        
        for i in range(n):
            if text[i] not in first_occurence: first_occurence[text[i]] = i
            last_occurence[text[i]] = i
            
        for i in range(n+1):
            if i < n and text[i] == text[prev]:
                count += 1
            else:
                if first_occurence[text[prev]] < prev or last_occurence[text[prev]] > i : count += 1
                ans = max(ans,count)
                count = 1
                prev = i
        
        def someWork(item,before,after):
            count = 0
            while before >= 0 and text[before] == item: 
                count += 1
                before -= 1
            while after < n and text[after] == item:
                count += 1
                after += 1
            if first_occurence[item] <= before or last_occurence[item] >= after:count+=1
            return count
        
        for i in range(1,n-1):
            ans = max(ans,someWork(text[i+1],i-1,i+1))
        return ans",reaper_27
1160,https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/discuss/2177578/Python3-O(n2)-oror-O(1)-Runtime%3A-96ms-97.20-Memory%3A-14.5mb-84.92,"class Solution:
#     O(n^2) || O(1)
# Runtime: 96ms 97.20% Memory: 14.5mb 84.92%
    def countCharacters(self, words: List[str], chars: str) -> int:
        ans=0
        for word in words:
            for ch in word:
                if word.count(ch)>chars.count(ch):
                    break
            else:
                ans+=len(word)
        
        return ans",arshergon
1161,https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/discuss/848959/BFS-Python-solution-with-comments!,"class Solution:
    def maxLevelSum(self, root: TreeNode) -> int:
        
        queue = deque() #init a queue for storing nodes as we traverse the tree
        queue.append(root) #first node (level = 1) inserted
        
        #bfs = []  #just for understanding- this will be a bfs list to store nodes as we conduct the search, but we don't need it here.
        
        level_sum = 0 # for sum of each level
        level_nodes = 1 # for knowing when a particular level has ended
        
        sum_of_levels = [] #list to store all levels sum of nodes
        
        while queue: #begin BFS
            node = queue.popleft() 
            #bfs.append(node)
            level_sum += node.val #add node 
            
            if node.left:
                queue.append(node.left)
            
            if node.right:
                queue.append(node.right)
            
            level_nodes -= 1   #reduce level number by 1, as we popped out a node
            if level_nodes == 0: # if 0, then a level has ended, so calculate the sum
                sum_of_levels.append(level_sum)
                level_sum = 0
                level_nodes = len(queue)
        
        return sum_of_levels.index(max(sum_of_levels)) + 1  #return index of max level sum",tintsTy
1162,https://leetcode.com/problems/as-far-from-land-as-possible/discuss/1158339/A-general-Explanation-w-Animation,"class Solution:
    def maxDistance(self, grid: List[List[int]]) -> int:
        
		# The # of rows and # of cols
        M, N, result = len(grid), len(grid[0]), -1
        
		# A list of valid points
        valid_points = {(i, j) for i in range(M) for j in range(N)}
        
		# A double-ended queue of ""land"" cells
        queue = collections.deque([(i, j) for i in range(M) for j in range(N) if grid[i][j] == 1])
        
        # Check if all land, or all water, an edge case
        if len(queue) == M*N or len(queue) == 0:
            return -1
        
		# BFS
        while queue:
			
			# One iteration here
            for _ in range(len(queue)):
                i, j = queue.popleft()
                for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                    if (x, y) not in valid_points: continue
                    if grid[x][y] == 1: continue 
                    queue.append((x, y))
                    grid[x][y] = 1 # We mark water cells as land to avoid visiting them again
                    
			# Increase the iteration/result count
            result += 1
            
        return result",dev-josh
1163,https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/361321/Solution-in-Python-3-(beats-100),"class Solution:
    def lastSubstring(self, s: str) -> str:
    	S, L, a = [ord(i) for i in s] + [0], len(s), 1
    	M = max(S)
    	I = [i for i in range(L) if S[i] == M]
    	if len(I) == L: return s
    	while len(I) != 1:
    		b = [S[i + a] for i in I]
    		M, a = max(b), a + 1
    		I = [I[i] for i, j in enumerate(b) if j == M]
    	return s[I[0]:]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
1169,https://leetcode.com/problems/invalid-transactions/discuss/670649/Simple-clean-python-only-10-lines,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        
        for i, t1 in enumerate(transactions):
            name1, time1, amount1, city1 = t1.split(',')
            if int(amount1) > 1000:
                invalid.append(t1)
                continue
            for j, t2 in enumerate(transactions):
                if i != j: 
                    name2, time2, amount2, city2 = t2.split(',')
                    if name1 == name2 and city1 != city2 and abs(int(time1) - int(time2)) <= 60:
                        invalid.append(t1)
                        break
        
        return invalid",auwdish
1170,https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/discuss/401039/Python-Simple-Code-Memory-efficient,"class Solution:
	def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
		def f(s):
			t = sorted(list(s))[0]
			return s.count(t)
		query = [f(x) for x in queries]
		word = [f(x) for x in words]
		m = []
		for x in query:
			count = 0
			for y in word:
				if y>x:
					count+=1
			m.append(count)
		return m",saffi
1171,https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/1701518/Easiest-Approach-oror-Clean-and-Concise-oror-Well-Explained,"class Solution:
	def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:

		dummy = ListNode(0,head)
		pre = 0
		dic = {0: dummy}

		while head:
			pre+=head.val
			dic[pre] = head
			head = head.next

		head = dummy
		pre = 0
		while head:
			pre+=head.val
			head.next = dic[pre].next
			head = head.next

		return dummy.next",abhi9Rai
1175,https://leetcode.com/problems/prime-arrangements/discuss/2794041/Find-product-between-factorial-of-primes-and-non-primes,"class Solution:
    def numPrimeArrangements(self, n: int) -> int:
        # find number of prime indices
        # ways to arrange prime indices
        # is prime indices factorial
        # amount of non-prime indices is
        # n - prime indices 
        # the factorial of non - prime indices
        # times the factorial of prime indices
        # is the amount of ways to arrange the 
        # prime numbers and i be valid 
        # use helper to find factorial of a number
        # use helper to see if a number is prime
        # time O(n ^ 2) space O(1)

        def isPrime(num):
            if num <= 1:
                return False
            for i in range(2, num // 2 + 1):
                if num % i == 0:
                    return False
            return True

        def factorial(num):
            res = 1
            for i in range(1, num + 1):
                res *= i
            return res
        
        primes = 0
        for num in range(1, n + 1):
            if isPrime(num):
                primes += 1
        return int(factorial(primes) * factorial(n - primes) % (10**9 + 7))",andrewnerdimo
1177,https://leetcode.com/problems/can-make-palindrome-from-substring/discuss/1201798/Python3-prefix-freq,"class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        prefix = [[0]*26]
        for c in s: 
            elem = prefix[-1].copy()
            elem[ord(c)-97] += 1
            prefix.append(elem)
        
        ans = []
        for left, right, k in queries: 
            cnt = sum(1&amp;(prefix[right+1][i] - prefix[left][i]) for i in range(26))
            ans.append(cnt <= 2*k+1)
        return ans",ye15
1178,https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/discuss/1567415/Python-TrieBitmasking-Solutions-with-Explanation,"class Solution:
    def mask(self, word: str) -> int:
        result = 0
        for ch in word:
            result |= 1 << (ord(ch)-ord('a'))
        return result

    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:
        word_count = Counter(self.mask(word) for word in words)
        result = []
        for puzzle in puzzles:
            original_mask, first = self.mask(puzzle[1:]), self.mask(puzzle[0])
            curr_mask, count = original_mask, word_count[first]
            while curr_mask:
                count += word_count[curr_mask|first]
                curr_mask = (curr_mask-1)&amp;original_mask
            result.append(count)
        return result",zayne-siew
1184,https://leetcode.com/problems/distance-between-bus-stops/discuss/377844/Python-Explanation,"class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        a, b = min(start, destination), max(start, destination)
        return min(sum(distance[a:b]), sum(distance) - sum(distance[a:b]))",nuclearoreo
1185,https://leetcode.com/problems/day-of-the-week/discuss/1084728/Python3-simple-solution,"class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        prev_year = year - 1
        days = prev_year * 365 + prev_year // 4 - prev_year // 100 + prev_year // 400
        days += sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:month - 1])
        days += day

        if month > 2 and ((year % 4 == 0 and year % 100 != 0) or year % 400 == 0):
            days += 1

        return ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][days % 7]",EklavyaJoshi
1186,https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/discuss/1104253/Python-Kadane's-Algorithm-easy-solution,"class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        n = len(arr)
        #maximum subarray starting from the last element i.e. backwards 
        prefix_sum_ending = [float('-inf')]*n
        #maximum subarray starting from the first element i.e forwards
        prefix_sum_starting = [float('-inf')]*n
        prefix_sum_ending[n-1] = arr[n-1]
        prefix_sum_starting[0] = arr[0]
        
        for i in range(1,n):
            prefix_sum_starting[i] = max(prefix_sum_starting[i-1]+arr[i], arr[i])
        for i in range(n-2,-1,-1):
            prefix_sum_ending[i] = max(prefix_sum_ending[i+1]+arr[i], arr[i])
           
        max_without_deletion = max(prefix_sum_starting)
        max_with_deletion = float('-inf')
        for i in range(1,n-1):
            max_with_deletion = max(max_with_deletion, prefix_sum_starting[i-1]+prefix_sum_ending[i+1])
            
        return max(max_without_deletion, max_with_deletion)",msd1311
1187,https://leetcode.com/problems/make-array-strictly-increasing/discuss/1155655/Python3-top-down-dp,"class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
        arr2.sort()
        
        @cache
        def fn(i, prev): 
            """"""Return min ops to make arr1[i:] increasing w/ given previous element.""""""
            if i == len(arr1): return 0 
            ans = inf 
            if (prev < arr1[i]): ans = fn(i+1, arr1[i])
            k = bisect_right(arr2, prev)
            if k < len(arr2): ans = min(ans, 1 + fn(i+1, arr2[k]))
            return ans 
        
        ans = fn(0, -inf)
        return ans if ans < inf else -1",ye15
1189,https://leetcode.com/problems/maximum-number-of-balloons/discuss/1013213/2-Line-Python-using-Counter,"class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        c = collections.Counter(text)
        return min(c['b'],c['a'],c['l']//2,c['o']//2,c['n'])",majinlion
1190,https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/2290806/PYTHON-SOL-or-RECURSION-AND-STACK-SOL-or-DETAILED-EXPLANATION-WITH-PICTRUE-or,"class Solution:
    def reverseParentheses(self, s: str) -> str:
        def solve(string):
            n = len(string)
            word = """"
            i = 0
            while i <n:
                if string[i] == '(':
                    new = """"
                    count = 0
                    while True:
                        count += 1 if string[i] == '(' else -1 if string[i] == ')' else 0
                        if count == 0: break
                        new += string[i]
                        i += 1
                    i += 1
                    word += solve(new[1:])
                else:
                    word += string[i]
                    i += 1
            return word[::-1]
        return solve(s)[::-1]",reaper_27
1191,https://leetcode.com/problems/k-concatenation-maximum-sum/discuss/2201976/Python-easy-to-read-and-understand-or-kadane,"class Solution:
    def kadane(self, nums):
        for i in range(1, len(nums)):
            if nums[i-1] > 0:
                nums[i] += nums[i-1]
        return max(max(nums), 0)
    
    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:
        sums = sum(arr)
        mod = 10**9 + 7
        if k == 1:
            return self.kadane(arr) % (mod)
        if sums > 0:
            return (self.kadane(arr+arr) + (k-2)*sums) % (mod)
        else:
            return self.kadane(arr+arr) % (mod)",sanial2001
1192,https://leetcode.com/problems/critical-connections-in-a-network/discuss/382440/Python-DFS-Tree-Solution-(O(V%2BE)-complexity),"class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        
        dic = collections.defaultdict(list)
        for c in connections:
            u, v = c
            dic[u].append(v)
            dic[v].append(u)
            
        
        timer = 0
        
        depth, lowest, parent, visited = [float(""inf"")]*n, [float(""inf"")]*n, [float(""inf"")]*n, [False]*n
        res = []
        
        def find(u):
            
            nonlocal timer
            
            visited[u] = True
            depth[u], lowest[u] = timer, timer
            timer += 1
            
            for v in dic[u]:   
                
                if not visited[v]:
                    parent[v] = u
                    find(v)
                    if lowest[v]>depth[u]:
                        res.append([u,v])
                
                if parent[u]!=v:
                    lowest[u] = min(lowest[u], lowest[v])
                
        find(0)
        return res",ywen1995
1200,https://leetcode.com/problems/minimum-absolute-difference/discuss/569795/Easy-to-Understand-or-Faster-or-Simple-or-Python-Solution,"class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()
        m = float('inf')
        out = []
        for i in range(1, len(arr)):
            prev = arr[i - 1]
            curr = abs(prev - arr[i])
            if curr < m:
                out = [[prev, arr[i]]]
                m = curr
            elif curr == m: out.append([prev, arr[i]])
        return out",Mrmagician
1201,https://leetcode.com/problems/ugly-number-iii/discuss/723589/Python3-inconsistent-definition-of-%22ugly-numbers%22,"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        # inclusion-exclusion principle
        ab = a*b//gcd(a, b)
        bc = b*c//gcd(b, c)
        ca = c*a//gcd(c, a)
        abc = ab*c//gcd(ab, c)
        
        lo, hi = 1, n*min(a, b, c)
        while lo < hi: 
            mid = lo + hi >> 1
            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1
            else: hi = mid 
        return lo",ye15
1202,https://leetcode.com/problems/smallest-string-with-swaps/discuss/1985185/Python3-UNION-FIND-()**-Explained,"class Solution:
    def union(self, a, b):
        self.parent[self.find(a)] = self.find(b)
		
    def find(self, a):
        if self.parent[a] != a:
            self.parent[a] = self.find(self.parent[a])

        return self.parent[a]
        
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
		# 1. Union-Find
        self.parent = list(range(len(s)))
        for a, b in pairs:
            self.union(a, b)

		# 2. Grouping
        group = defaultdict(lambda: ([], []))  
        for i, ch in enumerate(s):
            parent = self.find(i)
            group[parent][0].append(i)
            group[parent][1].append(ch)

		# 3. Sorting
        res = [''] * len(s)
        for ids, chars in group.values():
            ids.sort()
            chars.sort()
            for ch, i in zip(chars, ids):
                res[i] = ch
                
        return ''.join(res)",artod
1203,https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/discuss/1149266/Python3-topological-sort,"class Solution:
    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:
        for i in range(n): 
            if group[i] == -1: group[i] = i + m # re-group 
        
        graph0 = {} # digraph of groups 
        indeg0 = [0]*(m+n) # indegree of groups 
        
        graph1 = {} # digrpah of items 
        indeg1 = [0]*n # indegree of items
        
        for i, x in enumerate(beforeItems): 
            for xx in x: 
                if group[xx] != group[i]: 
                    graph0.setdefault(group[xx], []).append(group[i])
                    indeg0[group[i]] += 1
                graph1.setdefault(xx, []).append(i)
                indeg1[i] += 1
        
        def fn(graph, indeg): 
            """"""Return topological sort of graph using Kahn's algo.""""""
            ans = []
            stack = [k for k in range(len(indeg)) if indeg[k] == 0]
            while stack: 
                n = stack.pop()
                ans.append(n)
                for nn in graph.get(n, []):
                    indeg[nn] -= 1
                    if indeg[nn] == 0: stack.append(nn)
            return ans 
        
        tp0 = fn(graph0, indeg0) 
        if len(tp0) != len(indeg0): return [] 
        
        tp1 = fn(graph1, indeg1)
        if len(tp1) != len(indeg1): return []
        
        mp0 = {x: i for i, x in enumerate(tp0)}
        mp1 = {x: i for i, x in enumerate(tp1)}
        
        return sorted(range(n), key=lambda x: (mp0[group[x]], mp1[x]))",ye15
1207,https://leetcode.com/problems/unique-number-of-occurrences/discuss/393086/Solution-in-Python-3-(one-line)-(beats-100.00-),"class Solution:
    def uniqueOccurrences(self, A: List[int]) -> bool:
    	return (lambda x: len(x) == len(set(x)))(collections.Counter(A).values())
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",junaidmansuri
1208,https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/2312556/PYTHON-or-SLIDING-WINDOW-or-O(n)-or-WELL-EXPLAINED-or-EASY-or,"class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        n = len(s)
        cost,start,ans = 0,0,0
        for i in range(n):
            diff = abs(ord(s[i]) - ord(t[i]))
            if cost + diff <= maxCost:
                # we can increase our sliding window
                cost += diff
            else:
                # we are unable to increase our sliding window
                ans = max(ans,i - start)
                while True:
                    cost -= abs(ord(s[start]) - ord(t[start]))
                    start += 1
                    if cost + diff <= maxCost: break
                if cost + diff > maxCost: start = i + 1
                else: cost += diff
                    
        ans = max(ans,n - start)
        return ans",reaper_27
1209,https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/discuss/2012318/Python-Simple-One-Pass-Solution,"class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:        
        stck = [['$', 0]]     # a placeholder to mark stack is empty. This eliminates the need to do an empty check later
        
        for c in s:
            if stck[-1][0] == c:
                stck[-1][1]+=1 # update occurences count of top element if it matches current character
                if stck[-1][1] == k:
                    stck.pop()
            else:
                stck.append([c, 1])            
        
        return ''.join(c * cnt for c, cnt in stck)",constantine786
1210,https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/393042/Python-3-(BFS-DFS-and-DP)-(With-Explanation)-(beats-100.00),"class Solution:
    def minimumMoves(self, G: List[List[int]]) -> int:
    	N, S, T, V, c = len(G), [(0, 0, 'h')], [], set(), 0
    	while S:
    		for i in S:
    			if i in V: continue
    			if i == (N-1, N-2, 'h'): return c
    			(a, b, o), _ = i, V.add(i)
	    		if o == 'h':
    				if b + 2 != N and G[a][b+2] == 0: T.append((a, b+1, o))
    				if a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: T.append((a+1, b, o)), T.append((a, b, 'v'))
    			elif o == 'v':
    				if a + 2 != N and G[a+2][b] == 0: T.append((a+1, b, o))
    				if b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: T.append((a, b+1, o)), T.append((a, b, 'h'))
    		S, T, c = T, [], c + 1
    	return -1",junaidmansuri
1217,https://leetcode.com/problems/minimum-cost-to-move-chips-to-the-same-position/discuss/1510460/Greedy-Approach-oror-Well-Explained-oror-Easy-to-understand,"class Solution:
def minCostToMoveChips(self, position: List[int]) -> int:
    
    dic = Counter([n%2 for n in position])
    return min(dic[0],dic[1])",abhi9Rai
1218,https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/discuss/1605339/Python3-dp-and-hash-table-easy-to-understand,"class Solution:
    def longestSubsequence(self, arr: List[int], difference: int) -> int:
        """"""
        dp is a hashtable, dp[x] is the longest subsequence ending with number x
        """"""
        dp = {}
        for x in arr:
            if x - difference in dp:
                dp[x] = dp[x-difference] + 1
            else:
                dp[x] = 1
            
        return max(dp.values())",nick19981122
1219,https://leetcode.com/problems/path-with-maximum-gold/discuss/1742414/very-easy-to-understand-using-backtracking-python3,"class Solution:
	def getMaximumGold(self, grid: List[List[int]]) -> int:
		m = len(grid)
		n = len(grid[0])
		def solve(i,j,grid,vis,val):
			# print(i,j,grid,vis,val)
			if(i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or vis[i][j]):
				# print(i,m,j,n)
				return val
			vis[i][j] = True
			a = solve(i,j-1,grid,vis,val+grid[i][j])
			b = solve(i,j+1,grid,vis,val+grid[i][j])
			c = solve(i+1,j,grid,vis,val+grid[i][j])
			d = solve(i-1,j,grid,vis,val+grid[i][j])
			vis[i][j] = False
			return max(a,b,c,d)
		ma = 0
		for i in range(len(grid)):
			for j in range(len(grid[0])):
				if(grid[i][j] != 0):
					vis = [[False for i in range(len(grid[0]))] for j in range(len(grid))]
					ma = max(ma,solve(i,j,grid,vis,0))
		return ma",jagdishpawar8105
1220,https://leetcode.com/problems/count-vowels-permutation/discuss/398231/Dynamic-programming-in-Python-with-in-depth-explanation-and-diagrams,"class Solution:
    def countVowelPermutation(self, n: int) -> int:
        dp_array = [[0] * 5 for _ in range(n + 1)]
        dp_array[1] = [1, 1, 1, 1, 1]
        for i in range(2, n + 1):
            # a is allowed to follow e, i, or u.
            dp_array[i][0] = dp_array[i - 1][1] + dp_array[i - 1][2] + dp_array[i - 1][4]
            # e is allowed to follow a or i.
            dp_array[i][1] = dp_array[i - 1][0] +  dp_array[i - 1][2]
            # i is allowed to follow e or o.
            dp_array[i][2] = dp_array[i - 1][1] + dp_array[i - 1][3]
            # o is allowed to follow i
            dp_array[i][3] = dp_array[i - 1][2]
            # u is allowed to follow i or o.
            dp_array[i][4] = dp_array[i - 1][2] + dp_array[i - 1][3]
        return sum(dp_array[n]) % ((10 ** 9) + 7)",Hai_dee
1221,https://leetcode.com/problems/split-a-string-in-balanced-strings/discuss/403688/Python-3-(three-lines)-(beats-100.00-),"class Solution:
    def balancedStringSplit(self, S: str) -> int:
        m = c = 0
        for s in S:
            if s == 'L': c += 1
            if s == 'R': c -= 1
            if c == 0: m += 1
        return m",junaidmansuri
1222,https://leetcode.com/problems/queens-that-can-attack-the-king/discuss/790679/Simple-Python-Solution,"class Solution:
    # Time: O(1)
    # Space: O(1)
    def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:
        queen_set = {(i, j) for i, j in queens}
        res = []
        
        for dx, dy in [[0, 1], [1, 0], [-1, 0], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]]:
            x, y = king[0], king[1]
            while 0 <= x < 8 and 0 <= y < 8:
                x += dx
                y += dy
                if (x, y) in queen_set:
                    res.append([x, y])
                    break
        return res",whissely
1223,https://leetcode.com/problems/dice-roll-simulation/discuss/1505338/Python-or-Intuitive-or-Recursion-%2B-Memo-or-Explanation,"class Solution:
    def dieSimulator(self, n: int, rollMax: List[int]) -> int:
        MOD = 10 ** 9 + 7
        
        @lru_cache(None)
        def func(idx, prevNum, prevNumFreq):
            if idx == n:
                return 1
            
            ans = 0
            for i in range(1, 7):
                if i == prevNum:
                    if prevNumFreq < rollMax[i - 1]:
                        ans += func(idx + 1, i, prevNumFreq + 1)
                        
                else:
                    ans += func(idx + 1, i, 1)
            
            return ans % MOD
        
        return func(0, 0, 0)",detective_dp
1224,https://leetcode.com/problems/maximum-equal-frequency/discuss/2448664/Python-easy-to-read-and-understand-or-hash-table,"class Solution:
    def maxEqualFreq(self, nums: List[int]) -> int:
        cnt, freq, maxfreq, ans = collections.defaultdict(int), collections.defaultdict(int), 0, 0
        for i, num in enumerate(nums):
            cnt[num] = cnt.get(num, 0) + 1
            freq[cnt[num]] += 1
            freq[cnt[num]-1] -= 1
            maxfreq = max(maxfreq, cnt[num])
            if maxfreq == 1:
                ans = i+1
            elif maxfreq*freq[maxfreq] == i:
                ans = i+1
            elif (maxfreq-1)*(freq[maxfreq-1]+1) == i:
                ans = i+1
        return ans",sanial2001
1227,https://leetcode.com/problems/airplane-seat-assignment-probability/discuss/530102/Python3-symmetry,"class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        return 1 if n == 1 else 0.5",ye15
1232,https://leetcode.com/problems/check-if-it-is-a-straight-line/discuss/1247752/Python3-simple-solution,"class Solution:
    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
        x1, y1 = coordinates[0]
        x2, y2 = coordinates[1]
        for x, y in coordinates[2:]:
            if (y2 - y1) * (x - x1) != (x2 - x1) * (y - y1):
                return False
        return True",EklavyaJoshi
1233,https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/1196525/Python3-simple-solution-using-%22startswith%22-method,"class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        ans = []
        for i, path in enumerate(sorted(folder)):
            if i == 0 or not path.startswith(ans[-1] + ""/""):
                ans.append(path)
        return ans",EklavyaJoshi
1234,https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/884039/Python3-sliding-window-with-explanation,"class Solution:
    def balancedString(self, s: str) -> int:
        counter = collections.Counter(s)
        n = len(s) // 4
        extras = {}
        for key in counter:
            if counter[key] > n:
                extras[key] = counter[key] - n
        
        if not extras: return 0
        i = 0
        res = len(s)
        for j in range(len(s)):
            if s[j] in extras:
                extras[s[j]] -= 1
            
            while max(extras.values()) <= 0:
                res = min(res, j-i+1)
                if s[i] in extras:
                    extras[s[i]] += 1
                i += 1
                
                
        return res",hwsbjts
1237,https://leetcode.com/problems/find-positive-integer-solution-for-a-given-equation/discuss/933212/Python-3-greater-91.68-faster.-O(n)-time,"def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
	x, y = 1, z
	pairs = []
	
	while x<=z and y>0:
		cf = customfunction.f(x,y)
		if cf==z:
			pairs.append([x,y])
			x, y = x+1, y-1
		elif cf > z:
			y -= 1
		else:
			x += 1
	return pairs",mybuddy29
1238,https://leetcode.com/problems/circular-permutation-in-binary-representation/discuss/1092321/Python3-backtracking,"class Solution:
    def circularPermutation(self, n: int, start: int) -> List[int]:
        ans = []
        for i in range(1<<n): 
            ans.append(start ^ i ^ i >> 1)
        return ans",ye15
1239,https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/discuss/1478666/Two-Approach-oror-Well-Explained-oror-97-faster,"class Solution:
def maxLength(self,arr):
    
    unique = ['']
    res = 0
    for i in range(len(arr)):
        for j in range(len(unique)):
            local = arr[i]+unique[j]
            if len(local)==len(set(local)):
                unique.append(local)
                res=max(res,len(local))
    
    return res",abhi9Rai
1240,https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/1216988/Python3-backtracking,"class Solution:
    def tilingRectangle(self, n: int, m: int) -> int:
        if n == m: return 1
        depth = [0]*m
        
        def fn(x): 
            """"""Explore tiling rectangle area via backtracking.""""""
            nonlocal ans 
            if x < ans: 
                if min(depth) == n: ans = x # all tiled
                else: 
                    i = min(depth)
                    j = jj = depth.index(i) # (i, j)
                    while jj < m and depth[jj] == depth[j]: jj += 1
                    k = min(n - i, jj - j)
                    for kk in reversed(range(1, k+1)): 
                        for jj in range(j, j+kk): depth[jj] += kk
                        fn(x+1)
                        for jj in range(j, j+kk): depth[jj] -= kk
                            
        ans = max(n, m)
        fn(0)
        return ans",ye15
1247,https://leetcode.com/problems/minimum-swaps-to-make-strings-equal/discuss/1196255/Python3-solution-using-list-and-dictionary,"class Solution:
    def minimumSwap(self, s1: str, s2: str) -> int:
        if s1 == s2:
            return 0
        else:
            count = 0
            d = {('xx','yy'):1,('xy','yx'):2,('yy','xx'):1,('yx','xy'):2}
            x = []
            y = []
            for i,j in zip(s1,s2):
                if i != j:
                    x.append(i)
                    y.append(j)
            x.sort()
            y.sort(reverse=True)
            i,j = 0,0
            if len(x)%2 != 0 or len(y)%2 != 0:
                return -1
            while i < len(x) and j < len(y):
                z = (''.join(x[i:i+2]),''.join(y[i:i+2]))
                if z not in d:
                    return -1
                else:
                    count += d[z]
                i += 2
                j += 2
            return count",EklavyaJoshi
1248,https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/1265615/Python-Two-pointer,"class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        right ,left = 0,0
        ans = 0 
        odd_cnt = 0
        ans = 0
        cur_sub_cnt = 0
        for right in range(len(nums)):
            
            if nums[right]%2 == 1:
                odd_cnt += 1
                cur_sub_cnt = 0
                
            while odd_cnt == k:
                if nums[left]%2 == 1:
                    odd_cnt -= 1
                cur_sub_cnt += 1
                left += 1
                
            ans += cur_sub_cnt
            
        return ans",harshhx
1249,https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/discuss/503754/Python-Memory-Usage-Less-Than-100-Faster-than-100,"class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        
        open = 0
        s = list(s)
        
        for i, c in enumerate(s):
            if c == '(': open += 1
            elif c == ')':
                if not open: s[i] = """"
                else: open -= 1
        
        for i in range(len(s)-1, -1, -1):
            if not open: break
            if s[i] == '(': s[i] = """"; open -= 1
        
        return """".join(s)",mmbhatk
1250,https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/1489417/This-problem-is-about-chinese-remainder-theorem.,"class Solution:
    def isGoodArray(self, nums: List[int]) -> bool:
        import math 
        n = len(nums)
        if n ==1:
            return nums[0] ==1
        d = math.gcd(nums[0], nums[1])
        for i in range(n):
            d = math.gcd(nums[i], d)
        return d ==1",byuns9334
1252,https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/discuss/1682009/Optimal-O(m%2Bn)-space-or-O(m*n)-time-complexity-solution,"class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        row_data = [0]*m
        col_data = [0]*n
        
        for tup in indices:
            row_data[tup[0]] = row_data[tup[0]] + 1
            col_data[tup[1]] = col_data[tup[1]] + 1
        
        odd_count = 0 
        for rowp in range(m):
            for colp in range(n):
                val = row_data[rowp] + col_data[colp]
                if val % 2 != 0:
                    odd_count+=1
        
        return odd_count",snagsbybalin
1253,https://leetcode.com/problems/reconstruct-a-2-row-binary-matrix/discuss/845641/Python-3-or-Greedy-or-Explanations,"class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        s, n = sum(colsum), len(colsum)
        if upper + lower != s: return []
        u, d = [0] * n, [0] * n
        for i in range(n):
            if colsum[i] == 2 and upper > 0 and lower > 0:
                u[i] = d[i] = 1
                upper, lower = upper-1, lower-1
            elif colsum[i] == 1:    
                if upper > 0 and upper >= lower:
                    u[i], upper = 1, upper-1
                elif lower > 0 and lower > upper:
                    d[i], lower = 1, lower-1
                else: return []    
            elif not colsum[i]: continue
            else: return []
        return [u, d]",idontknoooo
1254,https://leetcode.com/problems/number-of-closed-islands/discuss/1250335/DFS-oror-Well-explained-oror-93-faster-oror,"class Solution:
def closedIsland(self, grid: List[List[int]]) -> int:
    
    def dfs(i,j):
        if grid[i][j]==1:
            return True
        if i<=0 or i>=m-1 or j<=0 or j>=n-1:
            return False
        grid[i][j]=1
        up=dfs(i-1,j)
        down=dfs(i+1,j)
        left=dfs(i,j-1)
        right=dfs(i,j+1)
        return left and right and up and down
     
    m,n = len(grid),len(grid[0])
    c=0
	# iterate through the grid from 1 to length of grid for rows and columns.
    # the iteration starts from 1 because if a 0 is present in the 0th column, it can't be a closed island.
    for i in range(1,m-1):
        for j in range(1,n-1):
			# if the item in the grid is 0 and it is surrounded by
            # up, down, left, right 1's then increment the count.
            if grid[i][j]==0 and dfs(i,j):
                c+=1
    return c",abhi9Rai
1255,https://leetcode.com/problems/maximum-score-words-formed-by-letters/discuss/2407807/PYTHON-SOL-or-RECURSION-%2B-MEMOIZATION-or-EXPLAINED-or-CLEAR-AND-CONSCISE-or,"class Solution:
    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:
        count , n , dp = [0]*26 , len(words) , {}
        
        for c in letters: count[ord(c) - 97] += 1
        
        def recursion(index,count):
            if index == n: return 0
            
            tpl = tuple(count)
            
            if (index,tpl) in dp: return dp[(index,tpl)]
            
            ans = recursion(index + 1, count)
            
            flag , tmp , cpy , add = True , defaultdict(int) , count.copy() , 0
            for c in words[index]: tmp[c] += 1
            
            for key in tmp:
                if tmp[key] <= cpy[ord(key) - 97]:
                    cpy[ord(key) - 97] -= tmp[key]
                    add += score[ord(key) - 97] * tmp[key] 
                else:
                    flag = False
                    break
            if flag : ans = max(ans, recursion(index + 1, cpy) + add)
            
            dp[(index,tpl)] = ans
            
            return ans
        
        return recursion(0 , count)",reaper_27
1260,https://leetcode.com/problems/shift-2d-grid/discuss/1935910/Just-Flatten-and-Rotate-the-Array,"class Solution:
    def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array
        n = len(nums)
        k = k % n
        nums[:] = nums[n - k:] + nums[:n - k]
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        arr = [i for sublist in grid for i in sublist] # Flatten out the array
        self.rotate(arr,k) # Rotate the array 
        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix
        return grid # Return 2d Result",anCoderr
1262,https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/497058/Python-3-(four-lines)-(Math-Solution)-(no-DP)-(beats-~92),"class Solution:
    def maxSumDivThree(self, N: List[int]) -> int:
        A, B, S = heapq.nsmallest(2,[n for n in N if n % 3 == 1]), heapq.nsmallest(2,[n for n in N if n % 3 == 2]), sum(N)
        if S % 3 == 0: return S
        if S % 3 == 1: return S - min(A[0], sum(B) if len(B) > 1 else math.inf)
        if S % 3 == 2: return S - min(B[0], sum(A) if len(A) > 1 else math.inf)
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
1263,https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/2643673/Python3-Double-BFS-or-O(m2-*-n2),"class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        
        neighbors = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        
        def player_bfs(st_row, st_col, tgt_row, tgt_col):
            nonlocal rows, cols
            if (st_row, st_col) == (tgt_row, tgt_col):
                return True
            q = deque([(st_row, st_col)]) 
            seen = [[False] * cols for _ in range(rows)]
            seen[st_row][st_col] = True
            
            while q:
                row, col = q.pop()
                for r, c in neighbors:
                    if 0 <= row+r < rows and 0 <= col+c < cols and not seen[row+r][col+c] and grid[row+r][col+c] == '.':
                        if row+r == tgt_row and col+c == tgt_col:
                            return True
                        seen[row+r][col+c] = True
                        q.appendleft((row+r, col+c))
            return False
            
        def box_bfs(st_row, st_col):
            nonlocal rows, cols, target
            q = deque([(st_row, st_col, start[0], start[1], 0)])
            seen = {st_row, st_col, start[0], start[1]}
            
            while q:
                row, col, prow, pcol, moves = q.pop()
                grid[row][col] = 'B'
                for r, c in neighbors:
                    box_can_move = 0 <= row+r < rows and 0 <= col+c < cols and (row+r, col+c, row-r, col-c) not in seen and grid[row+r][col+c] == '.'
                    if box_can_move and player_bfs(prow, pcol, row-r, col-c):
                        if (row+r, col+c) == target:
                            return moves + 1
                        seen.add((row+r, col+c, row-r, col-c))
                        q.appendleft((row+r, col+c, row-r, col-c, moves+1))
                grid[row][col] = '.'
            
            return -1
        
        start = target = box = None
        rows, cols = len(grid), len(grid[0])
        for r, row in enumerate(grid):
            for c, pos in enumerate(row):
                if pos == 'S':
                    start = (r, c)
                    grid[r][c] = '.'
                elif pos == 'T':
                    target = (r, c)
                    grid[r][c] = '.'
                elif pos == 'B':
                    box = (r, c)
                    grid[r][c] = '.'
        
        return box_bfs(*box)",ryangrayson
1267,https://leetcode.com/problems/count-servers-that-communicate/discuss/1587912/93-faster-oror-Well-Explained-oror-Thought-Process-oror-Clean-and-Concise,"class Solution:
def countServers(self, grid: List[List[int]]) -> int:
    
    m,n = len(grid),len(grid[0])
    rows = [0]*m
    cols = [0]*n
    total = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j]==1:
                rows[i]+=1
                cols[j]+=1
                total+=1
    
    cnt = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j]==1 and rows[i]==1 and cols[j]==1:
                cnt+=1
    
    return total-cnt",abhi9Rai
1268,https://leetcode.com/problems/search-suggestions-system/discuss/436564/Python-A-simple-approach-without-using-Trie,"class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        list_ = []
        products.sort()
        for i, c in enumerate(searchWord):
            products = [ p for p in products if len(p) > i and p[i] == c ]
            list_.append(products[:3])
        return list_",crosserclaws
1269,https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/discuss/2488667/LeetCode-The-Hard-Way-DP-with-Explanation,"class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        M = 10 ** 9 + 7
        @lru_cache(None)
        def dfs(pos, steps):
            # if we walk outside the array or use all the steps
            # then return 0
            if pos < 0 or pos > steps or pos > arrLen - 1: return 0
            # if we use all the steps, return 1 only if pos is 0
            if steps == 0: return pos == 0
            return (
                # move to the left
                dfs(pos - 1, steps - 1) +
                # stay at current position
                dfs(pos, steps - 1) +
                # move to the right
                dfs(pos + 1, steps - 1) 
            ) % M
        return dfs(0, steps)",wingkwong
1275,https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/discuss/1767406/Python-3-solution-with-comments,"class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        # keep track of the ""net score"" of each row/col/diagonal
        # player A adds 1 to the ""net score"" of each row/col/diagonal they play in,
        # player B subtracts 1
        # scores[0], scores[1] and scores[2] are for rows 0, 1 and 2
        # scores[3], scores[4] and scores[5] are for cols 0, 1 and 2
        # scores[6] and scores[7] are for the forward and backward diagonal
        scores = [0] * 8
        
        for i, (row, col) in enumerate(moves):
            if i % 2 == 0:  # if player A is playing
                x = 1
            else:  # if player B is playing
                x = -1
            
            scores[row] += x
            scores[col + 3] += x
            if row == col:
                scores[6] += x
            if 2 - row == col:
                scores[7] += x
            
        for score in scores:
            if score == 3:
                return 'A'
            elif score == -3:
                return 'B'
        
        return 'Draw' if len(moves) == 9 else 'Pending'",dereky4
1276,https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/discuss/551868/Math-%2B-Python-Using-2-variables-linear-algebra-to-solve-the-problem,"class Solution:
    def numOfBurgers(self, tomatoSlices, cheeseSlices):
		# on the basis of the matrix solution
        ans = [0.5 * tomatoSlices - cheeseSlices, -0.5 * tomatoSlices + 2 * cheeseSlices]
		
		# using the constraints to see if solution satisfies it
        if 0 <= int(ans[0]) == ans[0] and 0 <= int(ans[1]) == ans[1]:
            return [int(ans[0]), int(ans[1])]
        else:
            return []",Suraj1127
1277,https://leetcode.com/problems/count-square-submatrices-with-all-ones/discuss/1736397/Python-Thought-process-for-the-DP-solution-with-very-simple-explanation-(with-images),"class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        
        count=matrix.count(1)
        count=0
        for r in range(len(matrix)):
            for c in range(len(matrix[0])):
                if matrix[r][c]==1:
                    count+=1
                if r==0 or c==0: continue
                
                old_val=matrix[r][c]
                matrix[r][c]=min(matrix[r-1][c-1], matrix[r][c-1],matrix[r-1][c]) + 1 if matrix[r][c]==1 else 0
                count= count+ matrix[r][c]- old_val  
        return count",InjySarhan
1278,https://leetcode.com/problems/palindrome-partitioning-iii/discuss/2593400/Dynamic-Programming-oror-Recursion-oror-Memoization-oror-Easy-Intuition-oror-Python,"class Solution:
    def palindromePartition(self, s: str, k: int) -> int:
        
        
		#This is the cost function 
        
        def Cost(s):
            i,j,c=0,len(s)-1,0
            
            while i<j:
                if s[i]!=s[j]:c+=1
                j-=1
                i+=1
            return c
        
        dp={}
        
		# Recursion
		
        def A(s,k):
			# Memoization
            if (s,k) in dp:
                return dp[(s,k)]
			# if k==1 then we want the whole string there is no other way 
            if k==1:
                return Cost(s)
            
			#intial value to max
            f=float('inf')
            
            #start checking whole string 
            for x in range(1,len(s)+1):
                #check wheather if both the strings exist.
                if len(s[:x]) and len(s[x:]):
				
                    #if exist we find the cost recursively assign min value 
                    f=min(f,Cost(s[:x])+A(s[x:],k-1))
             #store the min value       
            dp[(s,k)]=f
			
            return dp[(s,k)]
        return A(s,k)
                
                    
            
            ```",srikarsai550
1281,https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/discuss/1713663/Python-3-(20ms)-or-3-Solutions-or-Fastest-Iterative-and-One-Liners-or-Super-Easy,"class Solution:
    def subtractProductAndSum(self, n: int) -> int:
        p,s=1,0
        while n!=0:
            p*=(n%10)
            s+=(n%10)
            n//=10
        return p-s",MrShobhit
1282,https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/discuss/712693/Python-O(n)-Easy-to-Understand,"class Solution:
    # Time: O(n)
    # Space: O(n)
    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:
        res, dic = [], {}
        for idx, group in enumerate(groupSizes):
            if group not in dic:
                dic[group] = [idx]
            else:
                dic[group].append(idx)
            
            if len(dic[group]) == group:
                res.append(dic[group])
                del dic[group]
        return res",whissely
1283,https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/863333/Python3-Binary-search-with-explanation,"class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        left, right = 1, max(nums)
        while left + 1 < right:
            mid = (left + right) // 2
            div_sum =  self.get_sum(mid, nums)
            if div_sum > threshold:
                left = mid
            else:
                right = mid
        
        div_sum = self.get_sum(left, nums)
        if div_sum <= threshold:
            return left
        return right
        
    
    def get_sum(self, divisor, nums):
        res = 0
        for n in nums:
            tmp = n // divisor
            if tmp * divisor < n:
                tmp += 1
            
            res += tmp
        
        return res",ethuoaiesec
1284,https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/discuss/446552/Python-3-(ten-lines)-(Check-All-Permutations),"class Solution:
    def minFlips(self, G: List[List[int]]) -> int:
        M, N = len(G), len(G[0])
        P = [(i,j) for i,j in itertools.product(range(M),range(N))]
        for n in range(M*N+1):
            for p in itertools.permutations(P,n):
                H = list(map(list,G))
                for (x,y) in p:
                    for (i,j) in (x,y-1),(x,y),(x,y+1),(x-1,y),(x+1,y):
                        if 0 <= i < M and 0 <= j < N: H[i][j] = 1 - H[i][j]
                if max(max(H)) == 0: return n
        return -1
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
1287,https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/discuss/452166/Python-3-(four-different-one-line-solutions)-(beats-100),"class Solution:
    def findSpecialInteger(self, A: List[int]) -> int:
        return collections.Counter(A).most_common(1)[0][0]
		

from statistics import mode

class Solution:
    def findSpecialInteger(self, A: List[int]) -> int:
        return mode(A)


class Solution:
    def findSpecialInteger(self, A: List[int]) -> int:
        return max(set(A), key = A.count)
		
		
class Solution:
    def findSpecialInteger(self, A: List[int]) -> int:
        return (lambda C: max(C.keys(), key = lambda x: C[x]))(collections.Counter(A))
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
1288,https://leetcode.com/problems/remove-covered-intervals/discuss/1784520/Python3-SORTING-Explained,"class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        res, longest = len(intervals), 0
        srtd = sorted(intervals, key = lambda i: (i[0], -i[1]))
        
        for _, end in srtd:
            if end <= longest:
                res -= 1
            else:
                longest = end
                
        return res",artod
1289,https://leetcode.com/problems/minimum-falling-path-sum-ii/discuss/1998001/Python-DP-Solution-or-Min-and-Second-min-or-Faster-than-79.77,"class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        cols = len(grid[0])
        min1 = min11 = float('inf')                     # min1 -> minimum , min11 -> second minimum in even indexed row
        min2 = min22 = float('inf')                     # min2 -> minimum , min22 -> second minimum in odd indexed row
        for i in range(rows):
            for j in range(cols):
                if i==0:
                    if grid[i][j]<=min1:                # Logic to find minimum and second minimum
                        min11 = min1
                        min1 = grid[i][j]
                    elif grid[i][j]<min11:
                        min11 = grid[i][j]    
                else:
                    if i%2:
                        if grid[i-1][j]==min1:          # If adjacent -> then add the second minimum value
                            grid[i][j] += min11
                        else:                           # Else -> add the minimum value
                            grid[i][j] += min1
                        if grid[i][j]<min2:             # Logic to find minimum and second minimum
                            min22 = min2
                            min2 = grid[i][j]
                        elif grid[i][j]<min22:
                            min22 = grid[i][j]
                    else:
                        if grid[i-1][j]==min2:
                            grid[i][j] += min22
                        else:
                            grid[i][j] += min2
                        if grid[i][j]<min1:             # Logic to find minimum and second minimum
                            min11 = min1
                            min1 = grid[i][j]
                        elif grid[i][j]<min11:
                            min11 = grid[i][j]    
            if i%2:                                     # Reset the minimum and second minimum values accordingly
                min1 = min11 = float('inf')
            else:
                min2 = min22 = float('inf')
        return min(grid[-1])                            # Return the minimum element in last row",lin_lance_07
1290,https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/discuss/455239/Python-Simple.-20ms.,"class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        answer = 0
        while head: 
            answer = 2*answer + head.val 
            head = head.next 
        return answer",rohin7
1291,https://leetcode.com/problems/sequential-digits/discuss/1713379/Python-3-(20ms)-or-Faster-than-95-or-Generating-All-Sequential-Digits-within-Range,"class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        l=len(str(low))
        h=len(str(high))
        ans=[]
        a=[12,23,34,45,56,67,78,89]
        t=0
        while l<=h:
            for i in a:
                for j in range(0,l-2):
                    t=i%10
                    if i==9:
                        break
                    i=int(str(i)+str(t+1))
                if i%10==0:
                    break
                if i>=low and i<=high:
                    ans.append(i)
            l+=1
        return ans",MrShobhit
1292,https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/discuss/691648/Python3-binary-search-like-bisect_right-Maximum-Side-Length-of-a-Square-with-Sum-less-Threshold,"class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        ans = 0            
        m = len(mat)
        n = len(mat[0])
        presum = [[0] * (n+1) for _ in range(m+1)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                presum[i][j] = mat[i-1][j-1] + presum[i][j-1] + presum[i-1][j] - presum[i-1][j-1] 
                lo, hi = 1, min(i, j) + 1
                while lo < hi:
                    mid = (lo + hi)//2
                    cursum = presum[i][j] - presum[i-mid][j] - presum[i][j-mid] + presum[i-mid][j-mid]
                    if cursum > threshold:
                        hi = mid
                    else:
                        lo = mid + 1
                ans = max(ans, lo-1)
        return ans",r0bertz
1293,https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/discuss/2758292/Python-Simple-and-Easy-Way-to-Solve-or-95-Faster,"class Solution:
    def shortestPath(self, grid: List[List[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])
        
        # x, y, obstacles, steps
        q = deque([(0,0,k,0)])
        seen = set()
        
        while q:
            x, y, left, steps = q.popleft()
            if (x,y,left) in seen or left<0:
                continue
            if (x, y) == (m-1, n-1):
                return steps
            seen.add((x,y,left))
            if grid[x][y] == 1:
                left-=1
            for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
                new_x, new_y = x+dx, y+dy
                if 0<=new_x<m and 0<=new_y<n:
                    q.append((new_x, new_y, left, steps+1))
        return -1",pniraj657
1295,https://leetcode.com/problems/find-numbers-with-even-number-of-digits/discuss/468107/Python-3-lightning-fast-one-line-solution,"class Solution:
    def findNumbers(self, nums: List[int]) -> int:
        return len([x for x in nums if len(str(x)) % 2 == 0])",denisrasulev
1296,https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/discuss/785364/O(N-log(N))-time-and-O(N)-space-Python3-using-Hashmap-and-lists,"class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        hand = nums
        W = k
        if not hand and W > 0:
            return False
        if W > len(hand):
            return False
        if W == 0 or W == 1: 
            return True
        expectation_map = {}
        # self.count keep track of the numbers of cards that have been successfully counted as a straight,
        # when self.count == len(hand) => All cards are part of a valid straight 
        self.count = 0
        handLength = len(hand)

        #Sort the hand.
        sortedHand = sorted(hand)

        
        """"""
        This method updates the expectation map in the following way:
            a) If the len(l) == W
                    => We've completed a straight of length W, add it towards the final count
            b) if the next expected number (num+1) is already in the map 
                    => add the list to a queue of hands waiting to make a straight
            c) if expected number (num+1) not in the map 
                    => Add a new expectation key with value as a new queue with this list 
        """"""
        def update_expectation_with_list(expectation_map, num, l, W):
            # If we have W consecutive numbers, we're done with this set, count towards final count
            if len(l) == W:
                self.count += W
            # we need more numbers to make this straight, add back with next expected num 
            else:
                exp = num + 1
                # Some other list is already expecting this number, add to the queue
                if exp in expectation_map:
                    expectation_map[exp].append(l)

                # New expected number, create new key and set [l] as value
                else:
                    expectation_map[exp] = [l]
        
        """"""
        Very similar to update_expectation_with_list. The difference here is we have the first card of the straight and thus we need to handle it correctly (set the value as a list of lists)
        """"""
        def update_expectation_with_integer(expectation_map, num):
            exp = num + 1
            # Some other list is already expecting this number, add to the queue
            if exp in expectation_map:
                expectation_map[exp].append([num])
            # New expected number, create new key and set [num] as value
            else:
                expectation_map[exp] = [[num]]
        
        for idx,num in enumerate(sortedHand):
            # A possible straight can be formed with this number
            if num in expectation_map:
                # there are multiple hands waiting for this number
                if len(expectation_map[num]) > 1:
                    # pop the first hand
                    l = expectation_map[num].pop(0)
                    # add num to this hand
                    l.append(num)
                    # Update the expectation map
                    update_expectation_with_list(expectation_map, num, l, W)
                
                # there's only one hand expecting this number
                else:
                    # pop the first hand
                    l = expectation_map[num].pop(0)
                    l.append(num)

                    # Important : del the key! There's no other hand expecting this number
                    expectation_map.pop(num) 
                    update_expectation_with_list(expectation_map, num, l, W)
                    
            # Nothing is expecting this number, add new expectation to the map
            else:
                update_expectation_with_integer(expectation_map, num)
                
        return self.count == handLength",prajwalpv
1297,https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/discuss/1905801/python-easy-approach,"class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        s1 = []
        count ={}
        while minSize <= maxSize:
            for i in range(0,len(s)):
                if (i+ minSize) <=len(s) and len(set(s[i: i+ minSize])) <= maxLetters:
                    s1.append(s[i: i+ minSize])
            minSize += 1         
        for i in s1:
            count[i] = count[i] + 1 if i in count  else 1      
        return max(count.values()) if count else 0",hari07
1298,https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/discuss/2841531/Easy-to-understand-BFS-Solution-(with-explanation),"class Solution:
    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:
        myKeys = set()
        canVisit = set(initialBoxes)
        q = initialBoxes[:]
        # Check [all keys we can get] and [all boxes we can visit]
        while q:
            box = q.pop(0)
            myKeys.update(set((keys[box]))) # Add the keys in box into ""myKeys""
            canVisit.add(box) # Add current box into ""canVisit""
            newBoxes = containedBoxes[box] # Add next boxes to the queue
            for nb in newBoxes:
                q.append(nb)
                
        ans = 0
        # Visit all boxes we can visit 
        for i in canVisit:
            # We can open the box only if we have the key or box's status is open(1)
            if i in myKeys or status[i] == 1:
                ans += candies[i]
        return ans",child70370636
1299,https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/discuss/1058153/Easy-and-simple-python-solution-or-O(n),"class Solution:
    def replaceElements(self, arr: List[int]) -> List[int]:
        mx = arr[-1]
        arr[-1] = -1
        for i in range(len(arr) - 2, -1, -1):
            temp = arr[i]
            arr[i] = mx
            if mx < temp: mx = temp
        return arr",vanigupta20024
1300,https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/discuss/463586/Python3-Sort-and-scan,"class Solution:
    def findBestValue(self, arr: List[int], target: int) -> int:
        arr.sort()
        s, n = 0, len(arr)
        
        for i in range(n):
            ans = round((target - s)/n)
            if ans <= arr[i]: return ans 
            s += arr[i]
            n -= 1
            
        return arr[-1]",ye15
1301,https://leetcode.com/problems/number-of-paths-with-max-score/discuss/463581/Python3-Bottom-up-DP,"class Solution:
    def pathsWithMaxScore(self, board: List[str]) -> List[int]:
        """"""bottom-up dp""""""
        n = len(board) #dimension

        #count > 0 also indicates state is reachable
        dp = [[0, 0] for _ in range(n+1)] #score-count (augment by 1 for convenience)
        
        for i in reversed(range(n)):
            #not assuming reachability while updating state
            copy = [[0, 0] for _ in range(n+1)] #to be updated to new dp
            for j in reversed(range(n)): 
                if board[i][j] == ""X"": continue #skip obstacle
                if board[i][j] == ""S"": #initialize ""S""
                    copy[j] = [0, 1]
                    continue 
                #find max score from neighbors
                for candidate in (copy[j+1], dp[j], dp[j+1]): #right/below/right-below
                    if not candidate[1]: continue #not reachable
                    if copy[j][0] < candidate[0]: copy[j] = candidate[:]
                    elif copy[j][0] == candidate[0]: copy[j][1] = (copy[j][1] + candidate[1])%(10**9+7)
                #update with board number 
                if board[i][j] != ""E"": copy[j][0] += int(board[i][j])
            dp = copy
        return dp[0]",ye15
1302,https://leetcode.com/problems/deepest-leaves-sum/discuss/1763924/Python-Simple-Level-Order-Traversal,"class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:
        q = [(root, 0)]
        ans = 0
        curr_level = 0 # Maintains the current level we are at
        while len(q) != 0: # Do a simple Level Order Traversal
            current, max_level = q.pop(0)
            if max_level > curr_level: # Update the ans as curr_level gets outdated
                curr_level = max_level # Update curr_level
                ans = 0 # Ans needs to be constructed for the new level i.e. max_level
            ans += current.val
            if current.left is not None:
                q.append((current.left, max_level + 1))
            if current.right is not None:
                q.append((current.right, max_level + 1))
        return ans",anCoderr
1304,https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/discuss/463818/Two-Solutions-in-Python-3-(one-line)-(beats-100)-(24-ms),"class Solution:
    def sumZero(self, n: int) -> List[int]:
        return list(range(1,n))+[-n*(n-1)//2]",junaidmansuri
1305,https://leetcode.com/problems/all-elements-in-two-binary-search-trees/discuss/523589/python-only-2-lines-easy-to-read-with-explanation.-Can-it-be-any-shorter,"class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        h = lambda r:  h(r.left) + [r.val] + h(r.right) if r else []
        return sorted( h(root1) + h(root2) )",rmoskalenko
1306,https://leetcode.com/problems/jump-game-iii/discuss/571683/Python3-3-Lines-DFS.-O(N)-time-and-space.-Recursion,"class Solution:
    def canReach(self, arr: List[int], i: int) -> bool:
        if i < 0 or i >= len(arr) or arr[i] < 0: return False
        arr[i] *= -1 # Mark visited
        return arr[i] == 0 or self.canReach(arr, i - arr[i]) or self.canReach(arr, i + arr[i])",jimmyyentran
1307,https://leetcode.com/problems/verbal-arithmetic-puzzle/discuss/1216642/Python3-backtracking,"class Solution:
    def isSolvable(self, words: List[str], result: str) -> bool:
        if max(map(len, words)) > len(result): return False # edge case 
        
        words.append(result)
        digits = [0]*10 
        mp = {} # mapping from letter to digit 
        
        def fn(i, j, val): 
            """"""Find proper mapping for words[i][~j] and result[~j] via backtracking.""""""
            if j == len(result): return val == 0 # base condition 
            if i == len(words): return val % 10 == 0 and fn(0, j+1, val//10)
            
            if j >= len(words[i]): return fn(i+1, j, val)
            if words[i][~j] in mp: 
                if j and j+1 == len(words[i]) and mp[words[i][~j]] == 0: return # backtrack (no leading 0)
                if i+1 == len(words): return fn(i+1, j, val - mp[words[i][~j]])
                else: return fn(i+1, j, val + mp[words[i][~j]])
            else: 
                for k, x in enumerate(digits): 
                    if not x and (k or j == 0 or j+1 < len(words[i])): 
                        mp[words[i][~j]] = k
                        digits[k] = 1
                        if i+1 == len(words) and fn(i+1, j, val-k): return True 
                        if i+1 < len(words) and fn(i+1, j, val+k): return True 
                        digits[k] = 0
                        mp.pop(words[i][~j])
        
        return fn(0, 0, 0)",ye15
1309,https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping/discuss/470770/Python-3-(two-lines)-(beats-100)-(16-ms)-(With-Explanation),"class Solution:
    def freqAlphabets(self, s: str) -> str:
        for i in range(26,0,-1): s = s.replace(str(i)+'#'*(i>9),chr(96+i))
        return s
            
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
1310,https://leetcode.com/problems/xor-queries-of-a-subarray/discuss/470834/Python-3-(two-lines)-(beats-100)-(412-ms),"class Solution:
    def xorQueries(self, A: List[int], Q: List[List[int]]) -> List[int]:
        B = [A[0]]
        for a in A[1:]: B.append(B[-1]^a)
        B.append(0)
        return [B[L-1]^B[R] for L,R in Q]",junaidmansuri
1311,https://leetcode.com/problems/get-watched-videos-by-your-friends/discuss/491936/Python3-Breadth-first-search,"class Solution:
    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:
        queue = [id]
        count = 0
        seen = set(queue)
        while queue and count < level: #bfs
            count += 1
            temp = set()
            for i in queue: 
                for j in friends[i]:
                    if j not in seen: 
                        temp.add(j)
                        seen.add(j)
            queue = temp
        
        movies = dict()
        for i in queue: 
            for m in watchedVideos[i]: 
                movies[m] = movies.get(m, 0) + 1
        return [k for _, k in sorted((v, k) for k, v in movies.items())]",ye15
1312,https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/discuss/470856/Python-3-(four-lines)-(DP)-(LCS),"class Solution:
    def minInsertions(self, S: str) -> int:
        L = len(S)
        DP = [[0 for _ in range(L+1)] for _ in range(L+1)]
        for i,j in itertools.product(range(L),range(L)): DP[i+1][j+1] = DP[i][j] + 1 if S[i] == S[L-1-j] else max(DP[i][j+1],DP[i+1][j])
        return L - DP[-1][-1]
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
1313,https://leetcode.com/problems/decompress-run-length-encoded-list/discuss/478426/Python-3-(one-line)-(beats-100),"class Solution:
    def decompressRLElist(self, N: List[int]) -> List[int]:
        L, A = len(N), []
        for i in range(0,L,2):
            A.extend(N[i]*[N[i+1]])
        return A",junaidmansuri
1316,https://leetcode.com/problems/distinct-echo-substrings/discuss/1341886/Python-3-Rolling-hash-(5780ms),"class Solution:
    def distinctEchoSubstrings(self, text: str) -> int:
        n = len(text)
		
        def helper(size):
            base = 1 << 5
            M = 10 ** 9 + 7
            a = pow(base, size, M)
            t = 0
            vis = defaultdict(set)
            vis_pattern = set()
            ans = 0
            for i in range(n):
                t = (base * t + ord(text[i]) - ord('a')) % M
                if i >= size:
                    t -= a * (ord(text[i - size]) - ord('a'))
                    t %= M
                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:
                        ans += 1
                        vis_pattern.add(t)
                if i >= size - 1:
                    vis[t].add(i - size + 1)
            return ans

        return sum(helper(size) for size in range(1, n//2+1))",chestnut890123
1317,https://leetcode.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers/discuss/1219360/Python-Fast-and-Easy-Soln,"class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        left = 0
        right = n
        ans = []
        while True:
            if str(left).count(""0"")==0 and str(right).count(""0"")==0:
                ans.append(left)
                ans.append(right)
                break
            left+=1
            right-=1
        return ans",iamkshitij77
1318,https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/discuss/489623/Python-Simple-Solution-Python-Memory-usage-less-than-100,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:   
        count = 0
        while a or b or c:
            if (a &amp; 1) | (b &amp; 1) != (c &amp; 1):
                if (c &amp; 1): count += 1
                else: count += (a &amp; 1) + (b &amp; 1)
            a, b, c = a >> 1, b >> 1, c >> 1
        return count",mmbhatk
1319,https://leetcode.com/problems/number-of-operations-to-make-network-connected/discuss/2420269/Operations-to-make-network-connected-oror-Python3-oror-Union-Find,"class Solution:
    def makeConnected(self, n: int, connections: List[List[int]]) -> int:
        self.components = n
        # We need atleast n-1 connections to connect n networks
        if(len(connections) < n-1):
            return -1
        # If we have n-1 connections, we only need to count to number of components
        # Union-Find 
        
        parent = [i for i in range(0, n)]
        rank = [0] * n
        for x, y in connections:
            self.union(x, y, parent, rank)
        # we require no. of components - 1 edge to connect n components
        return self.components - 1             
        
    def find(self, x, parent):
        if(parent[x] != x):
            parent[x] = self.find(parent[x], parent)
        return parent[x]
    
    def union(self, x, y, parent, rank):
        parent_x = self.find(x, parent)
        parent_y = self.find(y, parent)
        
        if(parent_x == parent_y):
            return
        rank_x = rank[parent_x]
        rank_y = rank[parent_y]
        
        if(rank_x > rank_y):
            parent[parent_y] = parent_x
        elif(rank_x < rank_y):
            parent[parent_x] = parent_y
        else:
            parent[parent_y] = parent_x
            rank[parent_x] += 1
        self.components -= 1",vanshika_2507
1320,https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/1509241/Well-Coded-oror-Clean-and-Concise-oror-93-faster,"class Solution:
def minimumDistance(self, word: str) -> int:
    def dist(pre,cur):
        if pre==None:
            return 0
        x1,y1 = divmod(ord(pre)-ord('A'),6)
        x2,y2 = divmod(ord(cur)-ord('A'),6)
        return abs(x1-x2) + abs(y1-y2)
    
    @lru_cache(None)
    def fingers(i,l,r):
        if i == len(word):
            return 0
        n1 = dist(l,word[i]) + fingers(i+1,word[i],r)
        n2 = dist(r,word[i]) + fingers(i+1,l,word[i])
        return min(n1,n2)
    
    return fingers(0,None,None)",abhi9Rai
1324,https://leetcode.com/problems/print-words-vertically/discuss/1277233/python-94.44-or-easy-or-with-comments,"class Solution:
    def printVertically(self, s: str) -> List[str]:
        
        
        st=0 # track of index to take element from each word 
        s=s.split()
        ans=[]
        y=0
        for i in s:
            y=max(y,len(i))
   
        while st<y:
            u=[]
            for i in s:
                if st<len(i):
                    u.append(i[st])
                else:
                    u.append(' ')# adding spaces if word length is less
                    
            
            while u[-1]==' ': # using stack operation to remove trailing spaces
                u.pop()
            ans.append(''.join(u))
            st+=1# increasing index at each iteration 
        return ans",chikushen99
1325,https://leetcode.com/problems/delete-leaves-with-a-given-value/discuss/484504/Python-3-(beats-100)-(five-lines)-(recursive),"class Solution:
    def removeLeafNodes(self, R: TreeNode, t: int) -> TreeNode:
        def RLN(R):
            if R == None: return None
            R.left, R.right = RLN(R.left), RLN(R.right)
            return None if R.val == t and R.left == R.right else R
        return RLN(R)
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
1326,https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/discuss/484299/Python-%3A-O(N),"class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        jumps = [0]*(n+1)
        for i in range(n+1):
            l, r = max(0,i-ranges[i]),  min(n,i+ranges[i])
            jumps[l] = max(jumps[l],r-l)
        step = start = end = 0
        while end < n:
            start, end = end+1, max(i+jumps[i] for i in range(start, end+1))
            if start > end:
                return -1
            step += 1
        return step",fallenranger
1328,https://leetcode.com/problems/break-a-palindrome/discuss/846873/Python-3-or-Greedy-one-pass-or-Explanations,"class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        n = len(palindrome)
        if n == 1: return ''
        for i, c in enumerate(palindrome):
            if c != 'a' and ((i != n // 2 and n % 2) or not n % 2): return palindrome[:i] + 'a' + palindrome[i+1:]                
        else: return palindrome[:-1] + 'b'",idontknoooo
1329,https://leetcode.com/problems/sort-the-matrix-diagonally/discuss/920657/Python3-simple-solution,"class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        
        
        d = defaultdict(list)
        
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                d[i-j].append(mat[i][j])
        
        for k in d.keys():
            d[k].sort()
        
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                mat[i][j] = d[i-j].pop(0)
        return mat",ermolushka2
1330,https://leetcode.com/problems/reverse-subarray-to-maximize-array-value/discuss/489882/O(n)-Solution-with-explanation,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        maxi, mini = -math.inf, math.inf
        
        for a, b in zip(nums, nums[1:]):
            maxi = max(min(a, b), maxi)
            mini = min(max(a, b), mini)
        change = max(0, (maxi - mini) * 2)
        
        # solving the boundary situation
        for a, b in zip(nums, nums[1:]):
            tmp1 = - abs(a - b) + abs(nums[0] - b)
            tmp2 = - abs(a - b) + abs(nums[-1] - a)
            change = max([tmp1, tmp2, change])
			
        original_value = sum(abs(a - b) for a, b in zip(nums, nums[1:]))
        return  original_value + change",neal99
1331,https://leetcode.com/problems/rank-transform-of-an-array/discuss/2421511/Python-Elegant-and-Short-or-Two-lines-or-HashMap-%2B-Sorting,"class Solution:
	""""""
	Time:   O(n*log(n))
	Memory: O(n)
	""""""

	def arrayRankTransform(self, arr: List[int]) -> List[int]:
		ranks = {num: r for r, num in enumerate(sorted(set(arr)), start=1)}
		return [ranks[num] for num in arr]",Kyrylo-Ktl
1332,https://leetcode.com/problems/remove-palindromic-subsequences/discuss/2124192/Python-oror-2-Easy-oror-One-liner,"class Solution:
    def removePalindromeSub(self, s: str) -> int:
        return 1 if s == s[::-1] else 2",constantine786
1333,https://leetcode.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/discuss/1464395/Python3-solution,"class Solution:
    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:
        def f(x):
            if (veganFriendly == 1 and x[2] == 1 and x[3] <= maxPrice and x[4] <= maxDistance) or (veganFriendly == 0 and x[3] <= maxPrice and x[4] <= maxDistance):
                return True
            else:
                return False
        y = list(filter(f,restaurants))
        y.sort(key=lambda a:a[0],reverse=True)
        y.sort(key=lambda a:a[1],reverse=True)
        return [i[0] for i in y]",EklavyaJoshi
1335,https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/2709132/91-Faster-Solution,"class Solution:
    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
        jobCount = len(jobDifficulty)    
        if jobCount < d:
            return -1

        @lru_cache(None)
        def topDown(jobIndex: int, remainDayCount: int) -> int:
            remainJobCount = jobCount - jobIndex
            if remainDayCount == 1:
                return max(jobDifficulty[jobIndex:])
            
            if remainJobCount == remainDayCount:
                return sum(jobDifficulty[jobIndex:])

            minDiff = float('inf')
            maxToday = 0
            for i in range(jobIndex, jobCount - remainDayCount + 1):
                maxToday = max(maxToday, jobDifficulty[i])
                minDiff = min(minDiff, maxToday + topDown(i+1, remainDayCount-1))
            return minDiff

        return topDown(0, d)",namanxk
1337,https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/discuss/1201679/C%2B%2B-Python3-No-Heap-No-BS-Simple-Sort-99.20,"class Solution:
	def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
		m = len(mat)
		rows = sorted(range(m), key=lambda i: (mat[i], i))
		del rows[k:]
		return rows",mycoding1729
1338,https://leetcode.com/problems/reduce-array-size-to-the-half/discuss/2443490/Easy-to-understand-or-C%2B%2B-or-PYTHON-or,"class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        freq = Counter(arr);
        f = [];
        for val in freq.values():
            f.append(val);
        f.sort(reverse=True)
        ans = 0;
        n = 0;
        while(len(arr)//2>n):
            n += f[ans];
            ans += 1;
        return ans;",dharmeshkporiya
1339,https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/discuss/496700/Python3-post-order-dfs,"class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        vals = []
        
        def fn(node): 
            """"""Return sum of sub-tree.""""""
            if not node: return 0 
            ans = node.val + fn(node.left) + fn(node.right)
            vals.append(ans)
            return ans
        
        total = fn(root)
        return max((total-x)*x for x in vals) % 1_000_000_007",ye15
1340,https://leetcode.com/problems/jump-game-v/discuss/1670065/Well-Coded-and-Easy-Explanation-oror-Use-of-Memoization,"class Solution:
	def maxJumps(self, arr: List[int], d: int) -> int:

		dp = defaultdict(int)
		def dfs(i):
			if i in dp: return dp[i]
			m_path = 0
			for j in range(i+1,i+d+1):
				if j>=len(arr) or arr[j]>=arr[i]: break
				m_path = max(m_path,dfs(j))

			for j in range(i-1,i-d-1,-1):
				if j<0 or arr[j]>=arr[i]: break
				m_path = max(m_path,dfs(j))
			dp[i] = m_path+1
			return m_path+1

		res = 0
		for i in range(len(arr)):
			res = max(res,dfs(i))
		return res",abhi9Rai
1342,https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/discuss/2738381/Python-Elegant-and-Short-or-O(1)-or-Recursive-Iterative-Bit-Manipulation,"class Solution:
    """"""
    Time:   O(log(n))
    Memory: O(log(n))
    """"""

    def numberOfSteps(self, num: int) -> int:
        if num == 0:
            return 0
        return 1 + self.numberOfSteps(num - 1 if num &amp; 1 else num >> 1)",Kyrylo-Ktl
1343,https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/discuss/1816745/Python-Solution-oror-Sliding-Window,"class Solution:
    def numOfSubarrays(self, arr, k, threshold):
        windowStart = 0
        max_avg = 0
        avg = 0
        c=0
        result = []
        windowSum = 0
        for windowEnd in range(len(arr)):
            windowSum += arr[windowEnd]
            if((windowEnd)>=k-1):
                avg = windowSum//k
                result.append(avg)
                windowSum -= arr[windowStart]
                windowStart += 1
        for i in range(len(result)):
            if(result[i]>=threshold):
                c=c+1
        return c",aashutoshjha21022002
1344,https://leetcode.com/problems/angle-between-hands-of-a-clock/discuss/1911342/Python-one-line-solution-based-on-aptitude-formula,"class Solution:
    def angleClock(self, hour: int, minutes: int) -> float:
        return min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))",amannarayansingh10
1345,https://leetcode.com/problems/jump-game-iv/discuss/1691093/Python3-RECURSIVE-BFS-(_)-Explained,"class Solution:
    def minJumps(self, arr: List[int]) -> int:
        N, groups = len(arr), defaultdict(list)

        for i, el in enumerate(arr): 
            groups[el].append(i)

        vis, vis_groups = set(), set()
        
        def bfs(lvl, dist):
            nextLvl = set()
            
            for i in lvl:
                if i in vis: continue
                if i == N-1: return dist
                
                vis.add(i)
                
                if i: nextLvl.add(i-1)
                if i+1 < N: nextLvl.add(i+1)
                
                if not arr[i] in vis_groups:
                    vis_groups.add(arr[i])
                    nextLvl.update(groups[arr[i]])
            
            return bfs(nextLvl, dist + 1)
            
        return bfs(set([0]), 0)",artod
1346,https://leetcode.com/problems/check-if-n-and-its-double-exist/discuss/503507/Python-3-(five-lines)-(beats-100),"class Solution:
    def checkIfExist(self, A: List[int]) -> bool:
        if A.count(0) > 1: return True
        S = set(A) - {0}
        for a in A:
            if 2*a in S: return True
        return False
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
1347,https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/discuss/503535/Python-3-(two-lines)-(beats-100),"class Solution:
    def minSteps(self, S: str, T: str) -> int:
        D = collections.Counter(S) - collections.Counter(T)
        return sum(max(0, D[s]) for s in set(S))
		
		
- Junaid Mansuri
- Chicago, IL",junaidmansuri
1349,https://leetcode.com/problems/maximum-students-taking-exam/discuss/1899957/Python-Bitmasking-dp-solution-with-explanation,"class Solution:
    def maxStudents(self, seats: list[list[str]]) -> int:
        def count_bits(num: int) -> int:
            # Count how many bits having value 1 in num.
            cnt = 0
            while num:
                cnt += 1
                num &amp;= num - 1

            return cnt

        R, C = len(seats), len(seats[0])
        validSeats = []

        # Calculate valid seats mask for each row.
        for row in seats:
            curr = 0
            for seat in row:
                curr = (curr << 1) + (seat == '.')

            validSeats.append(curr)

        # dp[i][mask] stands for the maximum students on ith row with students
        # following the mask.
        dp = [[-1] * (1 << C) for _ in range(R + 1)]
        dp[0][0] = 0
        for r in range(1, R + 1):
            seatMask = validSeats[r - 1]
            for studentMask in range(1 << C):
                validBits = count_bits(studentMask)

                # 1. Check if a student mask is a subset of seatMask so that
                #   the target student could sit on a seat.
                # 2. The student should not sit next to each other.
                if (
                    studentMask &amp; seatMask == studentMask and
                    studentMask &amp; (studentMask >> 1) == 0
                ):
                    # Then check the upper student mask and make sure that
                    # 1. no student is on the upper left.
                    # 2. no student is on the upper right.
                    # Then the upper mask is a valid candidate for the current
                    # student mask.
                    for upperStudentMask in range(1 << C):
                        if (
                            studentMask &amp; (upperStudentMask >> 1) == 0 and
                            studentMask &amp; (upperStudentMask << 1) == 0 and
                            dp[r - 1][upperStudentMask] != -1
                        ):
                            dp[r][studentMask] = max(
                                dp[r][studentMask],
                                dp[r - 1][upperStudentMask] + validBits
                            )

        return max(dp[-1])",eroneko
1351,https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/discuss/2193369/Python3-slight-tweak-in-binary-search,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        result = 0
        rows = len(grid)
        cols = len(grid[0])
        
        i = 0
        j = cols - 1
        while i < rows and j>=0:
            curr = grid[i][j]
            if(curr < 0):
                j-=1
            else:
                result+=((cols-1) - j) #capture the no.of negative number in this row and jump to next row
                i+=1
        
		#left out negative rows
        while i < rows:
            result+=cols
            i+=1
        
        return result",Dark_wolf_jss
1354,https://leetcode.com/problems/construct-target-array-with-multiple-sums/discuss/2189540/Python-Easy-Solution-oror-Less-Line-Of-Code-oror-Heapify,"class Solution:
	def isPossible(self, target: List[int]) -> bool:

		heapq._heapify_max(target)
		s = sum(target)

		while target[0] != 1:
			sub = s - target[0]
			if sub == 0: return False
			n = max((target[0] - 1) // sub, 1)
			s -= n * sub
			target0 = target[0] - n * sub
			if target0 < 1: return False
			heapq._heapreplace_max(target, target0)

		return True
	```",vaibhav0077
1356,https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/discuss/2697450/Python-or-1-liner-lambda-key,"class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        return sorted(arr, key = lambda item: (str(bin(item))[2:].count(""1""), item))",LordVader1
1358,https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/851021/Python-3-or-Two-Pointers-or-Explanation,"class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        a = b = c = 0                        # counter for letter a/b/c
        ans, i, n = 0, 0, len(s)             # i: slow pointer
        for j, letter in enumerate(s):       # j: fast pointer
            if letter == 'a': a += 1         # increment a/b/c accordingly
            elif letter == 'b': b += 1
            else: c += 1
            while a > 0 and b > 0 and c > 0: # if all of a/b/c are contained, move slow pointer
                ans += n-j                   # count possible substr, if a substr ends at j, then there are n-j substrs to the right that are containing all a/b/c
                if s[i] == 'a': a -= 1       # decrement counter accordingly
                elif s[i] == 'b': b -= 1
                else: c -= 1
                i += 1                       # move slow pointer
        return ans",idontknoooo
1359,https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/discuss/1825566/Python-oror-Easy-To-Understand-oror-98-Faster-oror-Maths,"class Solution:
    def countOrders(self, n: int) -> int:
        n=2*n
        ans=1
        while n>=2:
            ans = ans *((n*(n-1))//2)
            n-=2
            ans=ans%1000000007
        return ans",rahulmittall
1360,https://leetcode.com/problems/number-of-days-between-two-dates/discuss/1814530/Python3-Solution-from-Scratch-NOT-USING-DATETIME,"class Solution:
    def daysBetweenDates(self, date1: str, date2: str) -> int:
        
        def f_date(date): # calculates days passed since '1900-01-01'
            year0 = '1900'
            year1, month1, day1 = date.split('-')
                        
            days = 0
            for y in range(int(year0), int(year1)):
                days += 365
                if y%100 == 0:
                    if y%400 == 0:
                        days += 1
                else:
                    if y%4 == 0:
                        days += 1
                        
            for m in range(int(month1)):
                if m in [1, 3, 5, 7, 8, 10, 12]:
                    days += 31
                if m in [4, 6, 9, 11]:
                    days += 30
                if m == 2:
                    days += 28
                    if int(year1)%100 == 0:
                        if int(year1)%400 == 0:
                            days += 1
                    else:
                        if int(year1)%4 ==0:
                            days += 1
            days += int(day1)
            return days
			
        return abs(f_date(date1) - f_date(date2))",rmateusc
1361,https://leetcode.com/problems/validate-binary-tree-nodes/discuss/1393392/Diagram-Explained-Clean-4-checks-single-parents-single-root-no-cycle-all-connected,"class Solution:
    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:
        n = len(leftChild)
        
        # tree has 2 requirements
        # 1. every node has a single parent
        # 2. single root (only one node has NO parent)
        # 3. no cycle
        # 4. all nodes connected to each other (single component)
        
        parent = [-1] * n
        
        # checking condition (1. and 2.)
        for idx, (left, right) in enumerate(zip(leftChild, rightChild)):
            
            if left != -1:
                # FAILED: condition (1.)
                if parent[left] != -1: return False
                parent[left] = idx
                
            if right != -1:
                # FAILED: condition (1.)
                if parent[right] != -1: return False
                parent[right] = idx
        
        # FAILED condition (2.)
        if parent.count(-1) != 1: return False
            
        # checking condition (3. and 4.)
        vis = set()
        def dfs_has_cycle(u):
            if u in vis:
                return True
            else:
                vis.add(u)
            
            for kid in [leftChild[u], rightChild[u]]:
                if kid != -1:
                    if dfs_has_cycle(kid): return True
            
        # FAILED condition (3.) - found a cycle
        if dfs_has_cycle(parent.index(-1)): return False
        
        # FAILED condition (4.) - DFS did not visit all nodes!
        if len(vis) != n: return False
        
        # did not FAIL any condition, success ;)
        return True

""""""
Tricky test case (cycle and not connected):
4
[1,-1,3,-1]
[2,-1,-1,-1]

""""""",yozaam
1362,https://leetcode.com/problems/closest-divisors/discuss/517720/Python3-A-concise-solution,"class Solution:
    def closestDivisors(self, num: int) -> List[int]:
        for i in range(int((num+2)**0.5), 0, -1):
            if not (num+1)%i: return (i, (num+1)//i)
            if not (num+2)%i: return (i, (num+2)//i)",ye15
1366,https://leetcode.com/problems/rank-teams-by-votes/discuss/2129031/python-3-oror-simple-O(n)O(1)-solution,"class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        teamVotes = collections.defaultdict(lambda: [0] * 26)
        for vote in votes:
            for pos, team in enumerate(vote):
                teamVotes[team][pos] += 1
        
        return ''.join(sorted(teamVotes.keys(), reverse=True,
                              key=lambda team: (teamVotes[team], -ord(team))))",dereky4
1367,https://leetcode.com/problems/linked-list-in-binary-tree/discuss/525814/Python3-A-naive-dp-approach,"class Solution:
    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:
        #build longest prefix-suffix array
        pattern, lps = [head.val], [0] #longest prefix-suffix array
        j = 0
        while head.next: 
            head = head.next 
            pattern.append(head.val)
            
            while j and head.val != pattern[j]: j = lps[j-1]
            if head.val == pattern[j]: j += 1
            lps.append(j)
            
        def dfs(root, i): 
            """"""Return True of tree rooted at ""root"" match pattern""""""
            if i == len(pattern): return True
            if not root: return False 
            
            while i > 0 and root.val != pattern[i]: i = lps[i-1]
            if root.val == pattern[i]: i += 1
            return dfs(root.left, i) or dfs(root.right, i)
        
        return dfs(root, 0)",ye15
1368,https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/discuss/1504913/Python-or-Template-or-0-1-BFS-vs-Dijkstra-or-Explanation,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        graph = {}
        m, n = len(grid), len(grid[0])
        
        def addEdges(i, j):
            graph[(i, j)] = {}
            neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]
            for each in neighbors:
                x, y = each
                if x < 0 or y < 0 or x > m - 1 or y > n - 1:
                    continue
                else:
                    graph[(i, j)][(x, y)] = 1
            
            if grid[i][j] == 1:
                if j != n - 1:
                    graph[(i, j)][(i, j + 1)] = 0
            
            elif grid[i][j] == 2:
                if j != 0:
                    graph[(i, j)][(i, j - 1)] = 0
            
            elif grid[i][j] == 3:
                if i != m - 1:
                    graph[(i, j)][(i + 1, j)] = 0
            
            else:
                if i != 0:
                    graph[(i, j)][(i - 1, j)] = 0
                    
        
        for i in range(m):
            for j in range(n):
                addEdges(i, j)
        
		# convert row, col to index value in distances array
        def convert(x, y):
            return x * n + y
        
        def BFS(graph):
            q = deque()
            q.append([0, 0, 0])
            distances = [float(inf)] * (m * n)
            
            while q:
                cost, x, y = q.popleft()
                if (x, y) == (m - 1, n - 1):
                    return cost
                
                idx = convert(x, y)
                if distances[idx] < cost:
                    continue
                
                distances[idx] = cost
                for node, nxtCost in graph[(x, y)].items():
                    nxtIndex = convert(node[0], node[1])
                    if distances[nxtIndex] <= cost + nxtCost:
                        continue
                    
                    distances[nxtIndex] = cost + nxtCost
                    if nxtCost == 0:
                        q.appendleft([cost, node[0], node[1]])
                    else:
                        q.append([cost + 1, node[0], node[1]])
                        
        
        def dijkstra(graph):
            distances = [float(inf)] * (m * n)
            myheap = [[0, 0, 0]]
            #distances[0] = 0
            
            while myheap:
                cost, x, y = heappop(myheap)
                if (x, y) == (m - 1, n - 1):
                    return cost
                
                idx = convert(x, y)
                if distances[idx] < cost:
                    continue
                else:
                    distances[idx] = cost
                    for node, nxtCost in graph[(x, y)].items():
                        total = cost + nxtCost
                        nxtIndex = convert(node[0], node[1])
                        if distances[nxtIndex] <= total:
                            continue
                        else:
                            distances[nxtIndex] = total
                            heappush(myheap, [total, node[0], node[1]])
            
            return distances[-1]
        
        #return dijkstra(graph)
        return BFS(graph)",detective_dp
1370,https://leetcode.com/problems/increasing-decreasing-string/discuss/543172/Python-3-Using-Set-and-Sort-with-commentary,"class Solution:
    def sortString(self, s: str) -> str:
        s = list(s)
        # Big S: O(n)
        result = []
        
        # Logic is capture distinct char with set
        # Remove found char from initial string
        
        # Big O: O(n)
        while len(s) > 0:

            # Big O: O(n log n) Space: O(n)
            smallest = sorted(set(s))
            # Big O: O(s) - reduced set
            for small in smallest:
                result.append(small)
                s.remove(small)
                
            # Big O: O(n log n) Space: O(n)
            largest = sorted(set(s), reverse = True)
            # Big O: O(s) - reduced set
            for large in largest:
                result.append(large)
                s.remove(large)
        
        return ''.join(result)
    
        # Summary:  Big O(n)^2 Space: O(n)",dentedghost
1371,https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/1125562/Python3-bitmask,"class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        ans = mask = 0 
        seen = {0: -1}
        for i, c in enumerate(s):
            if c in ""aeiou"": 
                mask ^= 1 << (""aeiou"".find(c))
            if mask in seen: ans = max(ans, i - seen[mask])
            seen.setdefault(mask, i)
        return ans",ye15
1372,https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/discuss/2559539/Python3-Iterative-DFS-Using-Stack-99-time-91-space-O(N)-time-O(N)-space,"class Solution:
    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        
        LEFT = 0
        RIGHT = 1
            
        stack = []
        if root.left:
            stack.append((root.left, LEFT, 1))
        if root.right:
            stack.append((root.right, RIGHT, 1))
            
        longest = 0
        while stack:
            node, direction, count = stack.pop()
            
            longest = max(longest, count)
            if direction == LEFT:
                if node.left:
                    stack.append((node.left, LEFT, 1))
                if node.right:
                    stack.append((node.right, RIGHT, count+1))
            else:
                if node.right:
                    stack.append((node.right, RIGHT, 1))
                if node.left:
                    stack.append((node.left, LEFT, count+1))
        return longest",rt500
1374,https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts/discuss/1232027/Easy-code-in-python-with-explanation.,"class Solution:
    def generateTheString(self, n: int) -> str:
        a=""a""
        b=""b""
        if n%2==0:
            return (((n-1)*a)+b)
        return (n*a)",souravsingpardeshi
1375,https://leetcode.com/problems/number-of-times-binary-string-is-prefix-aligned/discuss/1330283/Python3-solution-O(n)-time-and-O(1)-space-complexity,"class Solution:
    def numTimesAllBlue(self, light: List[int]) -> int:
        max = count = 0
        for i in range(len(light)):
            if max < light[i]:
                max = light[i]
            if max == i + 1:
                count += 1
        return count",EklavyaJoshi
1377,https://leetcode.com/problems/frog-position-after-t-seconds/discuss/1092590/Python-basic-DFS-from-a-new-grad,"class Solution:

	def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
		if target==1:
			if t>=1 and len(edges)>=1:
				return 0
		adj = collections.defaultdict(list)
		for i in edges:
			adj[min(i[0],i[1])].append(max(i[1],i[0]))

		def traversal(curr, target,t):
			if curr==target:
				if t==0 or len(adj[curr])==0:
					return 1
				return 0
			if t==0:
				return 0
			for child in adj[curr]:
				prob = traversal(child, target, t-1)/len(adj[curr])
				if prob>0: 
					return prob
			return 0
		return traversal(1,target,t)",yb233
1379,https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/discuss/2046151/Python-Simple-2-approaches-Recursion(3-liner)-and-Morris,"class Solution:    
    def getTargetCopy(self, node1: TreeNode, node2: TreeNode, target: TreeNode) -> TreeNode:        
        if not node1 or target == node1:  # if node1 is null, node2 will also be null
            return node2
        
        return self.getTargetCopy(node1.left, node2.left, target) or self.getTargetCopy(node1.right, node2.right, target)",constantine786
1380,https://leetcode.com/problems/lucky-numbers-in-a-matrix/discuss/539748/Python3-store-row-min-and-column-max,"class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        rmin = [min(x) for x in matrix]
        cmax = [max(x) for x in zip(*matrix)]
        return [matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0])) if rmin[i] == cmax[j]]",ye15
1383,https://leetcode.com/problems/maximum-performance-of-a-team/discuss/741822/Met-this-problem-in-my-interview!!!-(Python3-greedy-with-heap),"class Solution:
    def maxPerformance_simple(self, n, speed, efficiency):
        
        people = sorted(zip(speed, efficiency), key=lambda x: -x[1])
        
        result, sum_speed = 0, 0
        
        for s, e in people:
            sum_speed += s
            result = max(result, sum_speed * e)
        
        return result # % 1000000007",dashidhy
1385,https://leetcode.com/problems/find-the-distance-value-between-two-arrays/discuss/2015283/python-3-oror-simple-binary-search-solution,"class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        n = len(arr2)
        arr2.sort()
        res = 0
        
        for num in arr1:
            low, high = 0, n - 1
            while low <= high:
                mid = (low + high) // 2
                if abs(num - arr2[mid]) <= d:
                    break
                elif num < arr2[mid]:
                    high = mid - 1
                else:
                    low = mid + 1
            else:
                res += 1
        
        return res",dereky4
1386,https://leetcode.com/problems/cinema-seat-allocation/discuss/1124736/Python3-bitmask,"class Solution:
    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
        seats = {}
        for i, j in reservedSeats: 
            if i not in seats: seats[i] = 0
            seats[i] |= 1 << j-1
        
        ans = 2 * (n - len(seats))
        for v in seats.values(): 
            if not int(""0111111110"", 2) &amp; v: ans += 2
            elif not int(""0111100000"", 2) &amp; v: ans += 1
            elif not int(""0001111000"", 2) &amp; v: ans += 1
            elif not int(""0000011110"", 2) &amp; v: ans += 1
        return ans",ye15
1387,https://leetcode.com/problems/sort-integers-by-the-power-value/discuss/1597631/Python-using-sorted-function,"class Solution:
    def getpower(self,num):
        p=0
        while(num!=1):
            if num%2==0:
                num=num//2
                
            else:
                num=(3*num)+1
            p+=1
            
        return p
             
    def getKth(self, lo: int, hi: int, k: int) -> int:
        
        temp=sorted(range(lo,hi+1),key=lambda x:self.getpower(x))
        return temp[k-1]
		```",PrimeOp
1388,https://leetcode.com/problems/pizza-with-3n-slices/discuss/1124752/Python3-top-down-dp,"class Solution:
    def maxSizeSlices(self, slices: List[int]) -> int:
        
        @cache
        def fn(i, k, first): 
            """"""Return max sum of k pieces from slices[i:].""""""
            if k == 0: return 0 
            if i >= len(slices) or first and i == len(slices)-1: return -inf 
            if i == 0: return max(fn(i+1, k, False), slices[i] + fn(i+2, k-1, True))
            return max(fn(i+1, k, first), slices[i] + fn(i+2, k-1, first))
        
        return fn(0, len(slices)//3, None)",ye15
1389,https://leetcode.com/problems/create-target-array-in-the-given-order/discuss/1163965/Python3-Simple-Solution,"class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        ans = []
        
        for i in range(len(nums)):
            ans.insert(index[i] , nums[i])
        
        return ans",VoidCupboard
1390,https://leetcode.com/problems/four-divisors/discuss/547308/Python3-Short-Easy-Solution,"class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        res = 0
        for num in nums:
            divisor = set() 
            for i in range(1, floor(sqrt(num)) + 1):
                if num % i == 0:
                    divisor.add(num//i)
                    divisor.add(i)
                if len(divisor) > 4:    
                    break
                    
            if len(divisor) == 4:
                res += sum(divisor)
        return res",localhostghost
1391,https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/discuss/635713/Python3-dfs-solution-Check-if-There-is-a-Valid-Path-in-a-Grid,"class Solution:
    directions = [[-1, 0], [0, 1], [1, 0], [0, -1]]
    streetDirections = {
       1: [1, 3],
       2: [0, 2],
       3: [2, 3],
       4: [1, 2],
       5: [0, 3],
       6: [0, 1]
    }
    def hasValidPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        def dfs(i: int, j: int, oppositeDirection: int) -> None:
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] < 0:
                return
            v = grid[i][j]
            sd = Solution.streetDirections[v]
            direction = (oppositeDirection + 2) % 4
            if direction not in sd:
                return
            grid[i][j] = -v
            for d in sd:
                delta = Solution.directions[d]
                dfs(i+delta[0], j+delta[1], d)
        dfs(0, 0, 0)
        dfs(0, 0, 3)
        return grid[m-1][n-1] < 0",r0bertz
1392,https://leetcode.com/problems/longest-happy-prefix/discuss/2814375/Dynamic-programming-solution,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n = [0] + [None] * (len(s) - 1)

        for i in range(1, len(s)):
            k = n[i - 1] # trying length k + 1
            while (k > 0) and (s[i] != s[k]):
                k = n[k - 1]
            if s[i] == s[k]:
                k += 1
            n[i] = k
        happy_border = n[-1]
        return s[:happy_border]",aknyazev87
1395,https://leetcode.com/problems/count-number-of-teams/discuss/1465532/Python-or-O(n2)-or-Slow-but-very-easy-to-understand-or-Explanation,"class Solution:
    def numTeams(self, rating: List[int]) -> int:
        
        dp = [[1, 0, 0] for i in range(len(rating))]
        
        for i in range(1, len(rating)):
            for j in range(i):
                if rating[i] > rating[j]:
                    dp[i][1] += dp[j][0]
                    dp[i][2] += dp[j][1]
        
        a = sum(dp[i][2] for i in range(len(dp)))
        #print(a)

        dp = [[1, 0, 0] for i in range(len(rating))]
        
        for i in range(1, len(rating)):
            for j in range(i):
                if rating[i] < rating[j]:
                    dp[i][1] += dp[j][0]
                    dp[i][2] += dp[j][1]
        
        b = sum(dp[i][2] for i in range(len(dp)))
        
        return a + b",detective_dp
1397,https://leetcode.com/problems/find-all-good-strings/discuss/1133347/Python3-dp-and-kmp-...-finally,"class Solution:
    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
        lps = [0]
        k = 0 
        for i in range(1, len(evil)): 
            while k and evil[k] != evil[i]: k = lps[k-1]
            if evil[k] == evil[i]: k += 1
            lps.append(k)
        
        @cache
        def fn(i, k, lower, upper): 
            """"""Return number of good strings at position i and k prefix match.""""""
            if k == len(evil): return 0 # boundary condition 
            if i == n: return 1 
            lo = ascii_lowercase.index(s1[i]) if lower else 0
            hi = ascii_lowercase.index(s2[i]) if upper else 25
            
            ans = 0
            for x in range(lo, hi+1): 
                kk = k 
                while kk and evil[kk] != ascii_lowercase[x]: 
                    kk = lps[kk-1]
                if evil[kk] == ascii_lowercase[x]: kk += 1
                ans += fn(i+1, kk, lower and x == lo, upper and x == hi)
            return ans 
        
        return fn(0, 0, True, True) % 1_000_000_007",ye15
1399,https://leetcode.com/problems/count-largest-group/discuss/660765/Python-DP-O(N)-99100,"class Solution:

    def countLargestGroup(self, n: int) -> int:
        dp = {0: 0}
        counts = [0] * (4 * 9)
        for i in range(1, n + 1):
            quotient, reminder = divmod(i, 10)
            dp[i] = reminder + dp[quotient]
            counts[dp[i] - 1] += 1

        return counts.count(max(counts))",xshoan
1400,https://leetcode.com/problems/construct-k-palindrome-strings/discuss/1806250/Python-Solution,"class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        if k > len(s):
            return False
        dic = {}
        
        for i in s:
            if i not in dic:
                dic[i] = 1
            else:
                dic[i] += 1
        c = 0        
        for i in dic.values():
            if i % 2 == 1:
                c += 1
        
        if c > k:
            return False
        return True",MS1301
1401,https://leetcode.com/problems/circle-and-rectangle-overlapping/discuss/639682/Python3-two-solutions-Circle-and-Rectangle-Overlapping,"class Solution:
    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:
        x = 0 if x1 <= x_center <= x2 else min(abs(x1-x_center), abs(x2-x_center))
        y = 0 if y1 <= y_center <= y2 else min(abs(y1-y_center), abs(y2-y_center))
        return x**2 + y**2 <= radius**2",r0bertz
1402,https://leetcode.com/problems/reducing-dishes/discuss/2152786/python-3-oror-simple-sorting-solution,"class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction.sort(reverse=True)
        maxSatisfaction = dishSum = 0

        for dish in satisfaction:
            dishSum += dish
            if dishSum <= 0:
                break
            maxSatisfaction += dishSum
        
        return maxSatisfaction",dereky4
1403,https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/discuss/1041468/Python3-simple-solution,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        nums.sort()
        l = []
        while sum(l) <= sum(nums):
            l.append(nums.pop())
        return l",EklavyaJoshi
1404,https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/discuss/2809472/Python3-Solution-or-One-Line,"class Solution:
    def numSteps(self, s):
        return len(s) + s.rstrip('0').count('0') + 2 * (s.count('1') != 1) - 1",satyam2001
1405,https://leetcode.com/problems/longest-happy-string/discuss/1226968/Python-9-line-greedy-solution-by-using-Counter,"class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        count = collections.Counter({'a':a, 'b':b, 'c':c})
        res = ['#']
        while True:
            (a1, _), (a2, _) = count.most_common(2)
            
            if a1 == res[-1] == res[-2]:
                a1 = a2
                
            if not count[a1]:
                break
                
            res.append(a1)
            count[a1] -= 1            
        
        return ''.join(res[1:])",licpotis
1406,https://leetcode.com/problems/stone-game-iii/discuss/815655/Python3-beats-93-DP,"class Solution(object):
    def stoneGameIII(self, stoneValue):
        """"""
        :type stoneValue: List[int]
        :rtype: str
        """"""
        
        dp = [0 for _ in range(len(stoneValue))]
        if len(dp) >= 1:
            dp[-1] = stoneValue[-1]
        if len(dp) >= 2:
            dp[-2] = max(stoneValue[-1] + stoneValue[-2], stoneValue[-2] - dp[-1])
        if len(dp) >= 3:
            dp[-3] = max(stoneValue[-3] + stoneValue[-1] + stoneValue[-2], stoneValue[-3] - dp[-2], stoneValue[-3] + stoneValue[-2] - dp[-1])
        
        for i in range(len(stoneValue) - 4, -1, -1):
            
            dp[i] = max([sum(stoneValue[i: i + j]) - dp[i + j] for j in range(1, 4)])
        
        if dp[0] > 0:
            return ""Alice""
        if dp[0] == 0:
            return ""Tie""
        return ""Bob""",ethuoaiesec
1408,https://leetcode.com/problems/string-matching-in-an-array/discuss/575147/Clean-Python-3-suffix-trie-O(NlogN-%2B-N-*-S2),"class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        def add(word: str):
            node = trie
            for c in word:
                node = node.setdefault(c, {})

        def get(word: str) -> bool:
            node = trie
            for c in word:
                if (node := node.get(c)) is None: return False
            return True

        words.sort(key=len, reverse=True)
        trie, result = {}, []
        for word in words:
            if get(word): result.append(word)
            for i in range(len(word)):
                add(word[i:])
        return result",lenchen1112
1409,https://leetcode.com/problems/queries-on-a-permutation-with-key/discuss/1702309/Understandable-code-for-beginners-in-python!!!,"class Solution:
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        permuteArr=[i for i in range(1,m+1)]
        query_len=len(queries)
        answer=[]
        left,right=[],[]
        for query in range(query_len):
            index=permuteArr.index(queries[query])
            answer.append(index)
            left=permuteArr[:index]
            right=permuteArr[index+1:]
            permuteArr=[permuteArr[index]]+left+right
        return answer",kabiland
1410,https://leetcode.com/problems/html-entity-parser/discuss/575248/Python-sol-by-replace-and-regex.-85%2B-w-Hint,"class Solution:
    def entityParser(self, text: str) -> str:
        
        html_symbol = [ '&amp;quot;', '&amp;apos;', '&amp;gt;', '&amp;lt;', '&amp;frasl;', '&amp;amp;']
        formal_symbol = [ '""', ""'"", '>', '<', '/', '&amp;']
                
        for html_sym, formal_sym in zip(html_symbol, formal_symbol):
            text = text.replace( html_sym , formal_sym )
        
        return text",brianchiang_tw
1411,https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/discuss/1648004/dynamic-programming-32ms-beats-99.44-in-Python,"class Solution:
    def numOfWays(self, n: int) -> int:
        mod = 10 ** 9 + 7
        two_color, three_color = 6, 6
        for _ in range(n - 1):
            two_color, three_color = (two_color * 3 + three_color * 2) % mod, (two_color * 2 + three_color * 2) % mod
        return (two_color + three_color) % mod",kryuki
1413,https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/discuss/1431774/2-Lines-Easy-Python-Solution,"class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        
        for i in range(1, len(nums)): nums[i] = nums[i] + nums[i - 1]
        
        return 1 if min(nums) >= 1 else abs(min(nums)) + 1",caffreyu
1414,https://leetcode.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/discuss/1341772/Python3-easy-solution-using-recursion,"class Solution:
    def findMinFibonacciNumbers(self, n: int) -> int:
        def check(z):
            key = [1,1]
            while key[-1] + key[-2] <= z:
                key.append(key[-1]+key[-2])
            print(key,z)
            if z in key:
                return 1
            return 1 + check(z-key[-1])
        return check(n)",EklavyaJoshi
1415,https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/discuss/1420200/Python3-or-Ez-for-loop-solves-ALL!-With-detailed-comments-and-graphical-examples,"class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        
        char = [""a"", ""b"", ""c""]  
        
        # Edge case, n = 1
        if n == 1: return char[k - 1] if k <= 3 else """"
        
        # There will be $part$ number of strings starting with each character (a, b, c)
        part = 2 ** (n - 1)
        
        # If k is too large
        if k > part * 3: return """"
        
        res = []
        
        # Edge case is k = n * i, where i is an integer in range [1, 3]
        res.append(char[k // part if k % part != 0 else k // part - 1])
        k = k % part if k % part != 0 else part
        
        for i in range(n - 2, -1, -1):
            char = [""a"", ""b"", ""c""]  
            char.remove(res[-1])        # Make sure the adjacent characters will be different
            
            if len(res) + 1 == n:       # Edge case, assigning the last element
                if k == 1: res.append(char[0])
                elif k == 2: res.append(char[-1])
            elif k > 2 ** i:            # Go to the right side
                res.append(char[-1])
                k -= 2 ** i       
            else: res.append(char[0])   # Go to the left side
        
        return """".join(res)",caffreyu
1416,https://leetcode.com/problems/restore-the-array/discuss/1165871/python-or-simple-dp,"class Solution(object):
    def numberOfArrays(self, s, k):
        n=len(s)
        new=[0]*n
        new[0]=1
        m=len(str(k))
        for i in range(1,n):
            for j in range(max(0,i-m+1),i+1):
                if s[j]!=""0"" and int(s[j:i+1])<=k:
                    if j==0:
                        new[i]=1
                    else:
                        new[i]+=new[j-1]
                #print(new)
        
        return new[-1]%(10**9+7)",heisenbarg
1420,https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/discuss/2785539/Python-DP-cleaner-than-most-answers,"class Solution:
    def numOfArrays(self, n: int, m: int, K: int) -> int:
        MOD = 10 ** 9 + 7
        # f[i][j][k] cumulative sum, first i elements, current max less than or equal to j, k more maximum to fill
        f = [[[0 for _ in range(K + 1)] for _ in range(m + 1)] for _ in range(n + 1)]
        for j in range(m + 1):
            f[0][j][K] = 1

        for i in range(n + 1):
            for j in range(1, m + 1):
                for k in range(K):
                    #             prev value       a[i] <= pref high                            a[i] = j refresh high
                    f[i][j][k] = (f[i][j - 1][k] + j * (f[i - 1][j][k] - f[i - 1][j - 1][k]) + f[i - 1][j - 1][k + 1]) % MOD
        
        return f[n][m][0]",chaosrw
1422,https://leetcode.com/problems/maximum-score-after-splitting-a-string/discuss/597944/Python3-linear-scan,"class Solution:
    def maxScore(self, s: str) -> int:
        zeros = ones = 0
        ans = float(""-inf"")
        
        for i in range(len(s)-1):
            if s[i] == ""0"": zeros += 1
            else: ones -= 1
            ans = max(ans, zeros + ones)
        
        return ans - ones + (1 if s[-1] == ""1"" else 0)",ye15
1423,https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/discuss/2197728/Python3-O(n)-Clean-and-Simple-Sliding-Window-Solution,"class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        n = len(cardPoints)
        total = sum(cardPoints)
        
        remaining_length = n - k
        subarray_sum = sum(cardPoints[:remaining_length])
        
        min_sum = subarray_sum
        for i in range(remaining_length, n):
            # Update the sliding window sum to the subarray ending at index i
            subarray_sum += cardPoints[i]
            subarray_sum -= cardPoints[i - remaining_length]
            # Update min_sum to track the overall minimum sum so far
            min_sum = min(min_sum, subarray_sum)
        return total - min_sum",TLDRAlgos
1424,https://leetcode.com/problems/diagonal-traverse-ii/discuss/1866412/Python-easy-to-read-and-understand-or-hashmap,"class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        d = collections.defaultdict(list)
        
        for i in range(len(nums)):
            for j in range(len(nums[i])):
                d[(i+j)].append(nums[i][j])
        
        
        ans = []
        for key in d:
            ans += d[key][::-1]
        
        return ans",sanial2001
1425,https://leetcode.com/problems/constrained-subsequence-sum/discuss/2672473/Python-or-Deque,"class Solution:
    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [0]*n
        q = deque()

        for i, num in enumerate(nums):
            if i > k and q[0] == dp[i-k-1]:
                q.popleft()
            dp[i] = max(q[0] if q else 0, 0)+num

            while q and q[-1] < dp[i]:
                q.pop()
            q.append(dp[i])
        return max(dp)",jainsiddharth99
1431,https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/discuss/2269844/Python-3-ONE-LINER,"class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        return [x+extraCandies >= max(candies) for x in candies]",omkarxpatel
1432,https://leetcode.com/problems/max-difference-you-can-get-from-changing-an-integer/discuss/608687/Python3-scan-through-digits,"class Solution:
    def maxDiff(self, num: int) -> int:
        num = str(num)
        
        i = next((i for i in range(len(num)) if num[i] != ""9""), -1) #first non-9 digit
        hi = int(num.replace(num[i], ""9""))
        
        if num[0] != ""1"": lo = int(num.replace(num[0], ""1""))
        else: 
            i = next((i for i in range(len(num)) if num[i] not in ""01""), -1)
            lo = int(num.replace(num[i], ""0"") if i > 0 else num)
            
        return hi - lo",ye15
1433,https://leetcode.com/problems/check-if-a-string-can-break-another-string/discuss/1415509/ONLY-CODE-N-log-N-sort-and-compare-%3A)-clean-3-liner-and-then-1-liner,"class Solution:
    def checkIfCanBreak(self, s1: str, s2: str) -> bool:
        return all(a<=b for a,b in zip(min(sorted(s1),sorted(s2)),max(sorted(s1),sorted(s2))))```",yozaam
1434,https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/discuss/608721/Python-dp-with-bit-mask-memorization,"class Solution:
    def numberWays(self, hats: List[List[int]]) -> int:
        n = len(hats)
        h2p = collections.defaultdict(list)
        for p, hs in enumerate(hats):
            for h in hs:
                h2p[h].append(p)
        full_mask = (1 << n) - 1
        mod = 10**9 + 7
        @functools.lru_cache(maxsize=None)
        def count(h, mask):
		    # everyone wears a hat
            if mask == full_mask:
                return 1
			# ran out of hats
            if h == 41:
                return 0
			# skip the current hat h
            ans = count(h + 1, mask)
            for p in h2p[h]:
			    # if person p already has a hat
                if mask &amp; (1 << p):
                    continue
				# let person p wear hat h
                ans += count(h + 1, mask | (1 << p))
                ans %= mod
            return ans
		# start from the first hat and no one wearing any hat
        return count(1, 0)",ChelseaChenC
1436,https://leetcode.com/problems/destination-city/discuss/1664716/98-faster-easy-python-solution-based-on-question-no.-997,"class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        lst=[]
        arr=[]
        for i in paths:
            lst.append(i[0])
            arr.append(i[1])
        ptr=set(lst)
        ptr2=set(arr)
        return list(ptr2-ptr)[0]",amannarayansingh10
1437,https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/discuss/609823/Python-O(n)-Easy-(For-Loop-List-Comprehension),"class Solution:
    def kLengthApart(self, nums: List[int], k: int) -> bool:
        indices = [i for i, x in enumerate(nums) if x == 1]
        if not indices:
            return True
        for i in range(1, len(indices)):
            if indices[i] - indices[i-1] < k + 1:
                return False
        return True",sonaksh
1438,https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/2798749/nlogn-solution-by-this-dude,"class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        #[8,2,4,3,6,11] limit = 5

        #if the new number is greater than max this becomes new max,
        #if new number is less than min this becomes new min
        #if max - min exceeds limit, pop the left most element -> if the left most element was max or min, recompute max - min and see if it goes limit

        q = []
        min_heap = []
        max_heap = []
        max_ans = 1
        popped_index = set()

        for i,v in enumerate(nums):

            q.append((v,i))
            # max_ans = max(max_ans,len(q))
            heapq.heappush(min_heap,(v,i))
            heapq.heappush(max_heap,(v*-1,i))
            while(max_heap[0][0]*-1 - min_heap[0][0] > limit):
                temp = q.pop(0)
                popped_ele = temp[0]
                popped_index.add(temp[1])

                while(min_heap[0][1] in popped_index):
                    heapq.heappop(min_heap)
                
                while(max_heap[0][1] in popped_index):
                    heapq.heappop(max_heap)

            if len(q) > max_ans:
                max_ans = len(q)

        return max_ans",ariboi27
1439,https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/discuss/1928887/Python3-or-O(m-*-knlogkn),"class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        row=len(mat)
        col=len(mat[0])
        temp=[i for i in mat[0]]
        for i in range(1,row):
            currSum=[]
            for j in range(col):
                for it in range(len(temp)):
                    currSum.append(temp[it]+mat[i][j])
            currSum.sort()
            temp.clear()
            maxSize=min(k,len(currSum))
            for size in range(maxSize):
                temp.append(currSum[size])
        return temp[k-1]",swapnilsingh421
1441,https://leetcode.com/problems/build-an-array-with-stack-operations/discuss/1291707/Easy-Python-Solution(96.97),"class Solution:
    def buildArray(self, target: List[int], n: int) -> List[str]:
        stack=[]
        for i in range(1,n+1):
            if(i in target):
                stack.append(""Push"")
            else:
                stack.append(""Push"")
                stack.append(""Pop"")
            if(i==(target[-1])):
                break
        return stack",Sneh17029
1442,https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/discuss/1271870/Python-O(n)-hash-table,"class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        import collections
        if len(arr) < 2:
            return 0
        xors = arr[0]
        cnt = collections.Counter()
        cnt_sums = collections.Counter()        
        result = 0
        cnt[xors] = 1
        cnt_sums[xors] = 0
        for k in range(1, len(arr)):
            xors ^= arr[k]
            if xors == 0:
                result += k
            result += (k - 1)*cnt[xors] - cnt_sums[xors]
            cnt_sums[xors] += k
            cnt[xors] += 1
            
        return result",CiFFiRO
1443,https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/discuss/1460342/Python-Recursive-DFS-Solution-with-detailed-explanation-in-comments,"class Solution:
    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        self.res = 0
        d = collections.defaultdict(list)
        
        for e in edges: # construct the graph
            d[e[0]].append(e[1])
            d[e[1]].append(e[0])
            
        seen = set() # initialise seen set for visited nodes
        seen.add(0) # add root to visited
        
        def dfs(key):
            # we initialize the go_thru state as 0, meaning we do not go through this node from root
            # there are two cases where we would set go_thru == 1: 
            #(1) when this is the apple node, so we must visit it and go back up
            #(2) when this node has apple nodes as descendants below, we must go down and come back
            go_thru = 0 
            if hasApple[key]: # case 1
                go_thru = 1
    
            for i in d[key]:
                if i not in seen:
                    seen.add(i)
                    a = dfs(i)    
                    if a: # case 2, note that having just one path with an apple node below would require us to go through our current node, 
						  # i.e we don't need both the paths to have apples
                        go_thru = 1
            
            if key != 0: # since 0 is already the root, there is no way we can go through 0 to a node above
                self.res += 2 * go_thru # passing one node means forward and backward, so 1 * 2 for going through, 0 * 2 for not
            return go_thru
        
        dfs(0)
        return self.res",lukefall425
1444,https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/discuss/2677389/Python3-or-Space-Optimized-Bottom-Up-DP-or-O(k-*-r-*-c-*-(r-%2B-c))-Time-O(r-*-c)-Space,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        rows, cols = len(pizza), len(pizza[0])
        
        # first, need way to query if a section contains an apple given a top left (r1, c1) and bottom right (r2, c2)
        # we can do this in constant time by keeping track of the number of apples above and to the left of any given cell
        apples = [[0] * cols for _ in range(rows)]
        for row in range(rows):
            apples_left = 0
            for col in range(cols):
                if pizza[row][col] == 'A':
                    apples_left += 1
                apples[row][col] = apples[row-1][col] + apples_left
              
        # query if there is an apple in this rectangle using the prefix sums
        def has_apple(r1, c1, r2 = rows-1, c2 = cols-1) -> bool:
            if r1 > r2 or c1 > c2:
                return False
            tot = apples[r2][c2]
            left_sub = apples[r2][c1-1] if c1 > 0 else 0
            up_sub = apples[r1-1][c2] if r1 > 0 else 0
            upleft_sub = apples[r1-1][c1-1] if r1 > 0 < c1 else 0
            in_rect = tot - left_sub - up_sub + upleft_sub
            return in_rect > 0
        
        # memory optimized dp, keep track of only one matrix of rows x cols
        # bc we only need to access the values at the previous number of cuts
        dp = [[1 if has_apple(r, c) else 0 for c in range(cols + 1)] for r in range(rows + 1)]
        
        for cuts in range(1, k):
            new_dp = [[0] * (cols + 1) for _ in range(rows + 1)]
            for row in range(rows-1, -1, -1):
                for col in range(cols-1, -1, -1):
                    
                    for r2 in range(row, rows):
                        if has_apple(row, col, r2):
                            new_dp[row][col] += dp[r2+1][col]
                            
                    for c2 in range(col, cols):
                        if has_apple(row, col, rows-1, c2):
                            new_dp[row][col] += dp[row][c2+1]
            dp = new_dp
                            
        return dp[0][0] % (10**9 + 7)",ryangrayson
1446,https://leetcode.com/problems/consecutive-characters/discuss/637217/Python-O(n)-by-linear-scan.-w-Comment,"class Solution:
    def maxPower(self, s: str) -> int:
        
        # the minimum value for consecutive is 1
        local_max, global_max = 1, 1
        
        # dummy char for initialization
        prev = '#'
        for char in s:
            
            if char == prev:
                
                # keeps consecutive, update local max
                local_max += 1
                
                # update global max length with latest one
                global_max = max( global_max, local_max )
                
            else:
                
                # lastest consective chars stops, reset local max
                local_max = 1
            
                # update previous char as current char for next iteration
                prev = char
        
        
        return global_max",brianchiang_tw
1447,https://leetcode.com/problems/simplified-fractions/discuss/1336226/Python3-solution-using-set,"class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        if n == 1:
            return []
        else:
            numerator = list(range(1,n))
            denominator = list(range(2,n+1))
            res = set()
            values = set()
            for i in numerator:
                for j in denominator:
                    if i < j and i/j not in values:
                        res.add(f'{i}/{j}')
                        values.add(i/j)
            return res",EklavyaJoshi
1448,https://leetcode.com/problems/count-good-nodes-in-binary-tree/discuss/2511520/C%2B%2B-or-PYTHON-oror-EXPLAINED-oror,"class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        def solve(root,val):
            if root:
                k = solve(root.left, max(val,root.val)) + solve(root.right, max(val,root.val))
                if root.val >= val:
                    k+=1
                return k
            return 0
        return solve(root,root.val)",karan_8082
1449,https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/discuss/1113027/Python3-top-down-dp,"class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        
        @cache
        def fn(x): 
            """"""Return max integer given target x.""""""
            if x == 0: return 0
            if x < 0: return -inf 
            return max(fn(x - c) * 10 + i + 1 for i, c in enumerate(cost))
        
        return str(max(0, fn(target)))",ye15
1450,https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/discuss/1817462/Python-Simple-Solution-or-Zip-and-Iterate-86-37ms,"class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        count = 0 # If a value meets the criteria, one will be added here.

        for x, y in zip(startTime, endTime): # Zipping the two lists to allow us to iterate over them using x,y as our variables.
            if x <= queryTime <= y: # Checking if the queryTime number is between startTime and endTime, adding one to count if it is.
                    count += 1
        return count # Returning the value in count",IvanTsukei
1451,https://leetcode.com/problems/rearrange-words-in-a-sentence/discuss/636348/Python3-one-line,"class Solution:
    def arrangeWords(self, text: str) -> str:
        return "" "".join(sorted(text.split(), key=len)).capitalize()",ye15
1452,https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/discuss/2827639/Python-or-Dictionary-%2B-Bitwise-operation,"class Solution:
    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:

        n = len(favoriteCompanies)
        comp = []
        for f in favoriteCompanies:
            comp += f
        comp = list(set(comp))
  
        dictBit = {comp[i] : 1 << i for i in range(len(comp))}

        def getBit(cList):
            output = 0
            for c in cList:
                output |= dictBit[c]
            return output
        bitFav = [getBit(favoriteCompanies[i]) for i in range(n)]

        output = []
        for i in range(n):
            isGood = True
            for j in range(n):
                if(i != j and bitFav[i] &amp; bitFav[j] == bitFav[i]):
                    isGood = False
                    break
            if(isGood):
                output.append(i)
    
        return output",CosmosYu
1453,https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/discuss/636439/Python3-angular-sweep-O(N2-logN),"class Solution:
    def numPoints(self, points: List[List[int]], r: int) -> int:
        ans = 1
        for x, y in points: 
            angles = []
            for x1, y1 in points: 
                if (x1 != x or y1 != y) and (d:=sqrt((x1-x)**2 + (y1-y)**2)) <= 2*r: 
                    angle = atan2(y1-y, x1-x)
                    delta = acos(d/(2*r))
                    angles.append((angle-delta, +1)) #entry
                    angles.append((angle+delta, -1)) #exit
            angles.sort(key=lambda x: (x[0], -x[1]))
            val = 1
            for _, entry in angles: 
                ans = max(ans, val := val+entry)
        return ans",ye15
1455,https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/discuss/1170901/Python3-Simple-And-Readable-Solution-With-Explanation,"class Solution:
    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
        for i , j in enumerate(sentence.split()):
            if(j.startswith(searchWord)):
                return i + 1
        
        return -1",VoidCupboard
1456,https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/discuss/1504290/Python3-simple-soluton,"class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        x = 0
        for i in range(k):
            if s[i] in ('a', 'e', 'i', 'o', 'u'):
                x += 1
        ans = x
        for i in range(k,len(s)):
            if s[i] in ('a', 'e', 'i', 'o', 'u'):
                x += 1
            if s[i-k] in ('a', 'e', 'i', 'o', 'u'):
                x -= 1
            ans = max(ans,x)
        return ans",EklavyaJoshi
1457,https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/discuss/2573237/LeetCode-The-Hard-Way-Explained-Line-By-Line,"class Solution:
    def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:
        if not root: return 0
        cnt ^= 1 << (root.val - 1)
        if root.left is None and root.right is None:
            return 1 if cnt &amp; (cnt - 1) == 0 else 0
        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)",wingkwong
1458,https://leetcode.com/problems/max-dot-product-of-two-subsequences/discuss/2613290/Python-Solution-or-DP-or-LCS,"class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        m=len(nums2)
        
        dp=[[0]*(m+1) for i in range(n+1)]
        for i in range(m+1):
            dp[0][i]=-1e9
        for i in range(n+1):
            dp[i][0]=-1e9
        
        for i in range(1, n+1):
            for j in range(1, m+1):
                val=nums1[i-1]*nums2[j-1]+max(0, dp[i-1][j-1])
                dp[i][j]=max(val, max(dp[i-1][j], dp[i][j-1]))
        return dp[n][m]",Siddharth_singh
1460,https://leetcode.com/problems/make-two-arrays-equal-by-reversing-subarrays/discuss/2730962/Easy-solution-using-dictionary-in-python,"class Solution:
    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:
        n, m = len(target), len(arr)
        if m > n:
            return False
        t = Counter(target)
        a = Counter(arr)
        for k, v in a.items():
            if k in t and v == t[k]:
                continue
            else:
                return False
        return True",ankurbhambri
1461,https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/discuss/2092441/Python-oror-2-Easy-oror-One-liner-with-explanation,"class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:                
        return len({s[i:i+k] for i in range(len(s)-k+1)}) == 2 ** k",constantine786
1462,https://leetcode.com/problems/course-schedule-iv/discuss/2337629/Python3-or-Solved-Using-Ancestors-of-every-DAG-Graph-Node-approach(Kahn's-Algo-BFS),"class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        #Let m = len(prereqs) and z = len(queries)
        #Time: O(m + n + n*n + z) -> O(n^2)
        #Space: O(n*n + n + n*n + n + z) -> O(n^2)
        
        
        #process the prerequisites and build an adjacency list graph
        #where edges go from prerequisite to the course that depends on the prereq!
        n = numCourses
        #Adjacency List graph!
        adj = [set() for _ in range(n)]
        #indegrees array!
        indegrees = [0] * n
        #tell us every ith node's set of ancestors or all prereqs to take ith course!
        ancestors = [set() for _ in range(n)]
        #iterate through prereqs and update indegrees array as well as the adj list!
        for i in range(len(prerequisites)):
            prereq, main = prerequisites[i][0], prerequisites[i][1]
            adj[prereq].add(main)
            indegrees[main] += 1
        
        queue = deque()
        #iterate through the indegrees array and add all courses that have no 
        #ancestors(no prerequisites to take it!)
        for a in range(len(indegrees)):
            #ath course can be taken without any prereqs -> first to be processed in
            #the Kahn's BFS algo!
            if(indegrees[a] == 0):
                queue.append(a)
        #proceed with Kahn's algo!
        while queue:
            cur_course = queue.pop()
            neighbors = adj[cur_course]
            for neighbor in neighbors:
                #neighbor has one less incoming edge!
                indegrees[neighbor] -= 1
                #current course is a prerequisite to every neighboring node!
                ancestors[neighbor].add(cur_course)
                #but also, all prereqs of cur_course is also indirectly a prereq
                #to each and every neighboring courses!
                ancestors[neighbor].update(ancestors[cur_course])
                #if neighboring node suddenly becomes can take with no prereqs,
                #add it to the queue!
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        #once the algorithm ends, our ancestors array will have info regarding
        #prerequisites in order to take every course from 0 to n-1!
        output = []
        for query in queries:
            prereq2, main2 = query[0], query[1]
            all_prereqs = ancestors[main2]
            #check if prereq2 is an ancestor or required prereq course to take main2!
            if(prereq2 in all_prereqs):
                output.append(True)
                continue
            else:
                output.append(False)
                
        
        return output",JOON1234
1463,https://leetcode.com/problems/cherry-pickup-ii/discuss/1674033/Python3-DYNAMIC-PROGRAMMING-(*)-Explained,"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        
        dp = [[[0]*(cols + 2) for _ in range(cols + 2)] for _ in range(rows + 1)]
        
        def get_next_max(row, col_r1, col_r2):
            res = 0
            for next_col_r1 in (col_r1 - 1, col_r1, col_r1 + 1):
                for next_col_r2 in (col_r2 - 1, col_r2, col_r2 + 1):
                    res = max(res, dp[row + 1][next_col_r1 + 1][next_col_r2 + 1])

            return res
        
        for row in reversed(range(rows)):
            for col_r1 in range(min(cols, row + 2)):
                for col_r2 in range(max(0, cols - row - 1), cols):

                    reward = grid[row][col_r1] + grid[row][col_r2]
                    if col_r1 == col_r2:
                        reward /= 2
                    
                    dp[row][col_r1 + 1][col_r2 + 1] = reward + get_next_max(row, col_r1, col_r2)
                    
        return dp[0][1][cols]",artod
1464,https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/discuss/1975858/Python-3-greater-Using-heap,"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        # approach 1: find 2 max numbers in 2 loops. T = O(n). S = O(1)
		# approach 2: sort and then get the last 2 max elements. T = O(n lg n). S = O(1)
		# approach 3: build min heap of size 2. T = O(n lg n). S = O(1)
		# python gives only min heap feature. heaq.heappush(list, item). heapq.heappop(list)
        
        heap = [-1]
        for num in nums:
            if num > heap[0]:
                if len(heap) == 2:
                    heapq.heappop(heap)
                heapq.heappush(heap, num)
                
        return (heap[0]-1) * (heap[1]-1)",mybuddy29
1465,https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/discuss/2227297/Python-easy-solution,"class Solution:
    def maxArea(self, h: int, w: int, hc: List[int], vc: List[int]) -> int:
        
        hc.sort()
        vc.sort()
        
        maxh = hc[0]
        maxv = vc[0]
        
        for i in range(1, len(hc)):
            maxh = max(maxh, hc[i] - hc[i-1])
        maxh = max(maxh, h - hc[-1])
        
        for i in range(1, len(vc)):
            maxv = max(maxv, vc[i] - vc[i-1])
        maxv = max(maxv, w - vc[-1])
        
        return maxh*maxv % (10**9 + 7)",lokeshsenthilkumar
1466,https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/discuss/1071235/Pythonor-Easy-and-fast-or-Beats-99,"class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        cmap = {0}
        count = 0
        dq = deque(connections)
        while dq:
            u, v = dq.popleft()
            if v in cmap:
                cmap.add(u)
            elif u in cmap:
                cmap.add(v)
                count += 1
            else:
                dq.append([u, v])
        return count",SlavaHerasymov
1467,https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/discuss/1214891/Python3-top-down-dp,"class Solution:
    def getProbability(self, balls: List[int]) -> float:
        n = sum(balls)//2
        
        @cache 
        def fn(i, s0, s1, c0, c1):
            """"""Return number of ways to distribute boxes successfully (w/o considering relative order).""""""
            if s0 > n or s1 > n: return 0 # impossible 
            if i == len(balls): return int(c0 == c1)
            ans = 0 
            for x in range(balls[i]+1): 
                ans += fn(i+1, s0+x, s1+balls[i]-x, c0+(x > 0), c1+(x < balls[i])) * comb(balls[i], x)
            return ans
        
        return fn(0, 0, 0, 0, 0) / comb(2*n, n)",ye15
1470,https://leetcode.com/problems/shuffle-the-array/discuss/941189/Simple-Python-Solution,"class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        l=[]
        for i in range(n):
            l.append(nums[i])
			l.append(nums[n+i])
        return l",lokeshsenthilkumar
1471,https://leetcode.com/problems/the-k-strongest-values-in-an-array/discuss/2516738/easy-python-solution,"class Solution:
    def getStrongest(self, arr: List[int], k: int) -> List[int]:
        new_arr = []
        arr.sort()
        med = arr[int((len(arr) - 1)//2)]
        for num in arr : 
            new_arr.append([int(abs(num - med)), num])
            
        new_arr = sorted(new_arr, key = lambda x : (x[0], x[1]))
        
        output, counter = [], 0
        for i in reversed(range(len(new_arr))) : 
            output.append(new_arr[i][1])
            counter += 1 
            if counter == k : 
                return output 
            
        return output",sghorai
1473,https://leetcode.com/problems/paint-house-iii/discuss/1397505/Explained-Commented-Top-Down-greater-Bottom-Up-greater-Space-Optimized-Bottom-Up,"class Solution:
    def minCost1(self, houses: List[int], cost: List[List[int]], R: int, C: int, target: int) -> int:
        # think as if we are traveling downward
        # at any point, if switch our column then (target--)
        
        @functools.cache
        def dp(x,y,k): # O(100*20*100) time space
            if x == R:
                return 0 if k == 0 else math.inf
            elif k <= 0: 
                return math.inf
            
            # if this house is already colored, dont recolor!!
            if houses[x] > 0 and houses[x] != y+1: return math.inf
            
            cur_cost = 0 if houses[x] == y+1 else cost[x][y] 
            
            # now try all columns! O(20) time
            res = math.inf
            for c in range(C):
                if c == y:
                    res = min(res, cur_cost + dp(x+1,c,k))
                else:
                    res = min(res, cur_cost + dp(x+1,c,k-1))
            # print('dp',x,y,k,'=',res)
            return res
        
        ans = min(dp(0,y,target) for y in range(C))
        
        return -1 if ans == math.inf else ans",yozaam
1475,https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/discuss/685429/PythonPython3-Final-Prices-with-a-Special-Discount-in-a-Shop,"class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        len_prices = len(prices)
        i = 0
        while i <= len_prices-2:
            for j in range(i+1, len(prices)):
                if prices[i] >= prices[j] and j > i:
                    prices[i] = prices[i] - prices[j]
                    break
            
            i += 1
        
        return prices",newborncoder
1477,https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/discuss/1987219/Python-Sliding-Window-O(n)-with-detail-comments.,"class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        l, windowSum, res = 0, 0, float('inf')
        min_till = [float('inf')] * len(arr) # records smallest lenth of subarry with target sum up till index i.
        for r, num in enumerate(arr): # r:right pointer and index of num in arr
            windowSum += num
            while windowSum > target: 
			# when the sum of current window is larger then target, shrink the left end of the window one by one until windowSum <= target
                windowSum -= arr[l]
                l += 1
			# the case when we found a new target sub-array, i.e. current window
            if windowSum == target:
			   # length of current window
                curLen = r - l + 1
				# min_till[l - 1]: the subarray with min len up till the previous position of left end of the current window: 
				# avoid overlap with cur window
				# new_sum_of_two_subarray = length of current window + the previous min length of target subarray without overlapping
				# , if < res, update res.
                res = min(res, curLen + min_till[l - 1])
				# Everytime we found a target window, update the min_till of current right end of the window, 
				# for future use when sum up to new length of sum_of_two_subarray and update the res.
                min_till[r] = min(curLen, min_till[r - 1])
            else:
			# If windowSum < target: window with current arr[r] as right end does not have any target subarry, 
			# the min_till[r] doesn't get any new minimum update, i.e it equals to previous min_till at index r - 1. 
                min_till[r] = min_till[r - 1]
        return res if res < float('inf') else -1
	
Time = O(n): when sliding the window, left and right pointers traverse the array once.
Space = O(n): we use one additional list min_till[] to record min length of target subarray till index i.",changyou1009
1478,https://leetcode.com/problems/allocate-mailboxes/discuss/1496112/Beginner-Friendly-oror-Easy-to-understand-oror-DP-solution,"class Solution:
def minDistance(self, houses: List[int], k: int) -> int:
    
    n = len(houses)
    houses.sort()
    cost = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(i+1,n):
            mid_house = houses[(i+j)//2]
            for t in range(i,j+1):
                cost[i][j]+= abs(mid_house-houses[t])
    
    @lru_cache(None)
    def dp(k,ind):
        if k==0 and ind==n: return 0
        if k==0 or ind==n: return float('inf')
        res = float('inf')
        for j in range(ind,n):
            c = cost[ind][j]
            res = min(res, c + dp(k-1,j+1))
        
        return res
    
    return dp(k,0)",abhi9Rai
1480,https://leetcode.com/problems/running-sum-of-1d-array/discuss/2306599/Easy-to-understand-Python-solution,"class Solution(object):
    def runningSum(self, nums):
        result = []
        current_sum = 0
        for i in range(0, len(nums)):
            result.append(current_sum + nums[i])
            current_sum = result[i]
        return result",Balance-Coffee
1481,https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/discuss/1269930/Beats-99-runtime-oror-98-memory-oror-python-oror-easy,"class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:

        count = Counter(arr)
        ans = len(count)
        for i in sorted(count.values()):
            k -= i
            if k < 0:
                break
            ans -= 1
        return ans",chikushen99
1482,https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/707611/Python-Binary-Search-or-Mathematical-function-definition-(75-Speed),"class Solution:
    def checker(self,arr, d, m, k) -> bool:
        '''
        d -> days
        m -> bouquets
        k -> adjacent flowers
        
        return bool
        '''
        arr = [10**9] + arr + [10**9] #appending array with maximum values
        idx = []
        for i in range(len(arr)):
            if arr[i] > d:
                idx.append(i)
        cnt = 0
        for i in range(len(idx)-1):
            # how many bouquet can we make out of an interval of valid flowers 
            cnt += (idx[i+1] - idx[i] - 1) // k
        
        # return if count >= m
        return cnt >= m

    def minDays(self, arr: List[int], m: int, k: int) -> int:
        if m*k > len(arr):
            return -1
        lo, hi = 1, max(arr)
        
        while(hi >= lo):
            mid = (hi+lo)//2
            if(self.checker(arr, mid, m, k) == True):
                hi = mid
            else:
                lo = mid+1
            if(hi == lo): break
    
        if self.checker(arr, lo, m, k):
            return lo
        else:
            return hi",uds5501
1486,https://leetcode.com/problems/xor-operation-in-an-array/discuss/942598/Simple-Python-Solutions,"class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        ans=0
        for i in range(n):
            ans^=start+(2*i)
        return ans",lokeshsenthilkumar
1487,https://leetcode.com/problems/making-file-names-unique/discuss/1646944/Very-simple-python3-solution-using-hashmap-and-comments,"class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        # names : array of names
        # n : size of names
        
        # create folders at the i'th minute for each name = names[i]
        # If name was used previously, append a suffix ""(k)"" - note parenthesis - where k is the smallest pos int
        
        # return an array of strings where ans[i] is the actual saved variant of names[i]
        
        n = len(names)
        
        dictNames = {}
        ans = ['']*n
        
        # enumerate to grab index so we can return ans list in order
        for idx, name in enumerate(names):
            # check if we have seen this name before
            if name in dictNames:
                # if we have grab the next k using last successful low (k) suffix
                k = dictNames[name]
                # track the name we started so we can update the dict
                namestart = name
                # cycle through values of increasing k until we are not in a previously used name
                while name in dictNames:
                    name = namestart + f""({k})""
                    k += 1
                # update the name we started with to the new lowest value of k
                dictNames[namestart] = k
                # add the new name with k = 1 so if we see this name with the suffix
                dictNames[name] = 1
            else:
                # we havent seen this name so lets start with 1
                dictNames[name] = 1
            # build the solution
            ans[idx] = name
        return ans",jumpstarter
1488,https://leetcode.com/problems/avoid-flood-in-the-city/discuss/1842629/Python-easy-to-read-and-understand-or-heap,"class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        pq = []
        fill = set()
        d = collections.defaultdict(list)
        ans = []
        
        for i, rain in enumerate(rains):
            d[rain].append(i)
        
        for rain in rains:
            if rain > 0:
                if rain in fill:
                    return []
                fill.add(rain)
                d[rain].pop(0)
                if d[rain]:
                    heapq.heappush(pq, d[rain][0])
                ans.append(-1)
            else:
                if pq:
                    ind = heapq.heappop(pq)
                    ans.append(rains[ind])
                    fill.remove(rains[ind])
                else:
                    ans.append(1)
        
        return ans",sanial2001
1489,https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/discuss/702027/Python3-Prim's-algo,"class Solution:
    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        graph = dict()
        for u, v, w in edges: 
            graph.setdefault(u, []).append((v, w))
            graph.setdefault(v, []).append((u, w))
            
        ref = self.mst(n, graph)
        critical, pseudo = [], []
        for i in range(len(edges)):
            if self.mst(n, graph, exclude=edges[i][:2]) > ref: critical.append(i)
            elif self.mst(n, graph, init=edges[i]) == ref: pseudo.append(i)
        return [critical, pseudo]
            
        
    def mst(self, n, graph, init=None, exclude=None):
        """"""Return weight of MST of given graph using Prim's algo""""""

        def visit(u): 
            """"""Mark node and put its edges to priority queue""""""
            marked[u] = True
            for v, w in graph.get(u, []):
                if exclude and u in exclude and v in exclude: continue
                if not marked[v]: heappush(pq, (w, u, v))
                    
        ans = 0
        marked = [False]*n
        pq = [] #min prioirty queue
        
        if init: 
            u, v, w = init
            ans += w
            marked[u] = marked[v] = True
            visit(u) or visit(v)
        else:
            visit(0)

        while pq: 
            w, u, v = heappop(pq)
            if marked[u] and marked[v]: continue
            ans += w
            if not marked[u]: visit(u)
            if not marked[v]: visit(v)
                
        return ans if all(marked) else inf",ye15
1491,https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/discuss/2213970/Python3-one-pass-solution-beats-99.20-of-submissions,"class Solution:
    def average(self, salary: List[int]) -> float:
        minimum = float(""inf"")
        maximum = float(""-inf"")
        
        i = 0
        sums = 0
        while i<len(salary):
            minimum = min(minimum, salary[i])
            maximum = max(maximum, salary[i])
            sums+=salary[i]
            i+=1
        
        return (sums - (maximum+minimum))/(i-2)",Dark_wolf_jss
1492,https://leetcode.com/problems/the-kth-factor-of-n/discuss/1352274/Python3-simple-solution-using-list,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        factors = []
        for i in range(1,n+1):
            if n % i == 0:
                factors.append(i)
        if k > len(factors):
            return -1
        else:
            return factors[k-1]",EklavyaJoshi
1493,https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/708121/Easy-Solution-without-DP-Simple-Pictorial-Explanation-or-Python-Solution.,"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        m=0
        l=len(nums)
        one=True
        for i in range(0,l):
            if nums[i]==0:
                one=False
                left=i-1
                right=i+1
                ones=0
                while left>=0:
                    if nums[left]==1:
                        ones=ones+1
                        left=left-1
                    else:
                        break
                while right<l:
                    if nums[right]==1:
                        ones=ones+1
                        right=right+1
                    else:
                        break
                if ones>m:
                    m=ones
        if one:
            return l-1
        return m",lazerx
1494,https://leetcode.com/problems/parallel-courses-ii/discuss/1111255/Python3-dp,"class Solution:
    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:
        pre = [0]*n # prerequisites 
        for u, v in dependencies: 
            pre[v-1] |= 1 << (u-1) 
            
        @cache
        def fn(mask): 
            """"""Return min semesters to take remaining courses.""""""
            if mask == (1 << n) - 1: return 0 # all courses taken 
            can = [] # available courses 
            for i in range(n): 
                if not mask &amp; 1 << i and mask &amp; pre[i] == pre[i]: 
                    can.append(i)
            
            ans = inf
            for courses in combinations(can, min(k, len(can))): 
                temp = mask | reduce(lambda x, y: x | 1 << y, courses, 0)
                ans = min(ans, 1 + fn(temp))
            return ans 
        
        return fn(0)",ye15
1496,https://leetcode.com/problems/path-crossing/discuss/1132447/Python3-simple-solution-faster-than-99-users,"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        l = [(0,0)]
        x,y = 0,0
        for i in path:
            if i == 'N':
                y += 1
            if i == 'S':
                y -= 1
            if i == 'E':
                x += 1
            if i == 'W':
                x -= 1
            if (x,y) in l:
                return True
            else:
                l.append((x,y))
        return False",EklavyaJoshi
1497,https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/discuss/709252/Python3-3-line-frequency-table,"class Solution:
    def canArrange(self, arr: List[int], k: int) -> bool:
        freq = dict()
        for x in arr: freq[x%k] = 1 + freq.get(x%k, 0)
        return all(freq[x] == freq.get(xx:=(k-x)%k, 0) and (x != xx or freq[x]%2 == 0) for x in freq)",ye15
1498,https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/discuss/1703899/python-easy-two-pointers-%2B-sorting-solution,"class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        n = len(nums)
        
        nums.sort()
        i, j = 0, n-1
        
        
        res = 0 
        NUM = 10**9+7
        while i <= j:
            if nums[i] + nums[j] > target:
                j -= 1
            elif nums[i] + nums[j] <= target:
                res += pow(2, j-i, NUM)
                i += 1
            #else: # nums[i] + nums[j] == target
                
            
            
        return res % NUM",byuns9334
1499,https://leetcode.com/problems/max-value-of-equation/discuss/709364/Python3-heap,"class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        ans = -inf
        hp = [] 
        for xj, yj in points:
            while hp and xj - hp[0][1] > k: heappop(hp)
            if hp: 
                ans = max(ans, xj + yj - hp[0][0])
            heappush(hp, (xj-yj, xj))
        return ans",ye15
1502,https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/discuss/720103/Python3-2-line-(sorting),"class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr.sort()
        return len(set(arr[i-1] - arr[i] for i in range(1, len(arr)))) == 1",ye15
1503,https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/discuss/720202/PythonPython3-Last-Moment-Before-All-Ants-Fall-Out-of-a-Plank,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        if left and not right:
            return max(left)
        if not left and right:
            return n - min(right)
        if not left and not right:
            return 0
        if left and right:
            return max(max(left), n - min(right))",newborncoder
1504,https://leetcode.com/problems/count-submatrices-with-all-ones/discuss/721999/Python3-O(MN)-histogram-model,"class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        
        #precipitate mat to histogram 
        for i in range(m):
            for j in range(n):
                if mat[i][j] and i > 0: 
                    mat[i][j] += mat[i-1][j] #histogram 
        
        ans = 0
        for i in range(m):
            stack = [] #mono-stack of indices of non-decreasing height
            cnt = 0
            for j in range(n):
                while stack and mat[i][stack[-1]] > mat[i][j]: 
                    jj = stack.pop()                          #start
                    kk = stack[-1] if stack else -1           #end
                    cnt -= (mat[i][jj] - mat[i][j])*(jj - kk) #adjust to reflect lower height

                cnt += mat[i][j] #count submatrices bottom-right at (i, j)
                ans += cnt
                stack.append(j)

        return ans",ye15
1505,https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720123/Python3-brute-force,"class Solution:
    def minInteger(self, num: str, k: int) -> str:
        n = len(num)
        if k >= n*(n-1)//2: return """".join(sorted(num)) #special case
        
        #find smallest elements within k swaps 
        #and swap it to current position 
        num = list(num)
        for i in range(n):
            if not k: break 
            #find minimum within k swaps
            ii = i
            for j in range(i+1, min(n, i+k+1)): 
                if num[ii] > num[j]: ii = j 
            #swap the min to current position 
            if ii != i: 
                k -= ii-i
                for j in range(ii, i, -1):
                    num[j-1], num[j] = num[j], num[j-1]
        return """".join(num)",ye15
1507,https://leetcode.com/problems/reformat-date/discuss/1861804/Python-3-Easy-Dict.-Solution-wout-imports-(98),"class Solution:
    def reformatDate(self, date: str) -> str:
        s = date.split() # Divides the elements into 3 individual parts
        
        monthDict = {'Jan': '01', 'Feb': '02', 
                     'Mar': '03', 'Apr': '04', 
                     'May': '05', 'Jun': '06', 
                     'Jul': '07', 'Aug': '08', 
                     'Sep': '09', 'Oct': '10', 
                     'Nov': '11', 'Dec': '12'}
        
        day = s[0][:-2] # Removes the last 2 elements of the day
        month = s[1] 
        year = s[2]
        
        if int(day) < 10: # Adds 0 to the front of day if day < 10
            day = '0' + day
        
        return ''.join(f'{year}-{monthDict[month]}-{day}') # Joins it all together. Month is used to draw out the corresponding number from the dict.",IvanTsukei
1508,https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/discuss/730973/Python3-priority-queue,"class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        ans = []
        for i in range(len(nums)):
            prefix = 0
            for ii in range(i, len(nums)):
                prefix += nums[ii]
                ans.append(prefix)
        ans.sort()
        return sum(ans[left-1:right]) % 1_000_000_007",ye15
1509,https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/discuss/1433873/Python3Python-Easy-readable-solution-with-comments.,"class Solution:
    
    def minDifference(self, nums: List[int]) -> int:
        
        n = len(nums)
        # If nums are less than 3 all can be replace,
        # so min diff will be 0, which is default condition
        if n > 3:
            
            # Init min difference
            min_diff = float(""inf"")
            
            # sort the array
            nums = sorted(nums)
            
            # Get the window size, this indicates, if we
            # remove 3 element in an array how many element
            # are left, consider 0 as the index, window
            # size should be (n-3), but for array starting
            # with 0 it should be ((n-1)-3)
            window = (n-1)-3
            
            # Run through the entire array slinding the
            # window and calculating minimum difference
            # between the first and the last element of
            # that window
            for i in range(n):
                if i+window >= n:
                    break
                else:
                    min_diff = min(nums[i+window]-nums[i], min_diff)
                    
            # return calculated minimum difference
            return min_diff
        
        return 0 # default condition",ssshukla26
1510,https://leetcode.com/problems/stone-game-iv/discuss/1708107/Python3-DP,"class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        dp = [False] * (n + 1)
        squares = []
        curSquare = 1
        for i in range(1, n + 1):
            if i == curSquare * curSquare:
                squares.append(i)
                curSquare += 1
                dp[i] = True
            else:
                for square in squares:
                    if not dp[i - square]:
                        dp[i] = True
                        break
        return dp[n]",PatrickOweijane
1512,https://leetcode.com/problems/number-of-good-pairs/discuss/749025/Python-O(n)-simple-dictionary-solution,"class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        hashMap = {}
        res = 0
        for number in nums:            
            if number in hashMap:
                res += hashMap[number]
                hashMap[number] += 1
            else:
                hashMap[number] = 1
        return res",Arturo001
1513,https://leetcode.com/problems/number-of-substrings-with-only-1s/discuss/731754/Python-Sum-of-Arithmetic-Progression-with-explanation-**100.00-Faster**,"class Solution:
    def numSub(self, s: str) -> int: 
            res = 0
            s = s.split(""0"")

            for one in s:
                if one == """":
                    continue
                    
                n = len(one)
                temp = (n / 2)*(2*n + (n-1)*-1)
                    
                if temp >= 1000000007:
                    res += temp % 1000000007
                else:
                    res += temp
            return int(res)",Jasper-W
1514,https://leetcode.com/problems/path-with-maximum-probability/discuss/731655/Python3-Dijkstra's-algo,"class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        graph, prob = dict(), dict() #graph with prob
        for i, (u, v) in enumerate(edges):
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)
            prob[u, v] = prob[v, u] = succProb[i]
        
        h = [(-1, start)] #Dijkstra's algo
        seen = set()
        while h: 
            p, n = heappop(h)
            if n == end: return -p
            seen.add(n)
            for nn in graph.get(n, []):
                if nn in seen: continue 
                heappush(h, (p * prob.get((n, nn), 0), nn))
        return 0",ye15
1515,https://leetcode.com/problems/best-position-for-a-service-centre/discuss/731717/Python3-geometric-median,"class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        #euclidean distance 
        fn = lambda x, y: sum(sqrt((x-xx)**2 + (y-yy)**2) for xx, yy in positions)
        #centroid as starting point
        x = sum(x for x, _ in positions)/len(positions)
        y = sum(y for _, y in positions)/len(positions)
        
        ans = fn(x, y)
        chg = 100 #change since 0 <= positions[i][0], positions[i][1] <= 100
        while chg > 1e-6: #accuracy within 1e-5
            zoom = True
            for dx, dy in (-1, 0), (0, -1), (0, 1), (1, 0):
                xx = x + chg * dx
                yy = y + chg * dy
                dd = fn(xx, yy)
                if dd < ans: 
                    ans = dd 
                    x, y = xx, yy
                    zoom = False 
                    break 
            if zoom: chg /= 2
        return ans",ye15
1518,https://leetcode.com/problems/water-bottles/discuss/743152/Python3-5-line-iterative,"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        ans = r = 0
        while numBottles:
            ans += numBottles
            numBottles, r = divmod(numBottles + r, numExchange)
        return ans",ye15
1519,https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/discuss/1441578/Python-3-or-DFS-Graph-Counter-or-Explanation,"class Solution:
    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:
        ans = [0] * n
        tree = collections.defaultdict(list)
        for a, b in edges:                             # build tree
            tree[a].append(b)
            tree[b].append(a)
        def dfs(node):                                 # dfs
            nonlocal visited, ans, tree
            c = collections.Counter(labels[node])
            for nei in tree[node]:
                if nei in visited: continue            # avoid revisit
                visited.add(nei)
                c += dfs(nei)                          # add counter (essentially adding a 26 elements dictionary)
            ans[node] = c.get(labels[node])            # assign count of label to this node
            return c
        visited = set([0])
        dfs(0)
        return ans",idontknoooo
1520,https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings/discuss/1208758/Python3-greedy,"class Solution:
    def maxNumOfSubstrings(self, s: str) -> List[str]:
        locs = {}
        for i, x in enumerate(s): 
            locs.setdefault(x, []).append(i)
        
        def fn(lo, hi): 
            """"""Return expanded range covering all chars in s[lo:hi+1].""""""
            for xx in locs: 
                k0 = bisect_left(locs[xx], lo)
                k1 = bisect_left(locs[xx], hi)
                if k0 < k1 and (locs[xx][0] < lo or hi < locs[xx][-1]): 
                    lo = min(lo, locs[xx][0])
                    hi = max(hi, locs[xx][-1])
                    lo, hi = fn(lo, hi)
            return lo, hi
        
        group = set()
        for x in locs: 
            group.add(fn(locs[x][0], locs[x][-1]))
        
        ans = [] # ISMP (interval scheduling maximization problem)
        prev = -1 
        for lo, hi in sorted(group, key=lambda x: x[1]): 
            if prev < lo: 
                ans.append(s[lo:hi+1])
                prev = hi 
        return ans",ye15
1523,https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/discuss/1813332/Python-3-or-Math-or-Intuitive,"class Solution:
  def countOdds(self, low: int, high: int) -> int:
    if low % 2 == 0:
      return (high-low+1)//2
    return (high-low)//2 + 1",ndus
1524,https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/discuss/2061760/Python-oror-8-line-math-using-Prefix-Sum,"class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        cumSum = odd = even = 0
        for num in arr:
            cumSum += num
            if cumSum % 2:
                odd += 1
            else:
                even += 1
        return odd * (even + 1) % (pow(10, 9) + 7)",gulugulugulugulu
1525,https://leetcode.com/problems/number-of-good-ways-to-split-a-string/discuss/1520004/99.7-Python-3-solution-with-17-lines-no-search-explained,"class Solution:
    def numSplits(self, s: str) -> int:
		# this is not neccessary, but speeds things up
        length = len(s)
        if length == 1:  # never splittable
            return 0
        elif length == 2:  # always splittable
            return 1
		
		# we are recording the first and last occurence of each included letter
        first = {}  # max size = 26
        last = {}  # max size = 26
		
        for index, character in enumerate(s):  # O(n)
            if character not in first:
                first[character] = index
            last[character] = index
			
		# we are concatenating the collected indices into a list and sort them
        indices = list(first.values()) + list(last.values())  # max length 26 + 26 = 52
        indices.sort()  # sorting is constant O(1) because of the length limit above
		
		# all possible splits will be in the middle of this list
        middle = len(indices)//2  # always an integer because indices has an even length
		
		# there are this many possible splits between the two 'median' numbers
        return indices[middle] - indices[middle-1]",epistoteles
1526,https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/discuss/1589995/Python3-O(n)-time-O(1)-space-solution,"class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        res = target[0]
        
        for i in range(1, len(target)):
            if target[i] >= target[i - 1]:
                res -= target[i - 1]
                res += target[i]
        
        return res",maosipov11
1528,https://leetcode.com/problems/shuffle-string/discuss/768482/Simple-Python-Solution-Faster-than-99.56,"class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        res = [''] * len(s)
        for i in range(len(s)):
            res[indices[i]] = s[i]
        return ''.join(i for i in res)",parkershamblin
1529,https://leetcode.com/problems/minimum-suffix-flips/discuss/755814/Python3-1-line,"class Solution:
    def minFlips(self, target: str) -> int:
        return len(list(groupby(""0"" + target)))-1",ye15
1530,https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/discuss/755979/Python3-recursive-postorder-dfs,"class Solution:
    def countPairs(self, root: TreeNode, distance: int) -> int:
        
        def dfs(node):
            """"""Return (a list of) distances to leaves of sub-tree rooted at node.""""""
            nonlocal ans
            if not node: return []
            if node.left is node.right is None: return [0]
            left,right = dfs(node.left), dfs(node.right)
            ans += sum(2 + x + y <= distance for x in left for y in right)
            return [1 + x for x in left + right]
        
        ans = 0
        dfs(root)
        return ans",ye15
1531,https://leetcode.com/problems/string-compression-ii/discuss/1203398/Python3-top-down-dp,"class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        rle = lambda x: x if x <= 1 else int(log10(x)) + 2 # rle length of a char repeated x times
        
        @cache 
        def fn(i, k, prev, cnt):
            """"""Return length of rle of s[i:] with k chars to be deleted.""""""
            if k < 0: return inf 
            if i == len(s): return 0 
            ans = fn(i+1, k-1, prev, cnt) # delete current character 
            if prev == s[i]: 
                ans = min(ans, fn(i+1, k, s[i], cnt+1) + rle(cnt+1) - rle(cnt))
            else: 
                ans = min(ans, fn(i+1, k, s[i], 1) + 1)
            return ans 
        
        return fn(0, k, """", 0)",ye15
1534,https://leetcode.com/problems/count-good-triplets/discuss/767942/Python3-1-line,"class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        return sum(abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c for i in range(len(arr)) for j in range(i+1, len(arr)) for k in range(j+1, len(arr)))",ye15
1535,https://leetcode.com/problems/find-the-winner-of-an-array-game/discuss/767983/Python3-6-line-O(N),"class Solution:
    def getWinner(self, arr: List[int], k: int) -> int:
        win = cnt = 0 #winner &amp; count 
        for i, x in enumerate(arr): 
            if win < x: win, cnt = x, 0 #new winner in town 
            if i: cnt += 1 #when initializing (i.e. i == 0) count is 0
            if cnt == k: break #early break 
        return win",ye15
1536,https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/768030/Python3-bubble-ish-sort,"class Solution:
    def minSwaps(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        #summarizing row into number 
        row = [0]*m 
        for i in range(m):
            row[i] = next((j for j in reversed(range(n)) if grid[i][j]), 0)
        
        ans = 0
        #sequentially looking for row to fill in 
        for k in range(m): 
            for i, v in enumerate(row): 
                if v <= k: #enough trailing zeros 
                    ans += i
                    row.pop(i) #value used 
                    break 
            else: return -1 #cannot find such row 
        return ans",ye15
1537,https://leetcode.com/problems/get-the-maximum-score/discuss/768050/Python3-range-sum-with-two-pointers-O(M%2BN),"class Solution:
    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
        ans = i = ii = s = ss = 0
        while i < len(nums1) and ii < len(nums2): 
            #update range sum &amp; move pointer 
            if nums1[i] < nums2[ii]: 
                s += nums1[i] 
                i += 1
            elif nums1[i] > nums2[ii]:
                ss += nums2[ii]
                ii += 1
            #add larger range sum to ans
            #add common value &amp; move pointers
            else: 
                ans += max(s, ss) + nums1[i]
                s = ss = 0
                i, ii = i+1, ii+1
        #complete the range sum &amp; update ans 
        ans += max(s + sum(nums1[i:]), ss + sum(nums2[ii:])) 
        return ans % 1_000_000_007",ye15
1539,https://leetcode.com/problems/kth-missing-positive-number/discuss/784720/Python3-O(N)-and-O(logN)-solutions,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        ss, x = set(arr), 1
        while True: 
            if x not in ss: k -= 1
            if not k: return x
            x += 1",ye15
1541,https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/discuss/2825876/Python,"class Solution:
    def minInsertions(self, s: str) -> int:
        """"""
        (
        """"""
        res = need = 0

        for i in range(len(s)):
            if s[i] == '(':
                need += 2
                if need % 2 == 1:
                    res += 1
                    need -= 1
            if s[i] == ')':
                need -= 1
                if need == -1:
                    res += 1
                    need = 1
        return res + need",lillllllllly
1542,https://leetcode.com/problems/find-longest-awesome-substring/discuss/2259262/Python3-or-Prefix-xor-or-O(n)-Solution,"class Solution:
    def longestAwesome(self, s: str) -> int:
        # li = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
        li = [2**i for i in range(10)]
        # checker = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512}
        checker = set(li)
        checker.add(0)
        # di: k = prefix xor, v = the first idx I got a new prefix_xor_value.
        di = collections.OrderedDict({0: -1})
        maxLength = prefix_xor = 0
        
        for i in range(len(s)):
            prefix_xor ^= li[int(s[i])]
            # Found a new prefix_xor_value
            if prefix_xor not in di:
                di[prefix_xor] = i
            
            # XOR operation with previous prefix_xor_value
            for key in di.keys():
                if i - di[key] <= maxLength:
                    break
				# s[di[key] : i] is Awesome Substring
                if key ^ prefix_xor in checker:
                    maxLength = i - di[key]
        return maxLength",shugokra
1544,https://leetcode.com/problems/make-the-string-great/discuss/781044/Python3-5-line-stack-O(N),"class Solution:
    def makeGood(self, s: str) -> str:
        stack = []
        for c in s: 
            if stack and abs(ord(stack[-1]) - ord(c)) == 32: stack.pop() #pop ""bad""
            else: stack.append(c) #push ""good""
        return """".join(stack)",ye15
1545,https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/discuss/781062/Python3-4-line-recursive,"class Solution:
    def findKthBit(self, n: int, k: int) -> str:
        if k == 1: return ""0""
        if k == 2**(n-1): return ""1""
        if k < 2**(n-1): return self.findKthBit(n-1, k)
        return ""0"" if self.findKthBit(n-1, 2**n-k) == ""1"" else ""1""",ye15
1546,https://leetcode.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/discuss/781075/Python3-O(N)-prefix-sum,"class Solution:
    def maxNonOverlapping(self, nums: List[int], target: int) -> int:
        ans = prefix = 0
        seen = set([0]) #prefix sum seen so far ()
        for i, x in enumerate(nums): 
            prefix += x
            if prefix - target in seen:
                ans += 1
                seen.clear() #reset seen
            seen.add(prefix)
        return ans",ye15
1547,https://leetcode.com/problems/minimum-cost-to-cut-a-stick/discuss/781085/Python3-top-down-and-bottom-up-dp,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        @lru_cache(None)
        def fn(lo, hi): 
            """"""Return cost of cutting [lo, hi].""""""
            cc = [c for c in cuts if lo < c < hi] #collect cuts within this region 
            if not cc: return 0
            ans = inf
            for mid in cc: ans = min(ans, fn(lo, mid) + fn(mid, hi))
            return ans + hi - lo
        
        return fn(0, n)",ye15
1550,https://leetcode.com/problems/three-consecutive-odds/discuss/794097/Python3-straight-forward-solution,"class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        count = 0
        
        for i in range(0, len(arr)):
            if arr[i] %2 != 0:
                count += 1
                if count == 3:
                    return True
            else:
                count = 0
        return False",sjha2048
1551,https://leetcode.com/problems/minimum-operations-to-make-array-equal/discuss/1704407/Understandable-code-for-beginners-like-me-in-python-!!,"class Solution:
    def minOperations(self, n: int) -> int:
        if(n%2!=0):
            n=n//2
            return n*(n+1)
        else:
            n=n//2
            return n**2",kabiland
1552,https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/794249/Python3-binary-search-distance-space,"class Solution:
    def maxDistance(self, position: List[int], m: int) -> int:
        position.sort()
        
        def fn(d):
            """"""Return True if d is a feasible distance.""""""
            ans, prev = 0, -inf # where previous ball is put
            for x in position:
                if x - prev >= d: 
                    ans += 1
                    if ans == m: return True
                    prev = x
            return False 
        
		# ""last True"" binary search (in contrast to ""first True"" binary search)
        lo, hi = 1, position[-1] - position[0]
        while lo < hi: 
            mid = lo + hi + 1 >> 1
            if fn(mid): lo = mid
            else: hi = mid - 1
        return lo",ye15
1553,https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794275/Python3-bfs,"class Solution:
    def minDays(self, n: int) -> int:
        ans = 0
        queue = [n]
        seen = set()
        while queue: #bfs 
            newq = []
            for x in queue: 
                if x == 0: return ans 
                seen.add(x)
                if x-1 not in seen: newq.append(x-1)
                if x % 2 == 0 and x//2 not in seen: newq.append(x//2)
                if x % 3 == 0 and x//3 not in seen: newq.append(x//3)
            ans += 1
            queue = newq",ye15
1556,https://leetcode.com/problems/thousand-separator/discuss/805712/Python3-1-line,"class Solution:
    def thousandSeparator(self, n: int) -> str:
        return f""{n:,}"".replace("","", ""."")",ye15
1557,https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/discuss/1212672/Python-Easy-Solution-Count-of-Nodes-with-Zero-Incoming-Degree,"class Solution:
    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
        if not edges:
            return []
        
        incoming_degrees = {i: 0 for i in range(n)}
        
        for x, y in edges:
            incoming_degrees[y] += 1
            
        result = [k for k, v in incoming_degrees.items() if v == 0]
        return result",ChidinmaKO
1558,https://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/discuss/807358/Python-Bit-logic-Explained,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))) - 2 - 1",akhil_ak
1559,https://leetcode.com/problems/detect-cycles-in-2d-grid/discuss/806630/Python3-memoized-dfs-with-a-direction-parameter-(16-line),"class Solution:
    def containsCycle(self, grid: List[List[str]]) -> bool:
        m, n = len(grid), len(grid[0])
        
        @lru_cache(None)
        def fn(i, j, d): 
            """"""Traverse the grid to find cycle via backtracking.""""""
            if grid[i][j] != ""BLACK"": 
                val = grid[i][j]
                grid[i][j] = ""GRAY"" # mark visited in this trial
                for ii, jj, dd in ((i-1, j, -2), (i, j-1, -1), (i, j+1, 1), (i+1, j, 2)):
                    if 0 <= ii < m and 0 <= jj < n and d + dd != 0: # in range &amp; not going back 
                        if grid[ii][jj] == ""GRAY"": return True #cycle found 
                        if grid[ii][jj] == val: fn(ii, jj, dd)
                grid[i][j] = val 
        
        for i in range(m):
            for j in range(n):
                if fn(i, j, 0): return True
                grid[i][j] = ""BLACK"" # mark ""no cycle""
        return False",ye15
1560,https://leetcode.com/problems/most-visited-sector-in-a-circular-track/discuss/806738/Python3-2-line,"class Solution:
    def mostVisited(self, n: int, rounds: List[int]) -> List[int]:
        x, xx = rounds[0], rounds[-1]
        return list(range(x, xx+1)) if x <= xx else list(range(1, xx+1)) + list(range(x, n+1))",ye15
1561,https://leetcode.com/problems/maximum-number-of-coins-you-can-get/discuss/1232262/Python-Simple-Solution,"class Solution:
    def maxCoins(self, piles: List[int]) -> int:
        piles.sort(reverse=True)
        sum = 0
        for i in range(1,len(piles)-int(len(piles)/3),2):
            sum += piles[i]
            print(sum)
        return sum",yashwant_mahawar
1562,https://leetcode.com/problems/find-latest-group-of-size-m/discuss/809823/Python3-summarizing-two-approaches,"class Solution:
    def findLatestStep(self, arr: List[int], m: int) -> int:
        span = [0]*(len(arr)+2)
        freq = [0]*(len(arr)+1)
        ans = -1
        for i, x in enumerate(arr, 1): 
            freq[span[x-1]] -= 1
            freq[span[x+1]] -= 1
            span[x] = span[x-span[x-1]] = span[x+span[x+1]] = 1 + span[x-1] + span[x+1]
            freq[span[x]] += 1
            
            if freq[m]: ans = i
        return ans",ye15
1563,https://leetcode.com/problems/stone-game-v/discuss/1504994/Python-O(n2)-optimized-solution.-O(n3)-cannot-pass.,"class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        length = len(stoneValue)
        if length == 1:
            return 0
        
		# Calculate sum
        s = [0 for _ in range(length)]
        s[0] = stoneValue[0]
        for i in range(1, length):
            s[i] = s[i-1] + stoneValue[i]
		
		# dp for best value, best_cut for where is the cut in (i, j), i, j inclusive
        dp = [[0 for _ in range(length)] for _ in range(length)]
        best_cut = [[0 for _ in range(length)] for _ in range(length)]
        
        for i in range(0, length-1):
            dp[i][i+1] = min(stoneValue[i], stoneValue[i+1])
            best_cut[i][i+1] = i
            
        for t in range(2, length):
            for i in range(0, length-t):
                tmp_dp = 0
                tmp_cut = 0
                left_bound = best_cut[i][i+t-1]
                if left_bound > i:
                    left_bound -= 1
                right_bound = best_cut[i+1][i+t]
                if right_bound < i+t-1:
                    right_bound += 1
                    
                for k in range(left_bound, 1+right_bound):
                    s1 = s[k] - s[i-1] if i > 0 else s[k]
                    s2 = s[i+t] - s[k]
                    if s1 < s2:
                        tmp = s1 + dp[i][k]
                        if tmp > tmp_dp:
                            tmp_dp = tmp
                            tmp_cut = k
                    elif s1 > s2:
                        tmp = s2 + dp[k+1][i+t]
                        if tmp > tmp_dp:
                            tmp_dp = tmp
                            tmp_cut = k
                    else:
                        tmp1 = s1 + dp[i][k]
                        tmp2 = s2 + dp[k+1][i+t]
                        if tmp1 > tmp_dp:
                            tmp_dp = tmp1
                            tmp_cut = k
                        if tmp2 > tmp_dp:
                            tmp_dp = tmp2
                            tmp_cut = k
        
                dp[i][i+t] = tmp_dp
                best_cut[i][i+t] = tmp_cut
                
        return dp[0][length-1]",pureme
1566,https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/discuss/1254278/Python3-simple-solution,"class Solution:
    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:
        for i in range(len(arr)-m+1):
            count = 1
            x = arr[i:i+m]
            res = 1
            for j in range(i+m,len(arr)-m+1,m):
                if x == arr[j:j+m]:
                    count += 1
                else:
                    res = max(res,count)
                    count = 1
                    x = arr[j:j+m]
            res = max(res,count)
            if res >= k:
                return True
        return False",EklavyaJoshi
1567,https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/discuss/819332/Python3-7-line-O(N)-time-and-O(1)-space,"class Solution:
    def getMaxLen(self, nums: List[int]) -> int:
        ans = pos = neg = 0
        for x in nums: 
            if x > 0: pos, neg = 1 + pos, 1 + neg if neg else 0
            elif x < 0: pos, neg = 1 + neg if neg else 0, 1 + pos
            else: pos = neg = 0 # reset 
            ans = max(ans, pos)
        return ans",ye15
1568,https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/discuss/819360/Python3-bfs,"class Solution:
    def minDays(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimension 
        grid = """".join("""".join(map(str, x)) for x in grid)
        
        @lru_cache(None)
        def fn(s): 
            """"""Return True if grid is disconnected.""""""
            row, grid = [], []
            for i, c in enumerate(s, 1):
                row.append(int(c))
                if i%n == 0: 
                    grid.append(row)
                    row = []
                    
            def dfs(i, j): 
                """"""""""""
                grid[i][j] = 0
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: dfs(ii, jj)
                return 1
            return sum(dfs(i, j) for i in range(m) for j in range(n) if grid[i][j])
        
        #bfs 
        queue = [grid]
        level = 0 
        seen = {grid}
        while queue: 
            tmp = []
            for node in queue: 
                if fn(node) == 0 or fn(node) >= 2: return level 
                for i in range(m*n):
                    if node[i] == ""1"": 
                        nn = node[:i] + ""0"" + node[i+1:]
                        if nn not in seen: 
                            seen.add(nn)
                            tmp.append(nn)
            queue = tmp
            level += 1",ye15
1569,https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/discuss/819349/Python3-math-ish,"class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        
        def fn(nums): 
            """"""Post-order traversal.""""""
            if len(nums) <= 1: return len(nums) # boundary condition 
            ll = [x for x in nums if x < nums[0]]
            rr = [x for x in nums if x > nums[0]]
            left, right = fn(ll), fn(rr)
            if not left or not right: return left or right
            ans = comb(len(rr)+len(ll), len(rr))
            return ans*left*right
            
        return (fn(nums)-1) % 1_000_000_007",ye15
1572,https://leetcode.com/problems/matrix-diagonal-sum/discuss/1369404/PYTHON-Best-solution-with-explanation.-SC-%3A-O(1)-TC-%3A-O(n),"class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        """"""
        The primary diagonal is formed by the elements A00, A11, A22, A33.
        Condition for Primary Diagonal:
            The row-column condition is row = column.

        The secondary diagonal is formed by the elements A03, A12, A21, A30. 
        Condition for Secondary Diagonal:
            The row-column condition is row = numberOfRows - column -1.
        """"""
        s = 0
        l , mid = len(mat), len(mat)//2
        for i in range(l):
            s += mat[i][i] # primary diagonal
            s += mat[len(mat)-i-1][i] # secondary diagonal
        
        # If the mat is odd, then diagonal will coincide, so subtract the middle element
        if l%2 != 0:
            s -= mat[mid][mid]
        
        return s",er1shivam
1573,https://leetcode.com/problems/number-of-ways-to-split-a-string/discuss/830700/Python-3-or-Math-(Pass)-Backtracking-(TLE)-or-Explanation,"class Solution:
    def numWays(self, s: str) -> int:
        total = s.count('1')
        if total % 3: return 0
        n = len(s)
        if not total: return (1+n-2) * (n-2) // 2 % 1000000007
        avg, ans = total // 3, 0
        cnt = first_part_right_zeros = last_part_left_zeros = 0
        for i in range(n):
            if s[i] == '1': cnt += 1
            elif cnt == avg: first_part_right_zeros += 1
            elif cnt > avg: break    
        cnt = 0
        for i in range(n-1, -1, -1):
            if s[i] == '1': cnt += 1
            elif cnt == avg: last_part_left_zeros += 1
            elif cnt > avg: break    
        return (first_part_right_zeros+1) * (last_part_left_zeros+1) % 1000000007",idontknoooo
1574,https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/discuss/835866/Python-Solution-Based-on-Binary-Search,"class Solution:
    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
        
        def lowerbound(left, right, target):
            while left < right:
                mid = left + (right - left) // 2
                
                if arr[mid] == target:
                    right = mid
                elif arr[mid] < target:
                    left = mid + 1
                else:
                    right = mid
                
            return left
        
        
        N = len(arr)
        
        # find the longest ascending array on the left side
        i = 0
        while i + 1 < N and arr[i] <= arr[i+1]:
            i += 1
        
        if i == N - 1:
            # it is already in ascending order
            return 0
        
        # find the longest ascending array on the right side
        j = N - 1
        while j - 1 >= 0 and arr[j] >= arr[j-1]:
            j -= 1
        
        if j == 0:
            # the entire array is in decending order
            return N - 1
        
        # keep ascending array on right side or left side
        result = min(N - (N - j), N - i -1)
        
        
        # find the shortest unordered subarray in the middle 
        for k in range(i+1):
            l = lowerbound(j, len(arr), arr[k])
            result = min(result, l - (k + 1))
        
        
        return result",pochy
1575,https://leetcode.com/problems/count-all-possible-routes/discuss/831260/Python3-top-down-dp,"class Solution:
    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
        
        @lru_cache(None)
        def fn(n, x): 
            """"""Return all possible routes from n to finish with x fuel.""""""
            if x < 0: return 0 # not going anywhere without fuel 
            ans = 0
            if n == finish: ans += 1
            for nn in range(len(locations)): 
                if nn != n: ans += fn(nn, x-abs(locations[n] - locations[nn]))
            return ans 
        
        return fn(start, fuel) % 1_000_000_007",ye15
1576,https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/discuss/831516/Python3-one-of-three-letters,"class Solution:
    def modifyString(self, s: str) -> str:
        s = list(s)
        for i in range(len(s)):
            if s[i] == ""?"": 
                for c in ""abc"": 
                    if (i == 0 or s[i-1] != c) and (i+1 == len(s) or s[i+1] != c): 
                        s[i] = c
                        break 
        return """".join(s)",ye15
1577,https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/1658113/Python-intuitive-hashmap-solution-O(n*m)-time,"class Solution:
    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        sqr1, sqr2 = defaultdict(int), defaultdict(int)
        m, n = len(nums1), len(nums2)
        for i in range(m):
            sqr1[nums1[i]**2] += 1
        for j in range(n):
            sqr2[nums2[j]**2] += 1
            
        res = 0 
        for i in range(m-1):
            for j in range(i+1, m):
                if nums1[i]*nums1[j] in sqr2:
                    res += sqr2[nums1[i]*nums1[j]]
                    
        for i in range(n-1):
            for j in range(i+1, n):
                if nums2[i]*nums2[j] in sqr1:
                    res += sqr1[nums2[i]*nums2[j]]
        return res",byuns9334
1578,https://leetcode.com/problems/minimum-time-to-make-rope-colorful/discuss/831500/Python3-greedy,"class Solution:
    def minCost(self, s: str, cost: List[int]) -> int:
        ans = prev = 0 # index of previously retained letter 
        for i in range(1, len(s)): 
            if s[prev] != s[i]: prev = i
            else: 
                ans += min(cost[prev], cost[i])
                if cost[prev] < cost[i]: prev = i
        return ans",ye15
1582,https://leetcode.com/problems/special-positions-in-a-binary-matrix/discuss/1802763/Python-Memory-Efficient-Solution,"class Solution:
    def numSpecial(self, mat: List[List[int]]) -> int:
        onesx = []
        onesy = []
        for ri, rv in enumerate(mat):
            for ci, cv in enumerate(rv):
                if cv == 1:
                    onesx.append(ri)
                    onesy.append(ci)
        
        count = 0
        for idx in range(len(onesx)):
            if onesx.count(onesx[idx]) == 1:
                if onesy.count(onesy[idx]) == 1:
                    count += 1
        return count",croatoan
1583,https://leetcode.com/problems/count-unhappy-friends/discuss/1103620/Readable-python-solution,"class Solution:
    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:

        def find_preferred_friends(x: int) -> List[int]:
            """"""
            Returns friends of x that have a higher preference than partner.
            """"""
			partner = partners[x]  # Find the partner of x.
            x_friends = friend_prefs[x]  # Find all the friends of x.
            partner_ranking = x_friends[partner]  # Get the partner's ranking amongst those friends.
            return list(x_friends)[:partner_ranking]  # Return all friends with a preferred lower ranking.

        def is_unhappy(x: int) -> bool:
            """"""
            Returns True if person x is unhappy, otherwise False.
            """"""
            # Find the partner for person x.
            partner = partners[x]  
            # Find the friends that person x prefers more than this partner.
            preferred_friends = find_preferred_friends(x)  
            # A friend is unhappy with their partner if there is another friend with a higher preference 
            # and that friend prefers them over their partner.
            return any(friend_prefs[friend][x] <= friend_prefs[friend][partners[friend]] 
                       for friend in preferred_friends)

        # Create dictionary to lookup friend preference for any person.
        friend_prefs = {
            person: {friend: pref for pref, friend in enumerate(friends)}
            for person, friends in enumerate(preferences)
        }
		# Example:
		# {0: {1: 0, 3: 1, 2: 2},
	    #  1: {2: 0, 3: 1, 0: 2},
	    #  2: {1: 0, 3: 1, 0: 2},
	    #  3: {0: 0, 2: 1, 1: 2}}
 
        # Create dictionary to find anyone's partner.
        partners = {}
        for x, y in pairs:
            partners[x] = y
            partners[y] = x
        
		# Count and return the number of unhappy people.
        return sum(is_unhappy(person) for person in range(n))",alexanco
1584,https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/843995/Python-3-or-Min-Spanning-Tree-or-Prim's-Algorithm,"class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])
        n, c = len(points), collections.defaultdict(list)
        for i in range(n):
            for j in range(i+1, n):
                d = manhattan(points[i], points[j])
                c[i].append((d, j))
                c[j].append((d, i))
        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]
        visited[0] = 1
        heapq.heapify(heap)
        while heap:
            d, j = heapq.heappop(heap)
            if not visited[j]:
                visited[j], cnt, ans = 1, cnt+1, ans+d
                for record in c[j]: heapq.heappush(heap, record)
            if cnt >= n: break        
        return ans",idontknoooo
1585,https://leetcode.com/problems/check-if-string-is-transformable-with-substring-sort-operations/discuss/844119/Python3-8-line-deque,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if sorted(s) != sorted(t): return False # edge case 
        
        pos = [deque() for _ in range(10)]
        for i, ss in enumerate(s): pos[int(ss)].append(i)
            
        for tt in t: 
            i = pos[int(tt)].popleft()
            for ii in range(int(tt)): 
                if pos[ii] and pos[ii][0] < i: return False # cannot swap 
        return True",ye15
1604,https://leetcode.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/discuss/1284866/Python3-or-Dict-%2B-Sort,"class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
        key_time = {}
        for index, name in enumerate(keyName):
            key_time[name] = key_time.get(name, [])
            key_time[name].append(int(keyTime[index].replace("":"", """")))
        ans = []
        for name, time_list in key_time.items():
            time_list.sort()
            n = len(time_list)
            for i in range(n-2):
                if time_list[i+2] - time_list[i] <= 100:
                    ans.append(name)
                    break
        return sorted(ans)",Sanjaychandak95
1605,https://leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/discuss/1734833/Python-or-Backtracking,"class Solution:
    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:
        def backtrack(y, x):
            choice = min(rowSum[y], colSum[x])
            result[y][x] = choice
            rowSum[y] -= choice
            colSum[x] -= choice
            if y == 0 and x == 0:
                return

            elif not rowSum[y]:
                backtrack(y - 1, x)
            elif not colSum[x]:
                backtrack(y, x - 1)

        Y, X = len(rowSum), len(colSum)
        result = [[0 for _ in range(X)] for _ in range(Y)]
        backtrack(Y-1, X-1)
        return result",holdenkold
1608,https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/discuss/1527669/Python-or-Faster-than-94-or-2-methods-or-O(nlogn),"class Solution:
    def specialArray(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)

        if n<=nums[0]:
            return n
        
        for i in range(1,n):
            count = n-i       #counts number of elements in nums greater than equal i
            if nums[i]>=(count) and (count)>nums[i-1]:
                return count 
        return -1",ana_2kacer
1609,https://leetcode.com/problems/even-odd-tree/discuss/877858/Python3-bfs-by-level,"class Solution:
    def isEvenOddTree(self, root: TreeNode) -> bool:
        even = 1 # even level 
        queue = deque([root])
        while queue: 
            newq = []
            prev = -inf if even else inf
            for _ in range(len(queue)): 
                node = queue.popleft()
                if even and (node.val&amp;1 == 0 or prev >= node.val) or not even and (node.val&amp;1 or prev <= node.val): return False 
                prev = node.val 
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            even ^= 1
        return True",ye15
1610,https://leetcode.com/problems/maximum-number-of-visible-points/discuss/1502236/Python-Clean-Sliding-Window,"class Solution:
    def visiblePoints(self, points: List[List[int]], angle: int, l: List[int]) -> int:
        
        array = []
        nloc = 0
        for p in points:
            if p == l:
                nloc += 1
            else:
                array.append(math.degrees(atan2(p[1]-l[1], p[0]-l[0])))
        array.sort()
        angles = array + [a+360 for a in array]
        left, maxm = 0, 0
        for right, a in enumerate(angles):
            if a-angles[left] > angle:
                left += 1
            maxm = max(right-left+1, maxm)
        
        return maxm + nloc",soma28
1611,https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/discuss/2273798/Easy-to-understand-6-line-solution-with-explanation-or-O(N)-time-O(1)-space,"class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        """"""
        to flip the bits to turn the number to zero
        
        Interpretation of Rules:
        - recursive:
            to turn a leading one of i bits to zero, the only way is to turn the i-1 bits to a leading one pattern
            and to turn the i-1 bits leading zero to zero, the only way is to turn the i-2 bits to a leading one pattern
            and so on, which is a recursive process
            
            (10000.. -> 11000.. -> 01000..), (01000.. -> 01100.. -> 00100), ..., (..010 -> ..011 -> ..001 -> ..000)
            
        - reversable:
        
            Let's make some observations to check if there's any pattern:

            - 2: 10 -> 11 -> 01 -> 00
            - 4: 100 -> 101 -> 111 -> 110 -> 010 -> 011 -> 001 -> 000
            - 8: 1000 -> 1001 -> 1011 -> 1010 -> 1110 -> 1111 -> 1101 -> 1100 -> 0100 -> (reversing 100 to 000) -> 0000
            ...
            
            based on the observation, turning every i bits leading one to zero, is turning the i-1 bits from 00.. to 10..
            and then back to 00.., which is a reverable process, and with the recursive process we can conclude that
            turning any length of 00..M-> 10.. is a reversable process
        
        - all unique states:
            since it is recursive and reversable, and we are flipping every bit between 1 and 0 programtically 10.. <-> 00..
            we can conclude that every intermediate state in a process is unique (2**i unique states, so we need 2**i - 1 steps)
        
                for i bits 10.. <-> 00.. - numer of operations f(i) = 2**i - 1
            
            this also aligns with the observation above that f(i) = 2*f(i-1) - 1 (-1 for no operation needed to achieve the initial 000)
        
        Process:
        to turn any binary to 0, we can turning the 1s to 0s one by one from lower bit to higher bit
        and because turning a higher bit 1 to 0, would passing the unique state including the lower bit 1s
        we can reverse those operations needed for the higher bit 100.. to the unique state including the lower bit 1s
        
        e.g. turning 1010100 to 0
        - 1010(100) -> 1010(000), we will need 2**3 - 1 operations
        - 10(10000) -> 10(00000), we will need (2**5 - 1) - (2**3 - 1) operations
        we will be passing the state 10(10100), which is ready available from the last state
        so we can save/reverse/deduct the operations needed for 1010(000) <-> 1010(100)
        - ...
        
            so for any binary, f(binary) would tell us how many operations we need for binary <-> 000..
            and for any more 1s, 100{binary} we can regard it as a process of 100.. <-> 100{binary} <-> 000{000..}
            which is 100.. <-> 000.. (2**i - 1) saving the operations 100{000..} <-> 100{binary} (f(binary))
            = (2**i - 1) - f(last_binary)
            
        """"""
        binary = format(n, ""b"")

        N, res = len(binary), 0
        
        for i in range(1, N+1):
            if binary[-i] == ""1"": res = 2**i-1 - res
                
        return res",zhenyulin
1615,https://leetcode.com/problems/maximal-network-rank/discuss/888965/Python3-graph-as-adjacency-list,"class Solution:
    def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:
        graph = {}
        for u, v in roads:
            graph.setdefault(u, set()).add(v)
            graph.setdefault(v, set()).add(u)
        
        ans = 0
        for i in range(n): 
            for j in range(i+1, n):
                val = len(graph.get(i, set())) + len(graph.get(j, set())) - (j in graph.get(i, set()))
                ans = max(ans, val)
        return ans",ye15
1616,https://leetcode.com/problems/split-two-strings-to-make-palindrome/discuss/888981/Python3-greedy,"class Solution:
    def checkPalindromeFormation(self, a: str, b: str) -> bool:
        
        fn = lambda x: x == x[::-1] # check for palindrome 
        
        i = 0
        while i < len(a) and a[i] == b[~i]: i += 1
        if fn(a[:i] + b[i:]) or fn(a[:-i] + b[-i:]): return True 
        
        i = 0
        while i < len(a) and a[~i] == b[i]: i += 1
        if fn(b[:i] + a[i:]) or fn(b[:-i] + a[-i:]): return True 
        
        return False",ye15
1617,https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/discuss/1068298/Python-Top-Down-DP-O(n5).-35-ms-and-faster-than-100-explained,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        # Create Tree as adjacency list
        neigh: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges:
            neigh[u - 1].append(v - 1)
            neigh[v - 1].append(u - 1)

        distance_array: List[int] = [0] * n

        def find_tree_center(vertices: List[int], adj_list: List[List[int]]) -> int:
            """"""Given a tree, return a central vertex (minimum radius vertex) with BFS""""""

            num_neighbors: List[int] = list(map(len, adj_list))
            leaf_nodes: Deque[int] = collections.deque((x for x in range(len(vertices)) if num_neighbors[x] == 1))
            while len(leaf_nodes) > 1:
                leaf = leaf_nodes.popleft()
                for neighbor in adj_list[leaf]:
                    num_neighbors[neighbor] -= 1
                    if num_neighbors[neighbor] == 1:
                        leaf_nodes.append(neighbor)
            return leaf_nodes[0]

        def merge_into_parent(parent_subtrees: Dict[Tuple[int, int], int],
                              child_subtrees: Dict[Tuple[int, int], int]) -> None:

            """""" Helper function to merge two disjoint rooted trees T_parent and T_child rooted at 'parent' and 'child',
               into one tree rooted at 'parent', by adding an edge from 'parent' to 'child'.
               Called once for each edge in our tree. parent_subtrees[i, j] is the count of rooted subtrees
               of T_parent that contain 'parent', have diameter i, and height j.
               Worst case complexity: O(n^4) per call
            """"""

            for (diam_for_parent, height_for_parent), count_from_parent in list(parent_subtrees.items()):

                for (diam_for_child, height_for_child), count_from_child in child_subtrees.items():

                    new_diameter = max(diam_for_parent, diam_for_child, height_for_parent + height_for_child + 1)
                    new_height = max(height_for_parent, height_for_child + 1)
                    parent_subtrees[new_diameter, new_height] = parent_subtrees.get((new_diameter, new_height), 0) + count_from_child * count_from_parent

            return None

        def compute_subtree_counts(current_vertex: int,
                                   last_vertex: int = -1) -> Dict[Tuple[int, int], int]:
            """"""Recursively counts subtrees rooted at current_vertex using DFS,
            with edge from current_vertex to 'last_vertex' (parent node) cut off""""""
            subtree_counts: Dict[Tuple[int, int], int] = {(0, 0): 1}

            for child_vertex in neigh[current_vertex]:
                if child_vertex == last_vertex:
                    continue

                merge_into_parent(parent_subtrees=subtree_counts,
                                  child_subtrees=compute_subtree_counts(current_vertex=child_vertex,
                                                                        last_vertex=current_vertex))

            for (diameter, height), subtree_count in subtree_counts.items():
                distance_array[diameter] += subtree_count

            return subtree_counts

        # Optimization: Use a max-degree vertex as our root to minimize recursion depth
        max_degree_vertex: int = find_tree_center(vertices=list(range(n)),
                                                  adj_list=neigh)

        compute_subtree_counts(current_vertex=max_degree_vertex)

        return distance_array[1:]",kcsquared
1619,https://leetcode.com/problems/mean-of-array-after-removing-some-elements/discuss/1193688/2-easy-Python-Solutions,"class Solution:
    def trimMean(self, arr: List[int]) -> float:
        arr.sort()

        return statistics.mean(arr[int(len(arr)*5/100):len(arr)-int(len(arr)*5/100)])",ayushi7rawat
1620,https://leetcode.com/problems/coordinate-with-maximum-network-quality/discuss/1103762/Python3-enumerate-all-candidates,"class Solution:
    def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:
        mx = -inf
        for x in range(51):
            for y in range(51): 
                val = 0
                for xi, yi, qi in towers: 
                    d = sqrt((x-xi)**2 + (y-yi)**2)
                    if d <= radius: val += int(qi/(1 + d))
                if val > mx: 
                    ans = [x, y]
                    mx = val
        return ans",ye15
1621,https://leetcode.com/problems/number-of-sets-of-k-non-overlapping-line-segments/discuss/1103787/Python3-top-down-dp,"class Solution:
    def numberOfSets(self, n: int, k: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return number of sets.""""""
            if n <= k: return 0 
            if k == 0: return 1
            return 2*fn(n-1, k) + fn(n-1, k-1) - fn(n-2, k)
        
        return fn(n, k) % 1_000_000_007",ye15
1624,https://leetcode.com/problems/largest-substring-between-two-equal-characters/discuss/899540/Python3-via-dictionary,"class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        ans = -1
        seen = {}
        for i, c in enumerate(s): 
            if c in seen: ans = max(ans, i - seen[c] - 1)
            seen.setdefault(c, i)
        return ans",ye15
1625,https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/discuss/899547/Python3-dfs,"class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        op1 = lambda s: """".join(str((int(c)+a)%10) if i&amp;1 else c for i, c in enumerate(s))
        op2 = lambda s: s[-b:] + s[:-b]
        
        seen = set()
        stack = [s]
        while stack: 
            s = stack.pop()
            seen.add(s)
            if (ss := op1(s)) not in seen: stack.append(ss)
            if (ss := op2(s)) not in seen: stack.append(ss)
        return min(seen)",ye15
1626,https://leetcode.com/problems/best-team-with-no-conflicts/discuss/2848106/Python-Heavily-commented-to-self-understand-first-of-all-DP-2-Loops,"class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:
        '''
        Using example scores = [1,2,3,5] and ages = [8,9,10,1]
        
        data is   [(1, 5), (8, 1), (9, 2), (10, 3)]
        and dp is [5, 1, 2, 3]
        
        when curr player is (1, 5)
            there are no prev players -> so leave dp of curr as-is
            
        when curr player is (8, 1)
            prev player's score is not less than curr player score
            nor is previous player's age same as curr player age -> so leave dp of curr as-is
        
        when curr player is (9, 2)
            prev player (1, 5) has score NOT less than, and age NOT equal to ... skipping
            prev player (8, 1) has score YES less than ... so we do something!
                since the accumulated dp of prev player + curr's score is GREATER than curr's accumulated dp value:
                    we update curr's accumulated dp value to be instead sum of prev player's dp value and curr's score
                    
        when curr player is (10, 3)
            prev player (1, 5) has score NOT less, and age NTO equal to ... skipping
            prev player (8, 1) has score YES less, so update curr's dp value from 3 -> 3+1 = 4
            prev player (9, 2) has score YES less, so update curr's dp value from 4 -> 4+2 = 6
            
        finally we return the max of all dp values for the dream team.
        '''
        # Sort by age and score ASC
        data = sorted(zip(ages, scores), key=lambda x:(x[0], x[1]))
        # Initialize dp with scores for each player
        dp = [score for age, score in data]
        N = len(data)
        
        # For every current player
        for curr in range(N):
            # Compare every previous player
            for prev in range(0, curr):
                # And if previous player score is less OR previous player is same age
                if (data[prev][1] <= data[curr][1] or data[curr][0] == data[prev][0]):
                    # Then update dp value for current player to be the max of either
                    #  -> the current score as it is OR
                    #  -> the current score PLUS the dp value of previous player
                    dp[curr] = max(dp[curr], data[curr][1] + dp[prev])

        return max(dp)",graceiscoding
1629,https://leetcode.com/problems/slowest-key/discuss/1172372/Python3-Simple-And-Readable-Solution,"class Solution:
    def slowestKey(self, r: List[int], k: str) -> str:
        times = {r[0]: [k[0]]}
        
        for i in range(1 , len(r)):
            t = r[i] - r[i - 1]
            if(t in times):
                times[t].append(k[i])
            else:
                times[t] = [k[i]]
        
        keys = times[max(times.keys())]
        
        return max(keys)",VoidCupboard
1630,https://leetcode.com/problems/arithmetic-subarrays/discuss/1231666/Python3-Brute-force,"class Solution:
    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:
        ans = []
        
        def find_diffs(arr):
            
            arr.sort()

            dif = []
            
            for i in range(len(arr) - 1):
                dif.append(arr[i] - arr[i + 1])
            
            return len(set(dif)) == 1
        
        for i , j in zip(l , r):
            ans.append(find_diffs(nums[i:j + 1]))
        
        return ans",VoidCupboard
1631,https://leetcode.com/problems/path-with-minimum-effort/discuss/909094/Python3-bfs-and-Dijkstra,"class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        
        queue = {(0, 0): 0} # (0, 0) maximum height so far 
        seen = {(0, 0): 0} # (i, j) -> heights 
        ans = inf 
        
        while queue: 
            newq = {} # new dictionary 
            for (i, j), h in queue.items(): 
                if i == m-1 and j == n-1: ans = min(ans, h)
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                    if 0 <= ii < m and 0 <= jj < n: 
                        hh = max(h, abs(heights[i][j] - heights[ii][jj]))
                        if hh < seen.get((ii, jj), inf): 
                            seen[(ii, jj)] = hh 
                            newq[(ii, jj)] = hh
            queue = newq 
        return ans",ye15
1632,https://leetcode.com/problems/rank-transform-of-a-matrix/discuss/913790/Python3-UF,"class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0]) # dimension 
        # mapping from value to index 
        mp = {} 
        for i in range(m):
            for j in range(n): 
                mp.setdefault(matrix[i][j], []).append((i, j))
        
        def find(p):
            """"""Find root of p.""""""
            if p != parent[p]:
                parent[p] = find(parent[p])
            return parent[p]
        
        rank = [0]*(m+n)
        ans = [[0]*n for _ in range(m)]
        
        for k in sorted(mp): # from minimum to maximum 
            parent = list(range(m+n))
            for i, j in mp[k]: 
                ii, jj = find(i), find(m+j) # find 
                parent[ii] = jj # union 
                rank[jj] = max(rank[ii], rank[jj]) # max rank 
            
            seen = set()
            for i, j in mp[k]:
                ii = find(i)
                if ii not in seen: rank[ii] += 1
                seen.add(ii)
                rank[i] = rank[m+j] = ans[i][j] = rank[ii]
        return ans",ye15
1636,https://leetcode.com/problems/sort-array-by-increasing-frequency/discuss/963292/Python-1-liner,"class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        return sorted(sorted(nums,reverse=1),key=nums.count)",lokeshsenthilkumar
1637,https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/discuss/2806260/Python-or-Easy-Peasy-Code-or-O(n),"class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        l = []
        for i in points:
            l.append(i[0])
        a = 0
        l.sort()
        for i in range(len(l)-1):
            if l[i+1] - l[i] > a:
                a = l[i+1] - l[i]
        return a",bhuvneshwar906
1638,https://leetcode.com/problems/count-substrings-that-differ-by-one-character/discuss/1101671/Python3-top-down-and-bottom-up-dp,"class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        m, n = len(s), len(t) 
        
        @cache
        def fn(i, j, k): 
            """"""Return number of substrings ending at s[i] and t[j] with k=0/1 difference.""""""
            if i < 0 or j < 0: return 0 
            if s[i] == t[j]: return fn(i-1, j-1, k) + (k==0)
            else: return 0 if k == 0 else 1 + fn(i-1, j-1, 0)
        
        return sum(fn(i, j, 1) for i in range(m) for j in range(n))",ye15
1639,https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/discuss/1101522/Python3-top-down-dp,"class Solution:
    def numWays(self, words: List[str], target: str) -> int:
        freq = [defaultdict(int) for _ in range(len(words[0]))]
        for word in words: 
            for i, c in enumerate(word): 
                freq[i][c] += 1
        
        @cache
        def fn(i, k): 
            """"""Return number of ways to form target[i:] w/ col k.""""""
            if i == len(target): return 1
            if k == len(words[0]): return 0 
            return freq[k][target[i]]*fn(i+1, k+1) + fn(i, k+1)
        
        return fn(0, 0) % 1_000_000_007",ye15
1640,https://leetcode.com/problems/check-array-formation-through-concatenation/discuss/918382/Python3-2-line-O(N),"class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        mp = {x[0]: x for x in pieces}
        i = 0
        while i < len(arr): 
            if (x := arr[i]) not in mp or mp[x] != arr[i:i+len(mp[x])]: return False 
            i += len(mp[x])
        return True",ye15
1641,https://leetcode.com/problems/count-sorted-vowel-strings/discuss/2027288/Python-4-approaches-(DP-Maths),"class Solution:
    def countVowelStrings(self, n: int) -> int:        
        dp = [[0] * 6 for _ in range(n+1)]
        for i in range(1, 6):
            dp[1][i] = i
        
        for i in range(2, n+1):
            dp[i][1]=1
            for j in range(2, 6):
                dp[i][j] = dp[i][j-1] + dp[i-1][j]
        
        return dp[n][5]",constantine786
1642,https://leetcode.com/problems/furthest-building-you-can-reach/discuss/2176666/Python-or-Min-Heap-or-With-Explanation-or-Easy-to-Understand,"class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        # prepare: use a min heap to store each difference(climb) between two contiguous buildings
        # strategy: use the ladders for the longest climbs and the bricks for the shortest climbs
        
        min_heap = []
        n = len(heights)
        
        for i in range(n-1):
            climb = heights[i+1] - heights[i]
            
            if climb <= 0:
                continue
            
            # we need to use a ladder or some bricks, always take the ladder at first
            if climb > 0:
                heapq.heappush(min_heap, climb)
            
            # ladders are all in used, find the current shortest climb to use bricks instead!
            if len(min_heap) > ladders:
                # find the current shortest climb to use bricks
                brick_need = heapq.heappop(min_heap)
                bricks -= brick_need
            
            if bricks < 0:
                return i
        
        return n-1",Mikey98
1643,https://leetcode.com/problems/kth-smallest-instructions/discuss/918429/Python3-greedy,"class Solution:
    def kthSmallestPath(self, destination: List[int], k: int) -> str:
        m, n = destination # m ""V"" &amp; n ""H"" in total 
        ans = """"
        while n: 
            kk = comb(m+n-1, n-1) # (m+n-1 choose n-1) instructions starting with ""H""  
            if kk >= k: 
                ans += ""H""
                n -= 1
            else: 
                ans += ""V""
                m -= 1
                k -= kk 
        return ans + m*""V""",ye15
1646,https://leetcode.com/problems/get-maximum-in-generated-array/discuss/1754391/Python-O(1)-solution,"class Solution:
    def getMaximumGenerated(self, n: int) -> int:
        max_nums = [0, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 11, 11, 11, 11, 11, 11, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21]
        return max_nums[n]",wssx349
1647,https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/discuss/927527/Python3-most-to-least-frequent-characters,"class Solution:
    def minDeletions(self, s: str) -> int:
        freq = {} # frequency table 
        for c in s: freq[c] = 1 + freq.get(c, 0)
        
        ans = 0
        seen = set()
        for k in sorted(freq.values(), reverse=True): 
            while k in seen: 
                k -= 1 
                ans += 1
            if k: seen.add(k)
        return ans",ye15
1648,https://leetcode.com/problems/sell-diminishing-valued-colored-balls/discuss/927674/Python3-Greedy,"class Solution:
    def maxProfit(self, inventory: List[int], orders: int) -> int:
        inventory.sort(reverse=True) # inventory high to low 
        inventory += [0]
        ans = 0
        k = 1
        for i in range(len(inventory)-1): 
            if inventory[i] > inventory[i+1]: 
                if k*(inventory[i] - inventory[i+1]) < orders: 
                    ans += k*(inventory[i] + inventory[i+1] + 1)*(inventory[i] - inventory[i+1])//2 # arithmic sum 
                    orders -= k*(inventory[i] - inventory[i+1])
                else: 
                    q, r = divmod(orders, k)
                    ans += k*(2*inventory[i] - q + 1) * q//2 + r*(inventory[i] - q)
                    return ans % 1_000_000_007
            k += 1",ye15
1652,https://leetcode.com/problems/defuse-the-bomb/discuss/1903674/Python-Solution,"class Solution:
    def decrypt(self, code: List[int], k: int) -> List[int]:
        if k == 0:
            return [0] * len(code)
        data = code + code
        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]
		# result = []
        # for i in range(len(code)):
        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))
        if 0 > k:
            return result[k - 1:] + result[:k - 1]
        return result",hgalytoby
1653,https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/discuss/1020107/Python-DP-solution-easy-to-understand,"class Solution:
    def minimumDeletions(self, s: str) -> int:
        # track the minimum number of deletions to make the current string balanced ending with 'a', 'b'
        end_a, end_b = 0,0 
        for val in s:
            if val == 'a':
                # to end with 'a', nothing to do with previous ending with 'a'
                # to end with 'b', need to delete the current 'a' from previous ending with 'b'
                end_b += 1
            else:
                # to end with 'a', need to delete the current 'b' from previous ending with 'a'
                # to end with 'b', nothing to do, so just pick smaller of end_a, end_b
                end_a, end_b = end_a+1, min(end_a, end_b)
        return min(end_a, end_b)",cloverpku
1654,https://leetcode.com/problems/minimum-jumps-to-reach-home/discuss/1540090/Simple-BFS-oror-Clean-and-Concise-oror-Well-coded,"class Solution:
def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
    
    forbidden = set(forbidden)
    limit = max(x,max(forbidden))+a+b
    seen = set()
    q = [(0,0,False)]
    while q:
        p,s,isb = q.pop(0)
        if p>limit or p<0 or p in forbidden or (p,isb) in seen:
            continue
        
        if p==x:
            return s
        
        q.append((p+a,s+1,False))
        if not isb:
            q.append((p-b,s+1,True))
        seen.add((p,isb))
    
    return -1",abhi9Rai
1655,https://leetcode.com/problems/distribute-repeating-integers/discuss/1103429/Python3-backtracking,"class Solution:
    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
        freq = {}
        for x in nums: freq[x] = 1 + freq.get(x, 0)
        
        vals = sorted(freq.values(), reverse=True)
        quantity.sort(reverse=True) # pruning - large values first  
        
        def fn(i): 
            """"""Return True if possible to distribute quantity[i:] to remaining.""""""
            if i == len(quantity): return True 
            seen = set()
            for k in range(len(vals)): 
                if vals[k] >= quantity[i] and vals[k] not in seen: 
                    seen.add(vals[k]) # pruning - unqiue values 
                    vals[k] -= quantity[i]
                    if fn(i+1): return True 
                    vals[k] += quantity[i] # backtracking
                    
        return fn(0)",ye15
1657,https://leetcode.com/problems/determine-if-two-strings-are-close/discuss/935962/Python3-2-line-via-counter,"class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        cnt1, cnt2 = Counter(word1), Counter(word2)
        return cnt1.keys() == cnt2.keys() and sorted(cnt1.values()) == sorted(cnt2.values())",ye15
1658,https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/discuss/935986/Python3-O(N)-hash-table-of-prefix,"class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        mp = {0: 0}
        prefix = 0
        for i, num in enumerate(nums, 1): 
            prefix += num
            mp[prefix] = i 
            
        ans = mp.get(x, inf)
        for i, num in enumerate(reversed(nums), 1): 
            x -= num
            if x in mp and mp[x] + i <= len(nums): ans = min(ans, i + mp[x])
        return ans if ans < inf else -1",ye15
1659,https://leetcode.com/problems/maximize-grid-happiness/discuss/1132982/Python3-top-down-dp,"class Solution:
    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:
        
        @cache
        def fn(prev, i, j, intro, extro): 
            """"""Return max grid happiness at (i, j).""""""
            if i == m: return 0 # no more position
            if j == n: return fn(prev, i+1, 0, intro, extro)
            if intro == extro == 0: return 0 
            
            prev0 = prev[:j] + (0,) + prev[j+1:]
            ans = fn(prev0, i, j+1, intro, extro)
            if intro: 
                val = 120 
                if i and prev[j]: # neighbor from above 
                    val -= 30 
                    if prev[j] == 1: val -= 30 
                    else: val += 20 
                if j and prev[j-1]: # neighbor from left 
                    val -= 30 
                    if prev[j-1] == 1: val -= 30 
                    else: val += 20 
                prev0 = prev[:j] + (1,) + prev[j+1:]
                ans = max(ans, val + fn(prev0, i, j+1, intro-1, extro))
            if extro: 
                val = 40 
                if i and prev[j]: 
                    val += 20 
                    if prev[j] == 1: val -= 30 
                    else: val += 20 
                if j and prev[j-1]: 
                    val += 20 
                    if prev[j-1] == 1: val -= 30 
                    else: val += 20 
                prev0 = prev[:j] + (2,) + prev[j+1:]
                ans = max(ans, val + fn(prev0, i, j+1, intro, extro-1))
            return ans 
        
        return fn((0,)*n, 0, 0, introvertsCount, extrovertsCount)",ye15
1662,https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/discuss/944697/Python-3-or-Python-1-liner-or-No-explanation,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        return ''.join(word1) == ''.join(word2)",idontknoooo
1663,https://leetcode.com/problems/smallest-string-with-a-given-numeric-value/discuss/1871793/Python3-GREEDY-FILLING-()-Explained,"class Solution:
    def getSmallestString(self, n: int, k: int) -> str:
        res, k, i = ['a'] * n, k - n, n - 1
        while k:
            k += 1
            if k/26 >= 1:
                res[i], k, i = 'z', k - 26, i - 1
            else:
                res[i], k = chr(k + 96), 0

        return ''.join(res)",artod
1664,https://leetcode.com/problems/ways-to-make-a-fair-array/discuss/1775588/WEEB-EXPLAINS-PYTHONC%2B%2B-DPPREFIX-SUM-SOLN,"class Solution:
	def waysToMakeFair(self, nums: List[int]) -> int:
		if len(nums) == 1:
			return 1

		if len(nums) == 2:
			return 0

		prefixEven = sum(nums[2::2])
		prefixOdd = sum(nums[1::2])
		result = 0

		if prefixEven == prefixOdd and len(set(nums)) == 1:
			result += 1

		for i in range(1,len(nums)):
			if i == 1:
				prefixOdd, prefixEven = prefixEven, prefixOdd 

			if i > 1:
				if i % 2 == 0:
					prefixEven -= nums[i-1]
					prefixEven += nums[i-2]

				else:
					prefixOdd -= nums[i-1]
					prefixOdd += nums[i-2]

			if prefixOdd == prefixEven:
				result += 1

		return result",Skywalker5423
1665,https://leetcode.com/problems/minimum-initial-energy-to-finish-tasks/discuss/944714/Python-3-or-Sort-%2B-Greedy-and-Sort-%2B-Binary-Search-or-Explanation,"class Solution:
    def minimumEffort(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x: x[0]-x[1])
        def ok(mid):
            for actual, minimum in tasks:
                if minimum > mid or actual > mid: return False
                if minimum <= mid: mid -= actual
            return True
        l, r = 0, 10 ** 9
        while l <= r:
            mid = (l+r) // 2
            if ok(mid): r = mid - 1
            else: l = mid + 1
        return l",idontknoooo
1668,https://leetcode.com/problems/maximum-repeating-substring/discuss/1400359/Python3-Simple-Solution,"class Solution:
    def maxRepeating(self, sequence: str, word: str) -> int:
        i = 0
        while word*(i+1) in sequence:
            i+=1
        return i",Flerup
1669,https://leetcode.com/problems/merge-in-between-linked-lists/discuss/1833998/Python3-oror-Explanation-and-Example,"class Solution:
    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:
        curr=list1
        for count in range(b):
            if count==a-1:      # travel to a node and   --> step 1
                start=curr      # then save pointer in start
            curr=curr.next   # continue travel to b node  --> step 2
        start.next=list2     # point start to list2   --> step3
        while list2.next:    # travel list2   --> step 4
            list2=list2.next
        list2.next=curr.next  # map end of list2 to b
        return list1",rushi_javiya
1671,https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/discuss/1543614/Python-oror-Easy-Solution,"class Solution:
	def minimumMountainRemovals(self, lst: List[int]) -> int:
		l = len(lst)
		dp = [0] * l
		dp1 = [0] * l

		for i in range(l):   # for increasing subsequence
			maxi = 0
			for j in range(i):
				if lst[i] > lst[j]:
					if dp[j] > maxi:
						maxi = dp[j]

			dp[i] = maxi + 1

		for i in range(l - 1, -1, -1):  # for decreasing subsequence
			maxi1 = 0
			for j in range(l - 1, i, -1):
				if lst[i] > lst[j]:
					if dp1[j] > maxi1:
						maxi1 = dp1[j]

			dp1[i] = maxi1 + 1

		ans = 0
		for i in range(l):
			if dp[i] > 1 and dp1[i] > 1:
				temp = dp[i] + dp1[i] - 1
				if temp > ans:
					ans = temp

		return l - ans",naveenrathore
1672,https://leetcode.com/problems/richest-customer-wealth/discuss/2675823/Python-or-1-liner-simple-solution,"class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        return max([sum(acc) for acc in accounts])",LordVader1
1674,https://leetcode.com/problems/minimum-moves-to-make-array-complementary/discuss/1650877/Sweep-Algorithm-or-Explained-Python,"class Solution:  
    def minMoves(self, nums: List[int], limit: int) -> int:
        n = len(nums)
        overlay_arr = [0] * (2*limit+2)
        for i in range(n//2):
            left_boundary = min(nums[i], nums[n-1-i]) + 1
            no_move_value = nums[i] + nums[n-1-i]
            right_boundary = max(nums[i], nums[n-1-i]) + limit
            overlay_arr[left_boundary] -= 1
            overlay_arr[no_move_value] -= 1
            overlay_arr[no_move_value+1] += 1
            overlay_arr[right_boundary+1] += 1
        curr_moves = n   #initial assumption of two moves for each pair
        res = float(""inf"")
		# start Sweeping
        for i in range(2, 2*limit+1):
            curr_moves += overlay_arr[i]
            res = min(res, curr_moves)
        return res",xyz76
1675,https://leetcode.com/problems/minimize-deviation-in-array/discuss/1782626/Python-Simple-Python-Solution-By-SortedList,"class Solution:
	def minimumDeviation(self, nums: List[int]) -> int:

		from sortedcontainers import SortedList

		for i in range(len(nums)):

			if nums[i]%2!=0:
				nums[i]=nums[i]*2

		nums = SortedList(nums)

		result = 100000000000

		while True:
			min_value = nums[0]
			max_value = nums[-1]

			if max_value % 2 == 0:
				nums.pop()
				nums.add(max_value // 2)
				max_value = nums[-1]
				min_value = nums[0]

				result = min(result , max_value - min_value)
			else:
				result = min(result , max_value - min_value)
				break

		return result",ASHOK_KUMAR_MEGHVANSHI
1678,https://leetcode.com/problems/goal-parser-interpretation/discuss/961441/Python-one-liner,"class Solution:
    def interpret(self, command: str) -> str:
        return command.replace('()','o').replace('(al)','al')",lokeshsenthilkumar
1679,https://leetcode.com/problems/max-number-of-k-sum-pairs/discuss/2005867/Python-Simple-One-Pass,"class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        counter = defaultdict(int)
        
        count = 0
        for x in nums:
            comp = k - x
            if counter[comp]>0:
                counter[comp]-=1
                count+=1
            else:
                counter[x] +=1
        
        return count",constantine786
1680,https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/discuss/2612717/python-one-line-solution-94-beats,"class Solution:
    def concatenatedBinary(self, n: int) -> int:
        return int("""".join([bin(i)[2:] for i in range(1,n+1)]),2)%(10**9+7)",benon
1681,https://leetcode.com/problems/minimum-incompatibility/discuss/965262/Python3-backtracking,"class Solution:
    def minimumIncompatibility(self, nums: List[int], k: int) -> int:
        nums.sort()
        
        def fn(i, cand): 
            """"""Populate stack and compute minimum incompatibility.""""""
            nonlocal ans 
            if cand + len(nums) - i - sum(not x for x in stack) > ans: return 
            if i == len(nums): ans = cand
            else: 
                for ii in range(k): 
                    if len(stack[ii]) < len(nums)//k and (not stack[ii] or stack[ii][-1] != nums[i]) and (not ii or stack[ii-1] != stack[ii]): 
                        stack[ii].append(nums[i])
                        if len(stack[ii]) == 1: fn(i+1, cand)
                        else: fn(i+1, cand + stack[ii][-1] - stack[ii][-2])
                        stack[ii].pop()
        
        ans = inf
        stack = [[] for _ in range(k)]
        fn(0, 0)
        return ans if ans < inf else -1",ye15
1684,https://leetcode.com/problems/count-the-number-of-consistent-strings/discuss/1054303/Python-simple-one-liner,"class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        return sum(set(allowed) >= set(i) for i in words)",angelique_
1685,https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/discuss/1439047/Python-3-or-O(N)-Prefix-Sum-Clean-or-Explanation,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        pre_sum = [0]
        for num in nums:                                     # calculate prefix sum
            pre_sum.append(pre_sum[-1] + num)
        n = len(nums)                                        # render the output
        return [(num*(i+1) - pre_sum[i+1]) + (pre_sum[-1]-pre_sum[i] - (n-i)*num) for i, num in enumerate(nums)]",idontknoooo
1686,https://leetcode.com/problems/stone-game-vi/discuss/1860830/python-easy-solution-using-sort,"class Solution:
    def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:
        n = len(alice)
        arr = [alice[i] + bob[i] for i in range(n)]
        s = sum(bob)
        res = 0
        k = (n+1)//2
        arr.sort(reverse=True)
        for i in range(0, n, 2):
            res += arr[i]
        
        
        if res > s:
            return 1
        elif res == s:
            return 0 
        else:
            return -1",byuns9334
1687,https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/discuss/1465884/Python3-dp-%2B-greedy,"class Solution:
    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:
        dp = [0] + [inf]*len(boxes)
        trips = 2
        ii = 0
        for i in range(len(boxes)):
            maxWeight -= boxes[i][1]
            if i and boxes[i-1][0] != boxes[i][0]: trips += 1
            while maxBoxes < i - ii + 1 or maxWeight < 0 or ii < i and dp[ii] == dp[ii+1]:
                maxWeight += boxes[ii][1]
                if boxes[ii][0] != boxes[ii+1][0]: trips-=1
                ii += 1
            dp[i+1] = dp[ii] + trips
        return dp[-1]",ye15
1688,https://leetcode.com/problems/count-of-matches-in-tournament/discuss/1276389/simple-python-solution-easy-to-understand,"class Solution:
	def numberOfMatches(self, n: int) -> int:

		# the logic is, among n teams only 1 team will won, so n-1 teams will lose
		# hence there will be n-1 match (so that n-1 teams can lose) 

		return n-1",nandanabhishek
1689,https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/discuss/2202648/C%2B%2BJavaPython-Easy-One-liner-with-explanation,"class Solution:
    def minPartitions(self, n: str) -> int:
        return int(max(n))",constantine786
1690,https://leetcode.com/problems/stone-game-vii/discuss/971804/Python3-Easy-code-with-explanation-DP,"class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        dp = [[0 for _ in range(len(stones))] for _ in range(len(stones))]     # dp table n x n
        run_sum = [0]                            # running sum -> sum [i..j] = run_sum[j] - run_sum[i]
        s = 0
        
		## Calculation of running sum
        for i in stones:
            s += i
            run_sum.append(s)
		
        n = len(stones) 
        
        for k in range(1, n):               # no. of stones left
            for i in range(0, n - k):   # from each starting point
                remove_i_stone = (run_sum[i+k+1] - run_sum[i+1])    # score after removing i th stone
                remove_j_stone = (run_sum[i+k] - run_sum[i])             # score after removing j th stone
                
                if (n-(k+1))%2 == 0:        # alice's move 
                    dp[i][i+k] = max(remove_i_stone + dp[i+1][i+k],
                                    remove_j_stone + dp[i][i+k-1])
                else:                       # bob's move
                    dp[i][i+k] = min(-remove_i_stone + dp[i+1][i+k],
                                    - remove_j_stone + dp[i][i+k-1])
                    
        return dp[0][n - 1]",mihirrane
1691,https://leetcode.com/problems/maximum-height-by-stacking-cuboids/discuss/970397/Python-3-or-DP-Sort-O(N2)-or-Explanation,"class Solution:
    def maxHeight(self, cuboids: List[List[int]]) -> int:
        cuboids = sorted([sorted(cub) for cub in cuboids], reverse=True)   # sort LxWxH in cube, then sort cube reversely
        ok = lambda x, y: (x[0] >= y[0] and x[1] >= y[1] and x[2] >= y[2]) # make a lambda function to verify whether y can be put on top of x
        n = len(cuboids)
        dp = [cu[2] for cu in cuboids]                                     # create dp array
        ans = max(dp)
        for i in range(1, n):                                              # iterate over each cube
            for j in range(i):                                             # compare with previous calculated cube
                if ok(cuboids[j], cuboids[i]):                             # update dp[i] if cube[i] can be put on top of cube[j]
                    dp[i] = max(dp[i], dp[j] + cuboids[i][2])              # always get the maximum
            ans = max(ans, dp[i])                                          # record the largest value
        return ans",idontknoooo
1694,https://leetcode.com/problems/reformat-phone-number/discuss/978512/Python3-string-processing,"class Solution:
    def reformatNumber(self, number: str) -> str:
        number = number.replace(""-"", """").replace("" "", """") # removing - and space 
        ans = []
        for i in range(0, len(number), 3): 
            if len(number) - i != 4: ans.append(number[i:i+3])
            else: 
                ans.extend([number[i:i+2], number[i+2:]])
                break 
        return ""-"".join(ans)",ye15
1695,https://leetcode.com/problems/maximum-erasure-value/discuss/2140512/Python-Easy-2-approaches,"class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        counter=defaultdict(int) # track count of  elements in the window
        res=i=tot=0
		
        for j in range(len(nums)):
            x=nums[j]   
            tot+=x
            counter[x]+=1
            # adjust the left bound of sliding window until you get all unique elements
            while i < j and counter[x]>1: 
                counter[nums[i]]-=1
                tot-=nums[i]
                i+=1
            
            res=max(res, tot)            
        return res",constantine786
1696,https://leetcode.com/problems/jump-game-vi/discuss/978563/Python3-range-max,"class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        pq = [] # max heap 
        for i in reversed(range(len(nums))): 
            while pq and pq[0][1] - i > k: heappop(pq)
            ans = nums[i] - pq[0][0] if pq else nums[i]
            heappush(pq, (-ans, i))
        return ans",ye15
1697,https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/discuss/981352/Python3-Union-find,"class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:
        
        parent = [i for i in range(n+1)]
    
        rank = [0 for i in range(n+1)]

        def find(parent, x):

            if parent[x] == x:
                return x
            parent[x] = find(parent, parent[x])
            return parent[x]

        def union(parent, a, b):

            a = find(parent, a)
            b = find(parent, b)

            if a == b:
                return 

            if rank[a] < rank[b]:
                parent[a] = b
            elif rank[a] > rank[b]:
                parent[b] = a
            else:
                parent[b] = a
                rank[a] += 1
                
        edgeList.sort(key = lambda x: x[2])
        res = [0] * len(queries)
        queries = [[i, ch] for i, ch in enumerate(queries)]
        queries.sort(key = lambda x: x[1][2])
        
        ind = 0
        for i, (a, b, w) in queries:
            
            while ind < len(edgeList) and edgeList[ind][2] < w:
                union(parent, edgeList[ind][0], edgeList[ind][1])
                ind += 1
                
            res[i] = find(parent, a) == find(parent, b)
        return res",ermolushka2
1700,https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/discuss/1228863/Python3-32ms-Brute-Force-Solution,"class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        curr = 0
        
        while students:
            if(students[0] == sandwiches[0]):
                curr = 0
                students.pop(0)
                sandwiches.pop(0)
            else:
                curr += 1
                students.append(students.pop(0))
            
            if(curr >= len(students)):
                break
        
        return len(students)",VoidCupboard
1701,https://leetcode.com/problems/average-waiting-time/discuss/1236349/Python3-Simple-And-Fast-Solution,"class Solution:
    def averageWaitingTime(self, customers: List[List[int]]) -> float:
        arr = []
        
        time = 0
        
        for i , j in customers:
            if(i > time):
                time = i + j
            else:
                time += j
            arr.append(time - i)
        
        return sum(arr) / len(arr)",VoidCupboard
1702,https://leetcode.com/problems/maximum-binary-string-after-change/discuss/1382851/python-3-oror-clean-oror-easy-approach,"lass Solution:
    def maximumBinaryString(self, s: str) -> str:
        #count of 0
        c=0
        #final ans string will contain only one zero.therefore shift the first 0  to c places.Initialize ans string with all 1s
        lst=[""1""]*len(s)
        for i in range (0,len(s)):
            if s[i]==""0"":
                c+=1
        for i in range (0,len(s)):
		#finding the ist 0
            if s[i]==""0"":
                lst[i+c-1]=""0""
                return """".join(lst)
        return s",minato_namikaze
1703,https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/discuss/1002574/Python3-1-pass-O(N),"class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        ii = val = 0 
        ans = inf
        loc = [] # location of 1s
        for i, x in enumerate(nums): 
            if x: 
                loc.append(i)
                m = (ii + len(loc) - 1)//2 # median 
                val += loc[-1] - loc[m] - (len(loc)-ii)//2 # adding right 
                if len(loc) - ii > k: 
                    m = (ii + len(loc))//2 # updated median 
                    val -= loc[m] - loc[ii] - (len(loc)-ii)//2 # removing left 
                    ii += 1
                if len(loc)-ii == k: ans = min(ans, val) # len(ones) - ii effective length
        return ans",ye15
1704,https://leetcode.com/problems/determine-if-string-halves-are-alike/discuss/991430/Runtime-is-faster-than-98-and-the-memory-usage-is-less-than-90-Python-3-Accepted,"class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        vowels = set('aeiouAEIOU')
        count = 0
        for i in range(len(s)//2):
            if s[i] in vowels:
                count+=1
            if s[-i-1] in vowels:
                count-=1

        return count == 0",WiseLin
1705,https://leetcode.com/problems/maximum-number-of-eaten-apples/discuss/988437/Python3-priority-queue,"class Solution:
    def eatenApples(self, apples: List[int], days: List[int]) -> int:
        ans = 0
        
        pq = [] # min-heap 
        for i, (x, d) in enumerate(zip(apples, days)): 
            while pq and pq[0][0] <= i: heappop(pq) # rotten 
            if x: heappush(pq, (i+d, x))
            if pq: 
                ii, x = heappop(pq)
                if x-1: heappush(pq, (ii, x-1))
                ans += 1
        
        i += 1
        while pq: 
            ii, x = heappop(pq)
            x = min(x, ii-i)
            ans += x
            i += x 
        return ans",ye15
1706,https://leetcode.com/problems/where-will-the-ball-fall/discuss/1443268/Python-3-or-DFS-Simulation-or-Explanation,"class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0])
        @cache
        def helper(r, c):
            if r == m:
                return c
            elif grid[r][c] == 1 and c+1 < n and grid[r][c+1] == 1:
                return helper(r+1, c+1)
            elif grid[r][c] == -1 and 0 <= c-1 and grid[r][c-1] == -1:
                return helper(r+1, c-1)
            else:
                return -1
            
        return [helper(0, j) for j in range(n)]",idontknoooo
1707,https://leetcode.com/problems/maximum-xor-with-an-element-from-array/discuss/988468/Python3-trie,"class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        nums.sort()
        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))
        ans = [-1]*len(queries)
        
        trie = {}
        k = 0
        for m, x, i in queries: 
            while k < len(nums) and nums[k] <= m: 
                node = trie
                val = bin(nums[k])[2:].zfill(32)
                for c in val: node = node.setdefault(int(c), {})
                node[""#""] = nums[k]
                k += 1
            if trie: 
                node = trie
                val = bin(x)[2:].zfill(32)
                for c in val: node = node.get(1-int(c)) or node.get(int(c))
                ans[i] = x ^ node[""#""]
        return ans",ye15
1710,https://leetcode.com/problems/maximum-units-on-a-truck/discuss/999230/Python-Simple-solution,"class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        boxTypes.sort(key=lambda x:x[1],reverse=1)
        s=0
        for i,j in boxTypes:
            i=min(i,truckSize)
            s+=i*j
            truckSize-=i
            if truckSize==0:
                break
        return s",lokeshsenthilkumar
1711,https://leetcode.com/problems/count-good-meals/discuss/999170/Python3-frequency-table,"class Solution:
    def countPairs(self, deliciousness: List[int]) -> int:
        ans = 0
        freq = defaultdict(int)
        for x in deliciousness: 
            for k in range(22): ans += freq[2**k - x]
            freq[x] += 1
        return ans % 1_000_000_007",ye15
1712,https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/discuss/999157/Python3-binary-search-and-2-pointer,"class Solution:
    def waysToSplit(self, nums: List[int]) -> int:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        ans = 0
        for i in range(1, len(nums)): 
            j = bisect_left(prefix, 2*prefix[i])
            k = bisect_right(prefix, (prefix[i] + prefix[-1])//2)
            ans += max(0, min(len(nums), k) - max(i+1, j))
        return ans % 1_000_000_007",ye15
1713,https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/discuss/999141/Python3-binary-search,"class Solution:
    def minOperations(self, target: List[int], arr: List[int]) -> int:
        loc = {x: i for i, x in enumerate(target)}
        stack = []
        for x in arr: 
            if x in loc: 
                i = bisect_left(stack, loc[x])
                if i < len(stack): stack[i] = loc[x]
                else: stack.append(loc[x])
        return len(target) - len(stack)",ye15
1716,https://leetcode.com/problems/calculate-money-in-leetcode-bank/discuss/1138960/Python-3-very-easy-solution,"class Solution:
    def totalMoney(self, n: int) -> int:
        res,k=0,0
        for i in range(n):
            if i%7==0:
                k+=1
            res+=k+(i%7)
        return res",lin11116459
1717,https://leetcode.com/problems/maximum-score-from-removing-substrings/discuss/1009152/Python-solution-with-explanation,"class Solution:
    def maximumGain(self, s: str, x: int, y: int) -> int:
		# to calculate first, high value of x or y
        a, b = 'ab', 'ba'
        if y > x:
            b, a, y, x = a, b, x, y

        answer = 0
        
        for word in [a, b]:
            stack = []

            i = 0
            while i < len(s):
                stack.append(s[i])
                
                n = len(stack)
                prefix = stack[n-2] + stack[n-1]
                # if see the prefix ab or ba move from stack and increment the answer
                if prefix == word:
                    answer += x
                    stack.pop()
                    stack.pop()
                i += 1
            # change the x point to y for 2nd iteration
            x = y
            
            # assign new letters with already removed prefix
            s = ''.join(stack)
        return answer",just_4ina
1718,https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/discuss/1008948/Python-Greedy%2BBacktracking-or-Well-Explained-or-Comments,"class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        
        arr = [0]*(2*n-1)     # the array we want to put numbers. 0 means no number has been put here
        i = 0                 # current index to put a number                
        vi = [False] * (n+1)  # check if we have used that number
        
		# backtracking
        def dfs(arr, i, vi):
		    # if we already fill the array successfully, return True
            if i >= (2*n-1):
                return True
				
			# try each number from n to 1
            for x in range(n, 0, -1):
			    # two cases:
			    # x > 1, we check two places. Mind index out of bound here.
			    # x = 1, we only check one place
				# arr[i] == 0 means index i is not occupied
                if (x > 1 and ((not (arr[i] == 0 and (i+x < 2*n-1) and arr[i+x] == 0)) or vi[x]))  \
					or (x == 1 and (arr[i] != 0 or vi[x])):
                    continue
				
				# if it can be placed, then place it
                if x > 1:
                    arr[i] = x
                    arr[i+x] = x
                else:
                    arr[i] = x
                vi[x] = True
				
				# find the next available place
                nexti = i+1
                while nexti < 2*n-1 and arr[nexti]:
                    nexti += 1
				
				# place the next one
                if dfs(arr, nexti, vi):
					# if it success, it is already the lexicographically largest one, we don't search anymore
                    return True
					
				# backtracking... restore the state
                if x > 1:
                    arr[i] = 0
                    arr[i+x] = 0
                else:
                    arr[i] = 0
                vi[x] = False
			
			# we could not find a solution, return False
            return False
		
        dfs(arr, i, vi)
        return arr",etoss
1719,https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/discuss/1128518/Python3-greedy,"class Solution:
    def checkWays(self, pairs: List[List[int]]) -> int:
        graph = {}
        for x, y in pairs: 
            graph.setdefault(x, set()).add(y)
            graph.setdefault(y, set()).add(x)
        
        ans = 1 
        ancestors = set()
        for n in sorted(graph, key=lambda x: len(graph[x]), reverse=True): 
            p = min(ancestors &amp; graph[n], key=lambda x: len(graph[x]), default=None) # immediate ancestor 
            ancestors.add(n)
            if p: 
                if graph[n] - (graph[p] | {p}): return 0 # impossible to have more than ancestor
                if len(graph[n]) == len(graph[p]): ans = 2
            elif len(graph[n]) != len(graph)-1: return 0
        return ans",ye15
1720,https://leetcode.com/problems/decode-xored-array/discuss/1075067/Python-1-Liner-(List-Comprehension-with-Assignment-Expresion),"class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        return [first] + [first:= first ^ x for x in encoded]",leeteatsleep
1721,https://leetcode.com/problems/swapping-nodes-in-a-linked-list/discuss/1911996/Python-Simple-Solution-with-Explanation,"class Solution:
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        l = head  # left node
        for _ in range(k-1):
            l = l.next
        # the rest of the code logic here",zayne-siew
1722,https://leetcode.com/problems/minimize-hamming-distance-after-swap-operations/discuss/1982743/Python3-solution,"class Solution:
    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:
        def gen_adjacency():
            adj = {}
            for i in range(len(source)):
                adj[i] = []
            for a, b in allowedSwaps:
                adj[a].append(b)
                adj[b].append(a)
            return adj
        
        def dfs(i):
            visited.add(i)
            this_group.add(i)
            for neigh in adj[i]:
                if neigh not in visited:
                    dfs(neigh)

        adj = gen_adjacency()
        visited = set()
        common_counts = 0
        for i in adj:
            if i not in visited:
                this_group = set()
                dfs(i)
                s_counts = collections.Counter([source[i] for i in this_group])
                t_counts = collections.Counter([target[i] for i in this_group])
                common = set(s_counts).intersection(t_counts)
                for common_int in common:
                    common_counts += min(s_counts[common_int], t_counts[common_int])
        ans = len(source) - common_counts
        return ans",dalechoi
1723,https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009859/Python3-backtracking,"class Solution:
    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:
        jobs.sort(reverse=True)
        
        def fn(i):
            """"""Assign jobs to worker and find minimum time.""""""
            nonlocal ans 
            if i == len(jobs): ans = max(time)
            else: 
                for kk in range(k): 
                    if not kk or time[kk-1] > time[kk]: 
                        time[kk] += jobs[i]
                        if max(time) < ans: fn(i+1)
                        time[kk] -= jobs[i]
            
        ans = inf
        time = [0]*k
        fn(0)
        return ans",ye15
1725,https://leetcode.com/problems/number-of-rectangles-that-can-form-the-largest-square/discuss/1020629/Python3-freq-table,"class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        freq = {}
        for l, w in rectangles: 
            x = min(l, w)
            freq[x] = 1 + freq.get(x, 0)
        return freq[max(freq)]",ye15
1726,https://leetcode.com/problems/tuple-with-same-product/discuss/1020657/Python3-freq-table,"class Solution:
    def tupleSameProduct(self, nums: List[int]) -> int:
        ans = 0
        freq = {}
        for i in range(len(nums)):
            for j in range(i+1, len(nums)): 
                key = nums[i] * nums[j]
                ans += freq.get(key, 0)
                freq[key] = 1 + freq.get(key, 0)
        return 8*ans",ye15
1727,https://leetcode.com/problems/largest-submatrix-with-rearrangements/discuss/1020589/Simple-Python3-or-9-Lines-or-Beats-100-or-Detailed-Explanation,"class Solution:
    def largestSubmatrix(self, matrix: List[List[int]]) -> int:
        m, n, ans = len(matrix), len(matrix[0]), 0
        
        for j in range(n):
            for i in range(1, m):
                matrix[i][j] += matrix[i-1][j] if matrix[i][j] else 0
                
        for i in range(m): 
            matrix[i].sort(reverse=1)
            for j in range(n):
                ans = max(ans, (j+1)*matrix[i][j])
        return ans",sushanthsamala
1728,https://leetcode.com/problems/cat-and-mouse-ii/discuss/1020616/Python3-Clean-and-Commented-Top-down-DP-with-the-early-stopping-trick,"class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
        m, n = len(grid), len(grid[0])
        mouse_pos = cat_pos = None
		available = 0 # available steps for mouse and cat
		# Search the start pos of mouse and cat
        for i in range(m):
            for j in range(n):
				if grid[i][j] != '#':
                    available += 1
                if grid[i][j] == 'M':
                    mouse_pos = (i, j)
                elif grid[i][j] == 'C':
                    cat_pos = (i, j)
        
        @functools.lru_cache(None)
        def dp(turn, mouse_pos, cat_pos):
            # if turn == m * n * 2:
			# We already search the whole grid (9372 ms 74.3 MB)
			if turn == available * 2:
				# We already search the whole touchable grid (5200 ms 57.5 MB)
                return False
            if turn % 2 == 0:
                # Mouse
                i, j = mouse_pos
                for di, dj in dirs:
                    for jump in range(mouseJump + 1):
						# Note that we want to do range(mouseJump + 1) instead of range(1, mouseJump + 1)
						# considering the case that we can stay at the same postion for next turn.
                        new_i, new_j = i + di * jump, j + dj * jump
                        if 0 <= new_i < m and 0 <= new_j < n and grid[new_i][new_j] != '#':
							# Valid pos
                            if dp(turn + 1, (new_i, new_j), cat_pos) or grid[new_i][new_j] == 'F':
                                return True
                        else:
							# Stop extending the jump since we cannot go further
                            break
                return False
            else:
                # Cat
                i, j = cat_pos
                for di, dj in dirs:
                    for jump in range(catJump + 1):
                        new_i, new_j = i + di * jump, j + dj * jump
                        if 0 <= new_i < m and 0 <= new_j < n and grid[new_i][new_j] != '#':
                            if not dp(turn + 1, mouse_pos, (new_i, new_j)) or (new_i, new_j) == mouse_pos or grid[new_i][new_j] == 'F':
							# This condition will also handle the case that the cat cannot jump through the mouse
                                return False
                        else:
                            break
                return True
				
        return dp(0, mouse_pos, cat_pos)",GBLin5566
1732,https://leetcode.com/problems/find-the-highest-altitude/discuss/1223440/24ms-Python-(with-comments),"class Solution(object):
    def largestAltitude(self, gain):
        """"""
        :type gain: List[int]
        :rtype: int
        """"""
		#initialize a variable to store the end output
        result = 0
		#initialize a variable to keep track of the altitude at each iteration
        current_altitude=0
		#looping through each of the gains
        for g in gain:
		#updating the current altitude based on the gain
            current_altitude += g
			#if the current altitude is greater than the highest altitude recorded then assign it as the result. This done iteratively, allows us to find the highest altitude
            if current_altitude > result:
                result = current_altitude
        return result",Akshar-code
1733,https://leetcode.com/problems/minimum-number-of-people-to-teach/discuss/1059885/Python3-count-properly,"class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        m = len(languages)
        languages = [set(x) for x in languages]
        
        mp = {}
        for u, v in friendships: 
            if not languages[u-1] &amp; languages[v-1]: 
                for i in range(n):
                    if i+1 not in languages[u-1]: mp.setdefault(u-1, set()).add(i)
                    if i+1 not in languages[v-1]: mp.setdefault(v-1, set()).add(i)
        
        ans = inf
        for i in range(n): 
            val = 0
            for k in range(m): 
                if i in mp.get(k, set()): val += 1
            ans = min(ans, val)
        return ans",ye15
1734,https://leetcode.com/problems/decode-xored-permutation/discuss/1031227/Python-or-Detailed-Exeplanation-by-finding-the-first-one,"class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        n = len(encoded)+1
        XOR = 0
        for i in range(1,n+1):
            XOR = XOR^i
        
        s = 0
        for i in range(1,n,2):
            s = s^encoded[i]
        res = [0]*n
        res[0] = XOR^s
        
        for j in range(1,n):
            res[j] = res[j-1]^encoded[j-1]
        return res",jmin3
1735,https://leetcode.com/problems/count-ways-to-make-array-with-product/discuss/1355240/No-Maths-Just-Recursion-DP-we-can-come-up-with-in-interviews-greater-WA,"class Solution:
    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
        # brute DP O(NK) where N is max(q[0]) and K is max(q[1])
        @cache
        def dp(n,k):
            
            if k == 1 or n == 1: return 1
            ways = 0
            for factor in range(1, k+1):
                if k % factor == 0:
                    ways += dp(n-1, k//factor) # or take the '3' part
                    ways %= (10**9+7)
            return ways % (10**9+7)
        
        res = [0] * len(queries)
        for i,(n, k) in enumerate(queries):
            res[i] = dp(n,k)
        
        return res
            
        # better solution -> find out how many prime factors a number has.
        # how many ways to group P numbers into N groups (since array has N values only)
        # but you can group in lesser groups and keep 1 1 1 1 as padding in array :(",yozaam
1736,https://leetcode.com/problems/latest-time-by-replacing-hidden-digits/discuss/1032030/Python3-if-elif,"class Solution:
    def maximumTime(self, time: str) -> str:
        time = list(time)
        for i in range(len(time)): 
            if time[i] == ""?"": 
                if i == 0: time[i] = ""2"" if time[i+1] in ""?0123"" else ""1""
                elif i == 1: time[i] = ""3"" if time[0] == ""2"" else ""9""
                elif i == 3: time[i] = ""5""
                else: time[i] = ""9""
        return """".join(time)",ye15
1737,https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/discuss/1032055/Python3-scan-through-a-z-w-prefix,"class Solution:
    def minCharacters(self, a: str, b: str) -> int:
        pa, pb = [0]*26, [0]*26
        for x in a: pa[ord(x)-97] += 1
        for x in b: pb[ord(x)-97] += 1
        
        ans = len(a) - max(pa) + len(b) - max(pb) # condition 3
        for i in range(25): 
            pa[i+1] += pa[i]
            pb[i+1] += pb[i]
            ans = min(ans, pa[i] + len(b) - pb[i]) # condition 2
            ans = min(ans, len(a) - pa[i] + pb[i]) # condition 1
        return ans",ye15
1738,https://leetcode.com/problems/find-kth-largest-xor-coordinate-value/discuss/1032117/Python3-compute-xor-O(MNlog(MN))-or-O(MNlogK)-or-O(MN),"class Solution:
    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:
        m, n = len(matrix), len(matrix[0]) # dimensions 
        
        ans = []
        for i in range(m): 
            for j in range(n): 
                if i: matrix[i][j] ^= matrix[i-1][j]
                if j: matrix[i][j] ^= matrix[i][j-1]
                if i and j: matrix[i][j] ^= matrix[i-1][j-1]
                ans.append(matrix[i][j])
        return sorted(ans)[-k]",ye15
1739,https://leetcode.com/problems/building-boxes/discuss/1032104/Python3-math,"class Solution:
    def minimumBoxes(self, n: int) -> int:
        x = int((6*n)**(1/3))
        if x*(x+1)*(x+2) > 6*n: x -= 1
        
        ans = x*(x+1)//2
        n -= x*(x+1)*(x+2)//6
        k = 1
        while n > 0: 
            ans += 1
            n -= k
            k += 1
        return ans",ye15
1742,https://leetcode.com/problems/maximum-number-of-balls-in-a-box/discuss/1042922/Python3-freq-table,"class Solution:
    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        freq = defaultdict(int)
        for x in range(lowLimit, highLimit+1):
            freq[sum(int(xx) for xx in str(x))] += 1
        return max(freq.values())",ye15
1743,https://leetcode.com/problems/restore-the-array-from-adjacent-pairs/discuss/1042939/Python3-graph,"class Solution:
    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
        graph = {}
        for u, v in adjacentPairs: 
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)
        
        ans = []
        seen = set()
        stack = [next(x for x in graph if len(graph[x]) == 1)]
        while stack: 
            n = stack.pop()
            ans.append(n)
            seen.add(n)
            for nn in graph[n]: 
                if nn not in seen: stack.append(nn)
        return ans",ye15
1744,https://leetcode.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/discuss/1042952/Python3-greedy,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum 
        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",ye15
1745,https://leetcode.com/problems/palindrome-partitioning-iv/discuss/1042964/Python3-dp,"class Solution:
    def checkPartitioning(self, s: str) -> bool:
        mp = {}
        for i in range(2*len(s)-1): 
            lo, hi = i//2, (i+1)//2
            while 0 <= lo <= hi < len(s) and s[lo] == s[hi]: 
                mp.setdefault(lo, set()).add(hi)
                lo -= 1
                hi += 1
        
        @lru_cache(None)
        def fn(i, k): 
            """"""Return True if s[i:] can be split into k palindromic substrings.""""""
            if k < 0: return False 
            if i == len(s): return k == 0
            return any(fn(ii+1, k-1) for ii in mp[i])
        
        return fn(0, 3)",ye15
1748,https://leetcode.com/problems/sum-of-unique-elements/discuss/1103188/Runtime-97-or-Python-easy-hashmap-solution,"class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        hashmap = {}
        for i in nums:
            if i in hashmap.keys():
                hashmap[i] += 1
            else:
                hashmap[i] = 1
        sum = 0
        for k, v in hashmap.items():
            if v == 1: sum += k
        return sum",vanigupta20024
1749,https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/discuss/1056653/Python3-Kadane's-algo,"class Solution:
    def maxAbsoluteSum(self, nums: List[int]) -> int:
        ans = mx = mn = 0
        for x in nums: 
            mx = max(mx + x, 0)
            mn = min(mn + x, 0)
            ans = max(ans, mx, -mn)
        return ans",ye15
1750,https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/discuss/1056664/Python3-3-approaches,"class Solution:
    def minimumLength(self, s: str) -> int:
        dd = deque(s)
        while len(dd) >= 2 and dd[0] == dd[-1]:
            ch = dd[0]
            while dd and dd[0] == ch: dd.popleft()
            while dd and dd[-1] == ch: dd.pop()
        return len(dd)",ye15
1751,https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/discuss/1103634/Python3-(DP)-Simple-Solution-Explained,"class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        
        # The number of events
        n = len(events)
        # Sort the events in chronological order
        events.sort()
        
        # k is the number of events we can attend
        # end is the last event we attended's END TIME
        # event_index is the current event we are checking
        @lru_cache(None)
        def dp(end: int, event_index: int, k: int):
            
            # No more events left or we have checked all possible events
            if k == 0 or event_index == n:
                return 0
            
            event = events[event_index]
            event_start, event_end, event_value = event
            # Can we attend this event?
            # Does its start time conflict with the previous events end time?
            # If the start time is the same as the end time we cannot end as well (view example 2)
            if event_start <= end:
                # Could not attend, check the next event
                return dp(end, event_index + 1, k)
            
            # We made it here, so we can attend!
            # Two possible options, we either attend (add the value) or do not attend this event
            # Value for attending versus the value for skipping
            attend = event_value + dp(event_end, event_index + 1, k - 1)
            skip = dp(end, event_index + 1, k)
            
            # Get the best option
            return max(attend, skip)
            
        # Clear cache to save memory
        dp.cache_clear()
        return dp(0, 0, k)",scornz
1752,https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/discuss/1053871/Python-Slicing-(easy-to-understand),"class Solution:
    def check(self, nums: List[int]) -> bool:
        i = 0
        while i<len(nums)-1:
            if nums[i]>nums[i+1]: break    # used to find the rotated position
            i+=1
        
        rotated = nums[i+1:]+nums[:i+1]
        for i,e in enumerate(rotated):
            if i<len(rotated)-1 and e>rotated[i+1]:   # check that rerotated array sorted or not
                return False
        return True",qwe9
1753,https://leetcode.com/problems/maximum-score-from-removing-stones/discuss/1053645/Python3-math,"class Solution:
    def maximumScore(self, a: int, b: int, c: int) -> int:
        a, b, c = sorted((a, b, c))
        if a + b < c: return a + b
        return (a + b + c)//2",ye15
1755,https://leetcode.com/problems/closest-subsequence-sum/discuss/1053790/Python3-divide-in-half,"class Solution:
    def minAbsDifference(self, nums: List[int], goal: int) -> int:
        
        def fn(nums):
            ans = {0}
            for x in nums: 
                ans |= {x + y for y in ans}
            return ans 
        
        nums0 = sorted(fn(nums[:len(nums)//2]))
        
        ans = inf
        for x in fn(nums[len(nums)//2:]): 
            k = bisect_left(nums0, goal - x)
            if k < len(nums0): ans = min(ans, nums0[k] + x - goal)
            if 0 < k: ans = min(ans, goal - x - nums0[k-1])
        return ans",ye15
1758,https://leetcode.com/problems/minimum-changes-to-make-alternating-binary-string/discuss/1437401/Python3-solution-or-O(n)-or-Explained,"class Solution:
    def minOperations(self, s: str) -> int:
        count = 0
        count1 = 0
        for i in range(len(s)):
            if i % 2 == 0:
                if s[i] == '1':
                    count += 1
                if s[i] == '0':
                    count1 += 1
            else:
                if s[i] == '0':
                    count += 1
                if s[i] == '1':
                    count1 += 1
        return min(count, count1)",FlorinnC1
1759,https://leetcode.com/problems/count-number-of-homogenous-substrings/discuss/1064598/Python-one-pass-with-explanation,"class Solution:
    def countHomogenous(self, s: str) -> int:
        res, count, n = 0, 1, len(s)
        for i in range(1,n):
            if s[i]==s[i-1]:
                count+=1
            else:
                if count>1:
                    res+=(count*(count-1)//2)
                count=1    
        if count>1:
            res+=(count*(count-1)//2)
        return (res+n)%(10**9+7)",ajith6198
1760,https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/discuss/1064572/Python3-binary-search,"class Solution:
    def minimumSize(self, nums: List[int], maxOperations: int) -> int:
        lo, hi = 1, 1_000_000_000
        while lo < hi: 
            mid = lo + hi >> 1
            if sum((x-1)//mid for x in nums) <= maxOperations: hi = mid
            else: lo = mid + 1
        return lo",ye15
1761,https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/discuss/1065724/Python3-brute-force,"class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        graph = [[False]*n for _ in range(n)]
        degree = [0]*n
        
        for u, v in edges: 
            graph[u-1][v-1] = graph[v-1][u-1] = True
            degree[u-1] += 1
            degree[v-1] += 1
        
        ans = inf
        for i in range(n): 
            for j in range(i+1, n):
                if graph[i][j]: 
                    for k in range(j+1, n):
                        if graph[j][k] and graph[k][i]: 
                            ans = min(ans, degree[i] + degree[j] + degree[k] - 6)
        return ans if ans < inf else -1",ye15
1763,https://leetcode.com/problems/longest-nice-substring/discuss/1074546/Python3-brute-force-and-divide-and-conquer,"class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        ans = """"
        for i in range(len(s)):
            for ii in range(i+1, len(s)+1):
                if all(s[k].swapcase() in s[i:ii] for k in range(i, ii)): 
                    ans = max(ans, s[i:ii], key=len)
        return ans",ye15
1764,https://leetcode.com/problems/form-array-by-concatenating-subarrays-of-another-array/discuss/1074555/Python3-check-group-one-by-one,"class Solution:
    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:
        i = 0
        for grp in groups: 
            for ii in range(i, len(nums)):
                if nums[ii:ii+len(grp)] == grp: 
                    i = ii + len(grp)
                    break 
            else: return False
        return True",ye15
1765,https://leetcode.com/problems/map-of-highest-peak/discuss/1074561/Python3-bfs,"class Solution:
    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:
        m, n = len(isWater), len(isWater[0]) # dimensions 
        queue = [(i, j) for i in range(m) for j in range(n) if isWater[i][j]]
        
        ht = 0
        ans = [[0]*n for _ in range(m)]
        seen = set(queue)
        
        while queue: 
            newq = []
            for i, j in queue: 
                ans[i][j] = ht
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen: 
                        newq.append((ii, jj))
                        seen.add((ii, jj))
            queue = newq
            ht += 1
        return ans",ye15
1766,https://leetcode.com/problems/tree-of-coprimes/discuss/1074565/Python3-dfs,"class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        tree = {} # tree as adjacency list 
        for u, v in edges: 
            tree.setdefault(u, []).append(v)
            tree.setdefault(v, []).append(u)
        
        ans = [-1]*len(nums)
        path = {} # val -> list of position &amp; depth 
        seen = {0}
        
        def fn(k, i): 
            """"""Populate ans via dfs.""""""
            ii = -1 
            for x in path:
                if gcd(nums[k], x) == 1: # coprime 
                    if path[x] and path[x][-1][1] > ii: 
                        ans[k] = path[x][-1][0]
                        ii = path[x][-1][1]
                        
            path.setdefault(nums[k], []).append((k, i))
            for kk in tree.get(k, []): 
                if kk not in seen: 
                    seen.add(kk)
                    fn(kk, i+1)
            path[nums[k]].pop()
            
            
        fn(0, 0)
        return ans",ye15
1768,https://leetcode.com/problems/merge-strings-alternately/discuss/1075531/Simple-Python-Solution,"class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        
        res=''
        
        for i in range(min(len(word1),len(word2))):
            res += word1[i] + word2[i]
            
        return res + word1[i+1:] + word2[i+1:]",lokeshsenthilkumar
1769,https://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/discuss/1075895/Easy-Python-beats-100-time-and-space,"class Solution:
    def minOperations(self, boxes: str) -> List[int]:
        ans = [0]*len(boxes)
        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)
        for i in range(1, n):
            if boxes[i-1] == '1': leftCount += 1
            leftCost += leftCount # each step move to right, the cost increases by # of 1s on the left
            ans[i] = leftCost
        for i in range(n-2, -1, -1):
            if boxes[i+1] == '1': rightCount += 1
            rightCost += rightCount
            ans[i] += rightCost
        return ans",trungnguyen276
1770,https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/discuss/1075495/Python3-bottom-up-dp,"class Solution:
    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:
        n, m = len(nums), len(multipliers)
        dp = [[0]*m for _ in range(m+1)]
        
        for i in reversed(range(m)):
            for j in range(i, m): 
                k = i + m - j - 1
                dp[i][j] = max(nums[i] * multipliers[k] + dp[i+1][j], nums[j-m+n] * multipliers[k] + dp[i][j-1])
        
        return dp[0][-1]",ye15
1771,https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/discuss/1075709/Python3-top-down-dp,"class Solution:
    def longestPalindrome(self, word1: str, word2: str) -> int:
        
        @cache
        def fn(lo, hi):
            """"""Return length of longest palindromic subsequence.""""""
            if lo >= hi: return int(lo == hi)
            if word[lo] == word[hi]: return 2 + fn(lo+1, hi-1)
            return max(fn(lo+1, hi), fn(lo, hi-1))
        
        ans = 0
        word = word1 + word2
        for x in ascii_lowercase: 
            i = word1.find(x) 
            j = word2.rfind(x)
            if i != -1 and j != -1: ans = max(ans, fn(i, j + len(word1)))
        return ans",ye15
1773,https://leetcode.com/problems/count-items-matching-a-rule/discuss/1085906/Python-3-or-2-liner-or-Explanation,"class Solution:
    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:
        d = {'type': 0, 'color': 1, 'name': 2}
        return sum(1 for item in items if item[d[ruleKey]] == ruleValue)",idontknoooo
1774,https://leetcode.com/problems/closest-dessert-cost/discuss/1085820/Python3-top-down-dp,"class Solution:
    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:
        toppingCosts *= 2
        
        @cache
        def fn(i, x):
            """"""Return sum of subsequence of toppingCosts[i:] closest to x.""""""
            if x < 0 or i == len(toppingCosts): return 0
            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))
        
        ans = inf
        for bc in baseCosts: 
            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))
        return ans",ye15
1775,https://leetcode.com/problems/equal-sum-arrays-with-minimum-number-of-operations/discuss/1085806/Python3-two-heaps,"class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
        if 6*len(nums1) < len(nums2) or 6*len(nums2) < len(nums1): return -1 # impossible 
        
        if sum(nums1) < sum(nums2): nums1, nums2 = nums2, nums1
        s1, s2 = sum(nums1), sum(nums2)
            
        nums1 = [-x for x in nums1] # max-heap 
        heapify(nums1)
        heapify(nums2)
        
        ans = 0
        while s1 > s2: 
            x1, x2 = nums1[0], nums2[0]
            if -1-x1 > 6-x2: # change x1 to 1
                s1 += x1 + 1
                heapreplace(nums1, -1)
            else: 
                s2 += 6 - x2
                heapreplace(nums2, 6)
            ans += 1
        return ans",ye15
1776,https://leetcode.com/problems/car-fleet-ii/discuss/1557743/Python3-Stack-Time%3A-O(n)-and-Space%3A-O(n),"class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        # Stack: go from back and use stack to get ans
        # Time: O(n)
        # Space: O(n)
        
        stack = [] # index
        ans = [-1] * len(cars)
        for i in range(len(cars)-1,-1,-1):
            # remove cars that are faster than current car since it will never collide
            while stack and cars[i][1] <= cars[stack[-1]][1]: 
                stack.pop()

            while stack: # if car left, we can compute collide time with current car. 
                collision_t = (cars[stack[-1]][0] - cars[i][0]) / (cars[i][1] - cars[stack[-1]][1])
                # if current car's collide time is greater than previous car's collide time 
                # (previous collided before current), then we have to find previous car's previous car
                # to compute collide time with that car, so we pop from stack and re-process
                # Otherwise, we add that collide time to answer and break
                if ans[stack[-1]] == -1 or collision_t <= ans[stack[-1]]:
                    ans[i] = collision_t
                    break
                stack.pop()
            stack.append(i)
        return ans",jae2021
1779,https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/discuss/1229047/Python-Easy-solution,"class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        minDist = math.inf
        ans = -1
        for i in range(len(points)):
            if points[i][0]==x or points[i][1]==y:
                manDist = abs(points[i][0]-x)+abs(points[i][1]-y)
                if manDist<minDist:
                    ans = i
                    minDist = manDist
        return ans",arkumari2000
1780,https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/discuss/1341617/While-loop-99-speed,"class Solution:
    def checkPowersOfThree(self, n: int) -> bool:
        while n:
            n, rem = divmod(n, 3)
            if rem == 2:
                return False
        return True",EvgenySH
1781,https://leetcode.com/problems/sum-of-beauty-of-all-substrings/discuss/1096392/Python3-freq-table,"class Solution:
    def beautySum(self, s: str) -> int:
        ans = 0 
        for i in range(len(s)):
            freq = [0]*26
            for j in range(i, len(s)):
                freq[ord(s[j])-97] += 1
                ans += max(freq) - min(x for x in freq if x)
        return ans",ye15
1782,https://leetcode.com/problems/count-pairs-of-nodes/discuss/1096612/Python3-2-pointer,"class Solution:
    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
        degree = [0]*n
        freq = defaultdict(int)
        for u, v in edges: 
            degree[u-1] += 1
            degree[v-1] += 1
            freq[min(u-1, v-1), max(u-1, v-1)] += 1
        
        vals = sorted(degree)
        
        ans = []
        for query in queries: 
            cnt = 0 
            lo, hi = 0, n-1
            while lo < hi: 
                if query < vals[lo] + vals[hi]: 
                    cnt += hi - lo # (lo, hi), (lo+1, hi), ..., (hi-1, hi) all valid
                    hi -= 1
                else: lo += 1
            for u, v in freq: 
                if degree[u] + degree[v] - freq[u, v] <= query < degree[u] + degree[v]: cnt -= 1
            ans.append(cnt)
        return ans",ye15
1784,https://leetcode.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/discuss/1097225/Python-3-Check-for-%2201%22-(1-Liner),"class Solution:
    def checkOnesSegment(self, s: str) -> bool:
        return ""01"" not in s",mb557x
1785,https://leetcode.com/problems/minimum-elements-to-add-to-form-a-given-sum/discuss/1121048/Python-3-or-1-liner-or-Explanation,"class Solution:
    def minElements(self, nums: List[int], limit: int, goal: int) -> int:
        return math.ceil(abs(goal - sum(nums)) / limit)",idontknoooo
1786,https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/discuss/1097219/Python3-Dijkstra-%2B-dp,"class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        graph = {} # graph as adjacency list 
        for u, v, w in edges: 
            graph.setdefault(u, []).append((v, w))
            graph.setdefault(v, []).append((u, w))
        
        queue = [n]
        dist = {n: 0}
        while queue: 
            newq = []
            for u in queue: 
                for v, w in graph[u]:
                    if v not in dist or dist[u] + w < dist[v]: 
                        dist[v] = dist[u] + w
                        newq.append(v)
            queue = newq
        
        @cache
        def fn(u): 
            """"""Return number of restricted paths from u to n.""""""
            if u == n: return 1 # boundary condition 
            ans = 0
            for v, _ in graph[u]: 
                if dist[u] > dist[v]: ans += fn(v)
            return ans 
        
        return fn(1) % 1_000_000_007",ye15
1787,https://leetcode.com/problems/make-the-xor-of-all-segments-equal-to-zero/discuss/1100417/Python3-dp,"class Solution:
    def minChanges(self, nums: List[int], k: int) -> int:
        freq = defaultdict(lambda: defaultdict(int))
        for i, x in enumerate(nums): freq[i%k][x] += 1 # freq by row
        
        n = 1 << 10
        dp = [0] + [-inf]*(n-1)
        for i in range(k): 
            mx = max(dp)
            tmp = [0]*n
            for x, c in enumerate(dp): 
                for xx, cc in freq[i].items(): 
                    tmp[x^xx] = max(tmp[x^xx], c + cc, mx)
            dp = tmp 
        return len(nums) - dp[0]",ye15
1790,https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/discuss/1108295/Python3-check-diff,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        diff = [[x, y] for x, y in zip(s1, s2) if x != y]
        return not diff or len(diff) == 2 and diff[0][::-1] == diff[1]",ye15
1791,https://leetcode.com/problems/find-center-of-star-graph/discuss/1568945/Beginner-Friendly-solution-in-O(1)-time-with-detailed-explanation,"class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        
        """""" From the Constraints: A valid STAR GRAPH is confirmed. 
		That means the center will be common to every edges. 
		Therefore we can get the center by comparing only first 2 elements""""""
        
        for i in range (1):
            
            # Check if first element of first edge mathches with any element of second edges
            
            if edges[i][0] == edges [i+1][0] or edges[i][0] == edges[i+1][1]:
                return edges[i][0]
            
            #Otherwise second element of first edge will be the answer
            else:
                return edges[i][1]",stormbreaker_x
1792,https://leetcode.com/problems/maximum-average-pass-ratio/discuss/1108491/Python-100-Efficient-solution-easy-to-understand-with-comments-and-explanation,"class Solution:
	def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
		
		n = len(classes)
		
		impacts = [0]*n
		minRatioIndex = 0
		
		# calculate and store impacts for each class in form of tuples -> (-impactValue, passCount, totalCount)
		for i in range(n):
			passCount = classes[i][0]
			totalCount = classes[i][1]
			
			# calculate the impact  for class i
			currentRatio = passCount/totalCount
			expectedRatioAfterUpdate = (passCount+1)/(totalCount+1)
			impact = expectedRatioAfterUpdate - currentRatio
			
			impacts[i] = (-impact, passCount, totalCount)  # note the - sign for impact
			
		heapq.heapify(impacts)
		
		while(extraStudents > 0):
			# pick the next class with greatest impact 
			_, passCount, totalCount = heapq.heappop(impacts)
			
			# assign a student to the class
			passCount+=1
			totalCount+=1
			
			# calculate the updated impact  for current class
			currentRatio = passCount/totalCount
			expectedRatioAfterUpdate = (passCount+1)/(totalCount+1)
			impact = expectedRatioAfterUpdate - currentRatio
			
			# insert updated impact back into the heap
			heapq.heappush(impacts, (-impact, passCount, totalCount))
			extraStudents -= 1
		
		result = 0
			
		# for all the updated classes calculate the total passRatio 
		for _, passCount, totalCount in impacts:
			result += passCount/totalCount
			
		# return the average pass ratio
		return result/n",CaptainX
1793,https://leetcode.com/problems/maximum-score-of-a-good-subarray/discuss/1108326/Python3-greedy-(2-pointer),"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        ans = mn = nums[k]
        lo = hi = k
        while 0 <= lo-1 or hi+1 < len(nums): 
            if lo == 0 or hi+1 < len(nums) and nums[lo-1] < nums[hi+1]: 
                hi += 1
                mn = min(mn, nums[hi])
            else: 
                lo -= 1
                mn = min(mn, nums[lo])
            ans = max(ans, mn * (hi-lo+1))
        return ans",ye15
1796,https://leetcode.com/problems/second-largest-digit-in-a-string/discuss/1739076/Python3-or-Faster-Solution-or-Easiest-or-brute-force,"class Solution:
    def secondHighest(self, s: str) -> int:
        s=set(s)
        a=[]
        for i in s:
            if i.isnumeric() :
                a.append(int(i))
        a.sort()
        if len(a)<2:
            return -1
        return a[len(a)-2]",Anilchouhan181
1798,https://leetcode.com/problems/maximum-number-of-consecutive-values-you-can-make/discuss/1153726/Python3-Simple-Solution,"class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        coins.sort()
        
        res = 1
        
        for coin in coins:
            if (res >= coin):
                res += coin
        
        return res",victor72
1799,https://leetcode.com/problems/maximize-score-after-n-operations/discuss/1118782/Python3-dp,"class Solution:
    def maxScore(self, nums: List[int]) -> int:
        
        @cache
        def fn(nums, k): 
            """"""Return max score from nums at kth step.""""""
            if not nums: return 0 # boundary condition 
            ans = 0 
            for i in range(len(nums)):
                for j in range(i+1, len(nums)): 
                    rest = nums[:i] + nums[i+1:j] + nums[j+1:]
                    ans = max(ans, k*gcd(nums[i], nums[j]) + fn(tuple(rest), k+1))
            return ans
        
        return fn(tuple(nums), 1)",ye15
1800,https://leetcode.com/problems/maximum-ascending-subarray-sum/discuss/1119686/Python3-line-sweep,"class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        ans = 0
        for i, x in enumerate(nums): 
            if not i or nums[i-1] >= nums[i]: val = 0 # reset val 
            val += nums[i]
            ans = max(ans, val)
        return ans",ye15
1801,https://leetcode.com/problems/number-of-orders-in-the-backlog/discuss/1119692/Python3-priority-queue,"class Solution:
    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:
        ans = 0
        buy, sell = [], [] # max-heap &amp; min-heap 
        
        for p, q, t in orders: 
            ans += q
            if t: # sell order
                while q and buy and -buy[0][0] >= p: # match 
                    pb, qb = heappop(buy)
                    ans -= 2*min(q, qb)
                    if q < qb: 
                        heappush(buy, (pb, qb-q))
                        q = 0 
                    else: q -= qb 
                if q: heappush(sell, (p, q))
            else: # buy order 
                while q and sell and sell[0][0] <= p: # match 
                    ps, qs = heappop(sell)
                    ans -= 2*min(q, qs)
                    if q < qs: 
                        heappush(sell, (ps, qs-q))
                        q = 0 
                    else: q -= qs 
                if q: heappush(buy, (-p, q))
            
        return ans % 1_000_000_007",ye15
1802,https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/discuss/1119650/Growing-A-HillPyramid-with-Visualization-in-Python3,"class Solution:
    def maxValue(self, n: int, index: int, maxSum: int) -> int:
        res_i, crr_sum = 0, n
        l, r, w_hill = index + 1, index - 1, 1 # left/right indices and width of the hill
        while crr_sum <= maxSum:
            l -= 1
            r += 1
            if l == index and r == index:
                crr_sum += w_hill
            else:
                l_, r_ = max(l, 0), min(r, n - 1)
				'''
				when the hill has the same width as the ground, 
				simply just speed up growing by adding the result 
				of dividing (maxSum - crr_sum) by w_hill
				'''
                if l < l_ and r > r_:
                    rm = maxSum - crr_sum
                    res_i += int(rm / w_hill) + 1
                    break
                else:
                    w_hill = r_ - l_ + 1
                    crr_sum += w_hill
            res_i += 1
        return res_i",BryanBoCao
1805,https://leetcode.com/problems/number-of-different-integers-in-a-string/discuss/1491046/Python-3-Short-and-easy-to-understand,"class Solution:
    def numDifferentIntegers(self, word: str) -> int:
        
        word = re.findall('(\d+)', word)
        numbers = [int(i) for i in word]
        
        return len(set(numbers))",frolovdmn
1806,https://leetcode.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/discuss/1130760/Python3-simulation,"class Solution:
    def reinitializePermutation(self, n: int) -> int:
        ans = 0
        perm = list(range(n))
        while True: 
            ans += 1
            perm = [perm[n//2+(i-1)//2] if i&amp;1 else perm[i//2] for i in range(n)]
            if all(perm[i] == i for i in range(n)): return ans",ye15
1807,https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/discuss/1286887/Python-or-Dictionary-or-Simple-Solution,"class Solution:
    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:
        knowledge = dict(knowledge)
        answer, start = [], None
        for i, char in enumerate(s):
            if char == '(': 
                start = i + 1
            elif char == ')':
                answer.append(knowledge.get(s[start:i], '?'))
                start = None
            elif start is None: 
                answer.append(char)
        return ''.join(answer)",leeteatsleep
1808,https://leetcode.com/problems/maximize-number-of-nice-divisors/discuss/1130780/Python3-math,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        mod = 1_000_000_007
        if primeFactors % 3 == 0: return pow(3, primeFactors//3, mod)
        if primeFactors % 3 == 1: return 1 if primeFactors == 1 else 4*pow(3, (primeFactors-4)//3, mod) % mod
        return 2*pow(3, primeFactors//3, mod) % mod",ye15
1812,https://leetcode.com/problems/determine-color-of-a-chessboard-square/discuss/1140948/PythonPython3-or-Simple-and-Easy-code-or-self-explanatory,"class Solution:
    def squareIsWhite(self, c: str) -> bool:
        if c[0] in 'aceg':
            return int(c[1])%2==0
        elif c[0] in 'bdfh':
            return int(c[1])%2==1
        return False",Sukhdev_143
1813,https://leetcode.com/problems/sentence-similarity-iii/discuss/1461165/PYTHON3-Easy-Peezy-code-using-Stack-crisp-and-clear,"class Solution:
    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
        if len(sentence2)>len(sentence1):
            return self.areSentencesSimilar(sentence2,sentence1)
        sentence1=sentence1.split("" "")
        sentence2=sentence2.split("" "")
        s1=sentence1[:]
        s2=sentence2[:]
        while s1[0]==s2[0]:
                s1.pop(0)
                s2.pop(0)
                if not s2:
                    return True
        if not s2:
            return True
        while s1[-1]==s2[-1]:
                s1.pop()
                s2.pop()
                if not s2:
                    return True
        if not s2:
            return True
        return False",mathur17021play
1814,https://leetcode.com/problems/count-nice-pairs-in-an-array/discuss/1140577/Accepted-Python-simple-and-easy-to-understand-solution-with-comments,"class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        
        # define constants
        n = len(nums)
        MOD = 10**9 + 7
        
        # handle scenario for no pairs
        if n<=1:
            return 0
        
        # utility method to calculate reverse of a number
        # e.g. rev(123) -> 321
        def rev(i):
            new = 0
            while(i!=0):
                r = i%10
                new = new*10+r
                i = i//10
            return new
        
        # calculate frequency of all the diffs
        freq_counter = defaultdict(int)
        for num in nums:
            freq_counter[num-rev(num)] += 1
        
        # for all the frequencies calculate the number of paris
        # which is basically nC2 (read as - ""n choose 2"") -> n*(n-1)/2
        answer = 0
        for freq in freq_counter.keys():
            count = freq_counter[freq]
            # note the modulo operation being performed to handle large answer
            answer = (answer + (count*(count-1))//2)%MOD
                          
        return answer",CaptainX
1815,https://leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts/discuss/1140716/Python3-Fastest-solution-with-explanation,"class Solution:
    def maxHappyGroups(self, bs: int, gs: List[int]) -> int:
        c = {i: 0 for i in range(bs)}
        for g in gs:
            c[g % bs] += 1
        ret = c[0]
        c[0] = 0
        
        
        def get_keys(num):
            keys = []
            def rec(stack):
                if len(stack) == num:
                    if sum(stack) % bs == 0:
                        keys.append(Counter(stack))
                else:
                    for i in range(stack[-1] if stack else bs - 1, - 1, - 1):
                        stack.append(i)
                        rec(stack)
                        stack.pop()
            rec([])
            return keys
        
        def get_diff_keys(num):
            keys = []
            def rec(stack):
                if len(stack) == num:
                    if sum(stack) % bs == 0:
                        keys.append(Counter(stack))
                else:
                    for i in range(stack[-1] - 1 if stack else bs - 1, - 1, - 1):
                        stack.append(i)
                        rec(stack)
                        stack.pop()
            rec([])
            return keys
        
        for tc in range(2, bs):
            for keys in get_diff_keys(tc):
                add = min(c[key] // keys[key] for key in keys)
                if add == 0: continue
                ret += add
                for key in keys:
                    c[key] -= add * keys[key]
        tc = 2
        while True:
            for keys in get_keys(tc):
                add = min(c[key] // keys[key] for key in keys)
                if add == 0: continue
                ret += add
                for key in keys:
                    c[key] -= add * keys[key]
            if tc > sum(c.values()): break
            tc += 1
        return ret + bool(sum(c.values()))
            
        ```",timetoai
1816,https://leetcode.com/problems/truncate-sentence/discuss/1142293/2-lines-of-code-with-100-less-space-used,"class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        words = s.split("" "")
        return "" "".join(words[0:k])",vashisht7
1817,https://leetcode.com/problems/finding-the-users-active-minutes/discuss/1141356/Python3-hash-map,"class Solution:
    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
        mp = {}
        for i, t in logs: 
            mp.setdefault(i, set()).add(t)
            
        ans = [0]*k
        for v in mp.values(): 
            if len(v) <= k: 
                ans[len(v)-1] += 1
        return ans",ye15
1818,https://leetcode.com/problems/minimum-absolute-sum-difference/discuss/1715575/Python-%2B-Fully-Explained-%2B-Best-Solution,"class Solution:
	def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:
		n = len(nums1)
		diff = []
		sum = 0
		for i in range(n):
			temp = abs(nums1[i]-nums2[i])
			diff.append(temp)
			sum += temp
		nums1.sort()
		best_diff = []
		for i in range(n):
			idx = bisect.bisect_left(nums1, nums2[i])
			if idx != 0 and idx != n:
				best_diff.append(
					min(abs(nums2[i]-nums1[idx]), abs(nums2[i]-nums1[idx-1])))
			elif idx == 0:
				best_diff.append(abs(nums2[i]-nums1[idx]))
			else:
				best_diff.append(abs(nums2[i]-nums1[idx-1]))
		saved = 0
		for i in range(n):
			saved = max(saved, diff[i]-best_diff[i])
		return (sum-saved) % ((10**9)+(7))",leet_satyam
1819,https://leetcode.com/problems/number-of-different-subsequences-gcds/discuss/1144445/Python3-enumerate-all-possibilities,"class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        nums = set(nums)
        
        ans = 0
        m = max(nums)
        for x in range(1, m+1): 
            g = 0
            for xx in range(x, m+1, x): 
                if xx in nums: 
                    g = gcd(g, xx)
            if g == x: ans += 1
        return ans",ye15
1822,https://leetcode.com/problems/sign-of-the-product-of-an-array/discuss/1152412/Python3-line-sweep,"class Solution:
    def arraySign(self, nums: List[int]) -> int:
        ans = 1
        for x in nums: 
            if x == 0: return 0 
            if x < 0: ans *= -1
        return ans",ye15
1823,https://leetcode.com/problems/find-the-winner-of-the-circular-game/discuss/1152420/Python3-simulation,"class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        nums = list(range(n))
        i = 0 
        while len(nums) > 1: 
            i = (i + k-1) % len(nums)
            nums.pop(i)
        return nums[0] + 1",ye15
1824,https://leetcode.com/problems/minimum-sideway-jumps/discuss/1480131/Python-3-or-DP-or-Explanation,"class Solution:
    def minSideJumps(self, obstacles: List[int]) -> int:
        n = len(obstacles)
        dp = [[sys.maxsize] * n for _ in range(3)]
        dp[0][0]= 1
        dp[1][0]= 0
        dp[2][0]= 1
        for i in range(1, n):
            dp[0][i] = dp[0][i-1] if obstacles[i] != 1 else sys.maxsize
            dp[1][i] = dp[1][i-1] if obstacles[i] != 2 else sys.maxsize
            dp[2][i] = dp[2][i-1] if obstacles[i] != 3 else sys.maxsize
            if obstacles[i] != 1:
                for j in [1, 2]:
                    dp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)
            if obstacles[i] != 2:
                for j in [0, 2]:
                    dp[1][i] = min(dp[1][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)
            if obstacles[i] != 3:
                for j in [0, 1]:
                    dp[2][i] = min(dp[2][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)
        return min(dp[0][-1], dp[1][-1], dp[2][-1])",idontknoooo
1827,https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/discuss/1178397/Python3-simple-solution-beats-90-users,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        count = 0
        for i in range(1,len(nums)):
            if nums[i] <= nums[i-1]:
                x = nums[i]
                nums[i] += (nums[i-1] - nums[i]) + 1
                count += nums[i] - x
        return count",EklavyaJoshi
1828,https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/discuss/1163133/Python-One-liner,"class Solution:
    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
        return [sum(math.sqrt((x0-x1)**2 + (y0-y1)**2) <= r for x1, y1 in points) for x0, y0, r in queries]",Black_Pegasus
1829,https://leetcode.com/problems/maximum-xor-for-each-query/discuss/1281679/Python3-solution-using-single-for-loop,"class Solution:
    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:
        res = []
        for i in range(1,len(nums)):
            res.append(2**maximumBit - 1 - nums[i-1])
            nums[i] = nums[i-1]^nums[i]
        res.append(2**maximumBit - 1 - nums[-1])
        return res[::-1]",EklavyaJoshi
1830,https://leetcode.com/problems/minimum-number-of-operations-to-make-string-sorted/discuss/1202007/Python3-math-solution,"class Solution:
    def makeStringSorted(self, s: str) -> int:
        freq = [0]*26
        for c in s: freq[ord(c) - 97] += 1
        
        MOD = 1_000_000_007
        fac = cache(lambda x: x*fac(x-1)%MOD if x else 1)
        ifac = cache(lambda x: pow(fac(x), MOD-2, MOD)) # Fermat's little theorem (a**(p-1) = 1 (mod p))
        
        ans, n = 0, len(s)
        for c in s: 
            val = ord(c) - 97
            mult = fac(n-1)
            for k in range(26): mult *= ifac(freq[k])
            for k in range(val): ans += freq[k] * mult
            n -= 1
            freq[val] -= 1
        return ans % MOD",ye15
1832,https://leetcode.com/problems/check-if-the-sentence-is-pangram/discuss/2712076/Multiple-solution-in-python,"class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        lst=[0]*26
        for i in sentence:
            lst[ord(i)-ord('a')]+=1
        return 0 not in lst",shubham_1307
1833,https://leetcode.com/problems/maximum-ice-cream-bars/discuss/1165500/Python3-with-Explanation-100-faster-and-100-memory-efficient,"class Solution:
    def maxIceCream(self, costs: List[int], coins: int) -> int:
        '''
        1. If the minimum of all costs is greater than amount of coins, the boy can't buy any bar, return 0
        2. Else, sort the list of costs in a non-decreasing order
        3. For each 'cost' in costs, if the cost is less than current coins
                -increase the count of ice cream bars that can be bought by 1
                -decrease the current coins amount by 'cost'
        4. If the cost is greater than current coins, return the ice cream bar count value
        '''
        
        if min(costs)>coins:        #minimum cost is greater than the coins available        
            return 0                #can't buy any ice cream bar
        
        costs=sorted(costs)         #sort the list of costs in a non-decreasing order
        res = 0                     #the resultant count of ice cream bars that can be bought
        for cost in costs:
            if cost<=coins:         #in this case, the boy can buy the ice cream bar
                res+=1              #increase the ice cream bar count
                coins-=cost         #spent an amount equal to 'cost', decrease current coins amount by cost
            else:
                break               #not enough coins, return the bars count
            
        return res",bPapan
1834,https://leetcode.com/problems/single-threaded-cpu/discuss/2004757/Python-or-Priority-Queue,"class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:
        dic=defaultdict(list)
        
        for i in range(len(tasks)):
            dic[tasks[i][0]].append((tasks[i][1],i))
        
        
        ans=[]
        keys=sorted(dic.keys())
        
        while keys:
            k=keys.pop(0)
            pq=dic[k]
            heapq.heapify(pq)
            time=k
            
            while pq:
                p_time,ind=heapq.heappop(pq)
                ans.append(ind)
                time+=p_time
                while keys:
                    if keys[0]>time:
                        break
                    for item in dic[keys.pop(0)]:
                        heapq.heappush(pq,item)
        return ans",heckt27
1835,https://leetcode.com/problems/find-xor-sum-of-all-pairs-bitwise-and/discuss/2724403/Simple-python-code-with-explanation,"class Solution:
    #example 1 
    #result =[(1&amp;6)^(1&amp;5)^(2&amp;6)^(2&amp;5)^(3&amp;6)^(3&amp;5)]
                \     /     \    /      \     /
    #           (1&amp;(6^5)) ^ (2&amp;(6^5)) ^ (3&amp;(6^5))   
                   \            |           /
                    \           |          /
                     \          |         /
                      \         |        /
    #                  ((1^2^3) &amp; (6^5))
    def getXORSum(self, a, b):
        x = 0 
        for i in range(len(a)):
            x = x ^ a[i]
        y = 0 
        for j in range(len(b)):
            y = y ^ b[j]
        return x &amp; y",thomanani
1837,https://leetcode.com/problems/sum-of-digits-in-base-k/discuss/1175067/Python3-self-explained,"class Solution:
    def sumBase(self, n: int, k: int) -> int:
        ans = 0
        while n: 
            n, x = divmod(n, k)
            ans += x
        return ans",ye15
1838,https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1179374/Python-3-Sliding-Window-Explanation-with-Code,"class Solution:
    def maxFrequency(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        sum_s_w = nums[0]
        fin = 1
        i=0
        for j in range(1,n):
            sum_s_w+=nums[j]
            mx = nums[j]
            while sum_s_w+k<mx*(j-i+1):
                sum_s_w -= nums[i]
                i += 1
            fin = max(fin,j-i+1)
        return fin",vamsi81523
1839,https://leetcode.com/problems/longest-substring-of-all-vowels-in-order/discuss/1175044/Python3-greedy,"class Solution:
    def longestBeautifulSubstring(self, word: str) -> int:
        vowels = ""aeiou""
        ans = 0
        cnt = prev = -1 
        for i, x in enumerate(word): 
            curr = vowels.index(x)
            if cnt >= 0: # in the middle of counting 
                if 0 <= curr - prev <= 1: 
                    cnt += 1
                    if x == ""u"": ans = max(ans, cnt)
                elif x == ""a"": cnt = 1
                else: cnt = -1 
            elif x == ""a"": cnt = 1
            prev = curr 
        return ans",ye15
1840,https://leetcode.com/problems/maximum-building-height/discuss/1175057/Python3-greedy,"class Solution:
    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:
        restrictions.extend([[1, 0], [n, n-1]])
        restrictions.sort()
        
        for i in reversed(range(len(restrictions)-1)): 
            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1] + restrictions[i+1][0] - restrictions[i][0])
        
        ans = 0 
        for i in range(1, len(restrictions)): 
            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0])
            ans = max(ans, (restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0] + restrictions[i][1])//2)
        return ans",ye15
1844,https://leetcode.com/problems/replace-all-digits-with-characters/discuss/1243646/Python3-simple-code-96-time-with-explanation,"class Solution:
    def replaceDigits(self, s: str) -> str:

        ans = """"

        def shift(char, num):
            return chr(ord(char) + int(num))

        for index in range(len(s)):
            ans += shift(s[index-1], s[index]) if index % 2 else s[index]

        return ans",albezx0
1847,https://leetcode.com/problems/closest-room/discuss/1186155/Python-3-Aggregate-sorted-list-detailed-explanation-(2080-ms),"class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans = [0] * len(queries)
        
        # sort queries to handle largest size queries first
        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))

        # sort rooms by descending size
        rooms = deque(sorted(rooms, key=lambda x: -x[1]))

        # current available room ids
        cands = []
        
        
        while q:
            size, room, i = q.popleft()
            # add room ids to candidates as long as top of room size meet the requirements
            while rooms and rooms[0][1] >= size:
                bisect.insort(cands, rooms.popleft()[0])
                    
            # if no room size available, return -1
            if not cands: ans[i] = -1
                
            # else use bisect to find optimal room ids
            else:
                loc = bisect.bisect_left(cands, room)
                if loc == 0: ans[i] = cands[loc]
                elif loc == len(cands): ans[i] = cands[-1]
                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]
        
        return ans",chestnut890123
1848,https://leetcode.com/problems/minimum-distance-to-the-target-element/discuss/1186862/Python3-linear-sweep,"class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        ans = inf
        for i, x in enumerate(nums): 
            if x == target: 
                ans = min(ans, abs(i - start))
        return ans",ye15
1849,https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/discuss/2632013/Clear-Python-DFS-with-comments,"class Solution:
    def splitString(self, s: str) -> bool:
        
        """"""
        Time = O(2^N)
        Space = O(N) space from stack
        
        """"""
        def dfs(index: int, last: int) -> bool:
            if index == len(s):
                return True
            
			# j: [index, len(s)-1]
            for j in range(index, len(s)):
				# cur: [index, index] ~ [index, len(s)-1]
                cur = int(s[index:j + 1])
				# last: [...,index-1]
				# cur: [index+1, j]
				# last = cur -> next: [j+1,...)
				# DFS condition: cur = last - 1 &amp;&amp; dfs(j+1, cur) == true
                if cur == last - 1 and dfs(j + 1, cur):
                    return True
            return False
        
        for i in range(len(s) - 1):
            last = int(s[:i+1])
            if dfs(i + 1, last):
                return True
        return False",changyou1009
1850,https://leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/discuss/1186887/Python3-brute-force,"class Solution:
    def getMinSwaps(self, num: str, k: int) -> int:
        num = list(num)
        orig = num.copy()
        
        for _ in range(k): 
            for i in reversed(range(len(num)-1)): 
                if num[i] < num[i+1]: 
                    ii = i+1 
                    while ii < len(num) and num[i] < num[ii]: ii += 1
                    num[i], num[ii-1] = num[ii-1], num[i]
                    lo, hi = i+1, len(num)-1
                    while lo < hi: 
                        num[lo], num[hi] = num[hi], num[lo]
                        lo += 1
                        hi -= 1
                    break 
        
        ans = 0
        for i in range(len(num)): 
            ii = i
            while orig[i] != num[i]: 
                ans += 1
                ii += 1
                num[i], num[ii] = num[ii], num[i]
        return ans",ye15
1851,https://leetcode.com/problems/minimum-interval-to-include-each-query/discuss/1422509/For-Beginners-oror-Easy-Approach-oror-Well-Explained-oror-Clean-and-Concise,"class Solution:
def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
    
    intervals.sort(key = lambda x:x[1]-x[0])
    q = sorted([qu,i] for i,qu in enumerate(queries))
    res=[-1]*len(queries)
	
    for left,right in intervals:
        ind = bisect.bisect(q,[left])
        while ind<len(q) and q[ind][0]<=right:
            res[q.pop(ind)[1]]=right-left+1
    return res",abhi9Rai
1859,https://leetcode.com/problems/sorting-the-sentence/discuss/1219040/Python3-99.60-Fast-Solution,"class Solution:
    def sortSentence(self, s: str) -> str:
        arr = [i[-1] + i[:-1] for i in s.split()]
        
        arr.sort()
        
        ans = """"
        for i in arr:
            ans += i[1:] + ' '
        
        return ans[:-1]",VoidCupboard
1860,https://leetcode.com/problems/incremental-memory-leak/discuss/1210088/JavaC%2B%2BPython-Solution,"class Solution:
    def memLeak(self, memory1: int, memory2: int) -> List[int]:
        i = 1
        while max(memory1, memory2) >= i:
            if memory1 >= memory2:
                memory1 -= i
            else:
                memory2 -= i
            i += 1
        return [i, memory1, memory2]",lokeshsenthilkumar
1861,https://leetcode.com/problems/rotating-the-box/discuss/1622675/Python-Easy-explanation,"class Solution:
    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
        # move stones to right, row by row
        for i in range(len(box)):
            stone = 0
            for j in range(len(box[0])):
                if box[i][j] == '#': # if a stone
                    stone += 1
                    box[i][j] = '.'
                elif box[i][j] == '*': # if a obstacle
                    for m in range(stone):
                        box[i][j-m-1] = '#'
                    stone = 0
            # if reaches the end of j, but still have stone
            if stone != 0:
                for m in range(stone):
                        box[i][j-m] = '#'
        
        # rotate box, same as leetcode #48
        box[:]  = zip(*box[::-1])
        
        return box",sashaxx
1862,https://leetcode.com/problems/sum-of-floored-pairs/discuss/1218305/PythonPython3-solution-BruteForce-and-Optimized-solution-using-Dictionary,"class Solution:
    def sumOfFlooredPairs(self, nums: List[int]) -> int:
        sumP = 0 #To store the value of Sum of floor values
        for i in nums: #Traverse every element in nums
            for j in nums: #Traverse every element in nums
                sumP += (j//i) #Simply do floor division and add the number to sumP
        return sumP % (10**9 +7)#return the sumof the pairs",prasanthksp1009
1866,https://leetcode.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/discuss/1211157/Python3-top-down-dp,"class Solution:
    def rearrangeSticks(self, n: int, k: int) -> int:
        
        @cache 
        def fn(n, k): 
            """"""Return number of ways to rearrange n sticks to that k are visible.""""""
            if n == k: return 1
            if k == 0: return 0
            return ((n-1)*fn(n-1, k) + fn(n-1, k-1)) % 1_000_000_007
        
        return fn(n, k)",ye15
1871,https://leetcode.com/problems/jump-game-vii/discuss/1224907/Python3-prefix-sum,"class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        prefix = [0, 1]
        for i in range(1, len(s)): 
            prefix.append(prefix[-1])
            lo = max(0, i-maxJump)
            hi = max(0, i-minJump+1)
            if s[i] == ""0"" and prefix[hi] - prefix[lo] > 0: prefix[-1] += 1
        return prefix[-1] > prefix[-2]",ye15
1872,https://leetcode.com/problems/stone-game-viii/discuss/1224872/Top-Down-and-Bottom-Up,"class Solution:
    def stoneGameVIII(self, s: List[int]) -> int:
        s, res = list(accumulate(s)), 0
        for i in range(len(s) - 1, 0, -1):
            res = s[i] if i == len(s) - 1 else max(res, s[i] - res)
        return res",votrubac
1876,https://leetcode.com/problems/substrings-of-size-three-with-distinct-characters/discuss/1356591/Easy-Python-Solution(98.80),"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count=0
        for i in range(len(s)-2):
            if(s[i]!=s[i+1] and s[i]!=s[i+2] and s[i+1]!=s[i+2]):
                count+=1
        return count",Sneh17029
1877,https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/discuss/2087728/Python-Easy-To-Understand-Code-oror-Beginner-Friendly-oror-Brute-Force,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        pair_sum = []
        nums.sort()
        for i in range(len(nums)//2):
            pair_sum.append(nums[i]+nums[len(nums)-i-1])
        return max(pair_sum)",Shivam_Raj_Sharma
1878,https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/discuss/1239929/python-oror-100-faster-oror-well-explained-oror-Simple-approach,"class Solution:
def getBiggestThree(self, grid: List[List[int]]) -> List[int]:
    
    def calc(l,r,u,d):
        sc=0
        c1=c2=(l+r)//2
        expand=True
        for row in range(u,d+1):
            if c1==c2:
                sc+=grid[row][c1]
            else:
                sc+=grid[row][c1]+grid[row][c2]
            
            if c1==l:
                expand=False
            
            if expand:
                c1-=1
                c2+=1
            else:
                c1+=1
                c2-=1
        return sc
        
    
    m=len(grid)
    n=len(grid[0])
    heap=[]
    for i in range(m):
        for j in range(n):
            l=r=j
            d=i
            while l>=0 and r<=n-1 and d<=m-1:
                sc=calc(l,r,i,d)
                l-=1
                r+=1
                d+=2
                if len(heap)<3:
                    if sc not in heap:
                        heapq.heappush(heap,sc)
                else:
                    if sc not in heap and sc>heap[0]:
                        heapq.heappop(heap)
                        heapq.heappush(heap,sc)
    
    heap.sort(reverse=True)
    return heap",abhi9Rai
1879,https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/discuss/1238641/Bit-Mask,"class Solution:
    def minimumXORSum(self, a: List[int], b: List[int]) -> int:
        @cache
        def dp(mask: int) -> int:
            i = bin(mask).count(""1"")
            if i >= len(a):
                return 0
            return min((a[i] ^ b[j]) + dp(mask + (1 << j)) 
                       for j in range(len(b)) if mask &amp; (1 << j) == 0)
        return dp(0)",votrubac
1880,https://leetcode.com/problems/check-if-word-equals-summation-of-two-words/discuss/1241968/Minus-49,"class Solution:
    def isSumEqual(self, first: str, second: str, target: str) -> bool:
        def op(s: str): return """".join(chr(ord(ch) - 49) for ch in s)
        return int(op(first)) + int(op(second)) == int(op(target))",votrubac
1881,https://leetcode.com/problems/maximum-value-after-insertion/discuss/1240010/Python-oror-simple-O(N)-iteration,"class Solution:
    def maxValue(self, n: str, x: int) -> str:
        if int(n)>0:
            ans = """"
            flag = False
            for i in range(len(n)):
                if int(n[i])>=x:
                    ans += n[i]
                else:
                    a = n[:i]
                    b = n[i:]
                    ans = a+str(x)+b
                
                    flag = True
                    break
            if not flag:
                ans += str(x)
        else:
            n = n[1:]
            ans = """"
            flag = False
            for i in range(len(n)):
                if int(n[i])<=x:
                    ans += n[i]
                else:
                    a = n[:i]
                    b = n[i:]
                    ans = a+str(x)+b
            
                    flag = True
                    break
            if not flag:
                ans += str(x)
            ans = ""-""+ans
        
        return ans",harshhx
1882,https://leetcode.com/problems/process-tasks-using-servers/discuss/1240147/Python-oror-Heap-oror-O(n%2Bmlogn)-oror-easy-and-well-explained,"class Solution:
def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:
    
    # sort the servers in order of weight, keeping index 
    server_avail = [(w,i) for i,w in enumerate(servers)]
    heapify(server_avail)
    tasks_in_progress = []
    res = []
    st=0
    for j,task in enumerate(tasks):
        #starting time of task
        st = max(st,j)
        
        # if any server is not free then we can take start-time equal to end-time of task
        if not server_avail:
            st = tasks_in_progress[0][0]
        
        # pop the completed task's server and push inside the server avail
        while tasks_in_progress and tasks_in_progress[0][0]<=st:
            heapq.heappush(server_avail,heappop(tasks_in_progress)[1])
            
        # append index of used server in res
        res.append(server_avail[0][1])
        
        # push the first available server in ""server_avail"" heap to ""tasks_in_progress"" heap
        heapq.heappush(tasks_in_progress,(st+task,heappop(server_avail)))
    
    return res",abhi9Rai
1883,https://leetcode.com/problems/minimum-skips-to-arrive-at-meeting-on-time/discuss/1242138/Python3-top-down-dp,"class Solution:
    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
        if sum(dist)/speed > hoursBefore: return -1 # impossible 
        
        @cache
        def fn(i, k): 
            """"""Return min time (in distance) of traveling first i roads with k skips.""""""
            if k < 0: return inf # impossible 
            if i == 0: return 0 
            return min(ceil((fn(i-1, k) + dist[i-1])/speed) * speed, dist[i-1] + fn(i-1, k-1))
        
        for k in range(len(dist)):
            if fn(len(dist)-1, k) + dist[-1] <= hoursBefore*speed: return k",ye15
1884,https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/discuss/1248069/Recursive-Iterative-Generic,"class Solution:
    @cache
    def twoEggDrop(self, n: int) -> int:
        return min((1 + max(i - 1, self.twoEggDrop(n - i)) for i in range (1, n)), default = 1)",votrubac
1886,https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/discuss/1253880/Python3-rotate-matrix,"class Solution:
    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:
        for _ in range(4): 
            if mat == target: return True
            mat = [list(x) for x in zip(*mat[::-1])]
        return False",ye15
1887,https://leetcode.com/problems/reduction-operations-to-make-the-array-elements-equal/discuss/1253889/Python3-greedy,"class Solution:
    def reductionOperations(self, nums: List[int]) -> int:
        ans = val = 0
        nums.sort()
        for i in range(1, len(nums)): 
            if nums[i-1] < nums[i]: val += 1
            ans += val
        return ans",ye15
1888,https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/discuss/1259837/Python-Simple-DP-(beats-99.52),"class Solution:
    def minFlips(self, s: str) -> int:
        prev = 0
        start_1, start_0, start_1_odd, start_0_odd = 0,0,sys.maxsize,sys.maxsize
        odd = len(s)%2
        for val in s:
            val = int(val)
            if val == prev:
                if odd:
                    start_0_odd = min(start_0_odd, start_1)
                    start_1_odd += 1
                start_1 += 1
            else:
                if odd:
                    start_1_odd = min(start_1_odd, start_0)
                    start_0_odd += 1
                start_0 += 1
            prev = 1 - prev
        return min([start_1, start_0, start_1_odd, start_0_odd])",cloverpku
1889,https://leetcode.com/problems/minimum-space-wasted-from-packaging/discuss/1253918/Python3-prefix-sum-and-binary-search,"class Solution:
    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
        packages.sort()
        prefix = [0]
        for x in packages: prefix.append(prefix[-1] + x)
        
        ans = inf 
        for box in boxes: 
            box.sort()
            if packages[-1] <= box[-1]: 
                kk = val = 0 
                for x in box: 
                    k = bisect_right(packages, x)
                    val += (k - kk) * x - (prefix[k] - prefix[kk])
                    kk = k
                ans = min(ans, val)
        return ans % 1_000_000_007 if ans < inf else -1",ye15
1893,https://leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/discuss/1444310/PYTHON3-Noob-Friendly-Easy-inuitive-naturally-occuring-solution,"class Solution:
    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
        ranges = sorted(ranges)
        for s,e in ranges:
            if  s<=left<=e:
                if s<=right<=e:
                    return True
                else:
                    left=e+1
        return False",mathur17021play
1894,https://leetcode.com/problems/find-the-student-that-will-replace-the-chalk/discuss/1612394/Python-oror-Prefix-Sum-and-Binary-Search-oror-O(n)-time-O(n)-space,"class Solution:
    def chalkReplacer(self, chalk: List[int], k: int) -> int:
        prefix_sum = [0 for i in range(len(chalk))]
        prefix_sum[0] = chalk[0]
        for i in range(1,len(chalk)):
            prefix_sum[i] = prefix_sum[i-1] + chalk[i]
        remainder = k % prefix_sum[-1]
        
        #apply binary search on prefix_sum array, target = remainder 
        start = 0
        end = len(prefix_sum) - 1
        while start <= end:
            mid = start + (end - start) // 2
            if remainder == prefix_sum[mid]:
                return mid + 1
            elif remainder < prefix_sum[mid]:
                end = mid - 1
            else:
                start = mid + 1
        return start",s_m_d_29
1895,https://leetcode.com/problems/largest-magic-square/discuss/1267452/Python3-prefix-sums,"class Solution:
    def largestMagicSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions 
        rows = [[0]*(n+1) for _ in range(m)] # prefix sum along row
        cols = [[0]*n for _ in range(m+1)] # prefix sum along column
        
        for i in range(m):
            for j in range(n): 
                rows[i][j+1] = grid[i][j] + rows[i][j]
                cols[i+1][j] = grid[i][j] + cols[i][j]
        
        ans = 1
        for i in range(m): 
            for j in range(n): 
                diag = grid[i][j]
                for k in range(min(i, j)): 
                    ii, jj = i-k-1, j-k-1
                    diag += grid[ii][jj]
                    ss = {diag}
                    for r in range(ii, i+1): ss.add(rows[r][j+1] - rows[r][jj])
                    for c in range(jj, j+1): ss.add(cols[i+1][c] - cols[ii][c])
                    ss.add(sum(grid[ii+kk][j-kk] for kk in range(k+2))) # anti-diagonal
                    if len(ss) == 1: ans = max(ans, k+2)
        return ans",ye15
1896,https://leetcode.com/problems/minimum-cost-to-change-the-final-value-of-expression/discuss/1272620/Python3-divide-and-conquer,"class Solution:
    def minOperationsToFlip(self, expression: str) -> int:
        loc = {}
        stack = []
        for i in reversed(range(len(expression))):
            if expression[i] == "")"": stack.append(i)
            elif expression[i] == ""("": loc[stack.pop()] = i 
        
        def fn(lo, hi): 
            """"""Return value and min op to change value.""""""
            if lo == hi: return int(expression[lo]), 1
            if expression[hi] == "")"" and loc[hi] == lo: return fn(lo+1, hi-1) # strip parenthesis 
            mid = loc.get(hi, hi) - 1 
            v, c = fn(mid+1, hi)
            vv, cc = fn(lo, mid-1)
            if expression[mid] == ""|"": 
                val = v | vv 
                if v == vv == 0: chg = min(c, cc)
                elif v == vv == 1: chg = 1 + min(c, cc)
                else: chg = 1 
            else: # expression[k] == ""&amp;""
                val = v &amp; vv
                if v == vv == 0: chg = 1 + min(c, cc)
                elif v == vv == 1: chg = min(c, cc)
                else: chg = 1
            return val, chg
                    
        return fn(0, len(expression)-1)[1]",ye15
1897,https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/discuss/1268522/Python-or-dictionary,"class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        map_ = {}
        for word in words:
            for i in word:
                if i not in map_:
                    map_[i] = 1
                else:
                    map_[i] += 1
        n = len(words)
        for k,v in map_.items():
            if (v%n) != 0:
                return False
        return True",harshhx
1898,https://leetcode.com/problems/maximum-number-of-removable-characters/discuss/1268727/Python3-binary-search,"class Solution:
    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:
        mp = {x: i for i, x in enumerate(removable)}
        
        def fn(x):
            """"""Return True if p is a subseq of s after x removals.""""""
            k = 0 
            for i, ch in enumerate(s): 
                if mp.get(i, inf) < x: continue 
                if k < len(p) and ch == p[k]: k += 1
            return k == len(p)
        
        lo, hi = -1, len(removable)
        while lo < hi: 
            mid = lo + hi + 1 >> 1
            if fn(mid): lo = mid
            else: hi = mid - 1
        return lo",ye15
1899,https://leetcode.com/problems/merge-triplets-to-form-target-triplet/discuss/1268491/python-or-implementation-O(N),"class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        i = 1
        cur = []
        for a,b,c in triplets:
            if a<=target[0] and b<=target[1] and c<= target[2]:
                cur = [a,b,c]
                break
        if not cur:
            return False
        while i<len(triplets):
            if cur == target:
                return True
            a,b,c = triplets[i]
            x,y,z = cur
            if max(a,x)<=target[0] and max(b,y)<=target[1] and max(c,z)<=target[2]:
                cur = [max(a,x), max(b,y), max(c,z)]
               
            
            i+= 1
        if cur == target:
            return True
        return False",harshhx
1900,https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/discuss/1268788/Python3-bit-mask-dp,"class Solution:
    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:
        firstPlayer, secondPlayer = firstPlayer-1, secondPlayer-1 # 0-indexed
        
        @cache
        def fn(k, mask): 
            """"""Return earliest and latest rounds.""""""
            can = deque()
            for i in range(n): 
                if mask &amp; (1 << i): can.append(i)
                    
            cand = [] # eliminated player
            while len(can) > 1: 
                p1, p2 = can.popleft(), can.pop()
                if p1 == firstPlayer and p2 == secondPlayer or p1 == secondPlayer and p2 == firstPlayer: return [k, k] # game of interest 
                if p1 in (firstPlayer, secondPlayer): cand.append([p2]) # p2 eliminated 
                elif p2 in (firstPlayer, secondPlayer): cand.append([p1]) # p1 eliminated 
                else: cand.append([p1, p2]) # both could be elimited 
            
            minn, maxx = inf, -inf
            for x in product(*cand): 
                mask0 = mask
                for i in x: mask0 ^= 1 << i
                mn, mx = fn(k+1, mask0)
                minn = min(minn, mn)
                maxx = max(maxx, mx)
            return minn, maxx
        
        return fn(1, (1<<n)-1)",ye15
1901,https://leetcode.com/problems/find-a-peak-element-ii/discuss/1446385/Python-3-or-Binary-Search-or-Explanation,"class Solution:
    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
        m, n = len(mat), len(mat[0])
        l, r = 0, n
        while l <= r:
            mid = (l + r) // 2
            cur_max, left = 0, False
            for i in range(m):
                if i > 0 and mat[i-1][mid] >= mat[i][mid]:
                    continue
                if i+1 < m and mat[i+1][mid] >= mat[i][mid]:   
                    continue
                if mid+1 < n and mat[i][mid+1] >= mat[i][mid]:   
                    cur_max, left = mat[i][mid], not mat[i][mid] > cur_max
                    continue
                if mid > 0 and mat[i][mid-1] >= mat[i][mid]:   
                    cur_max, left = mat[i][mid], mat[i][mid] > cur_max
                    continue
                return [i, mid]
            if left:
                r = mid-1
            else:
                l = mid+1
        return []",idontknoooo
1903,https://leetcode.com/problems/largest-odd-number-in-string/discuss/1338138/PYTHON-3%3A-99.34-FASTER-EASY-EXPLANATION,"class Solution:
    def largestOddNumber(self, num: str) -> str:
        
        for i in range(len(num) - 1, -1, -1) :
            if num[i] in {'1','3','5','7','9'} :
                return num[:i+1]
        return ''",rohitkhairnar
1904,https://leetcode.com/problems/the-number-of-full-rounds-you-have-played/discuss/1284279/Python3-math-ish,"class Solution:
    def numberOfRounds(self, startTime: str, finishTime: str) -> int:
        hs, ms = (int(x) for x in startTime.split("":""))
        ts = 60 * hs + ms
        hf, mf = (int(x) for x in finishTime.split("":""))
        tf = 60 * hf + mf
        if 0 <= tf - ts < 15: return 0 # edge case 
        return tf//15 - (ts+14)//15 + (ts>tf)*96",ye15
1905,https://leetcode.com/problems/count-sub-islands/discuss/1284306/98-faster-oror-Simple-approach-oror-well-explained,"class Solution:
def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
    
    m=len(grid1)
    n=len(grid1[0])
    
    def dfs(i,j):
        if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:
            return
        
        grid2[i][j]=0
        dfs(i+1,j)
        dfs(i,j+1)
        dfs(i,j-1)
        dfs(i-1,j)
        
    # removing all the non-common sub-islands
    for i in range(m):
        for j in range(n):
            if grid2[i][j]==1 and grid1[i][j]==0:
                dfs(i,j)
    
    c=0
	# counting sub-islands
    for i in range(m):
        for j in range(n):
            if grid2[i][j]==1:
                dfs(i,j)
                c+=1
    return c",abhi9Rai
1906,https://leetcode.com/problems/minimum-absolute-difference-queries/discuss/1284341/Python3-binary-search,"class Solution:
    def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        loc = {}
        for i, x in enumerate(nums): loc.setdefault(x, []).append(i)
        keys = sorted(loc)
        
        ans = []
        for l, r in queries: 
            prev, val = 0, inf
            for x in keys: 
                i = bisect_left(loc[x], l)
                if i < len(loc[x]) and loc[x][i] <= r: 
                    if prev: val = min(val, x - prev)
                    prev = x 
            ans.append(val if val < inf else -1)
        return ans",ye15
1909,https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/discuss/1298457/Python3-collect-non-conforming-indices,"class Solution:
    def canBeIncreasing(self, nums: List[int]) -> bool:
        stack = []
        for i in range(1, len(nums)): 
            if nums[i-1] >= nums[i]: stack.append(i)
                
        if not stack: return True 
        if len(stack) > 1: return False
        i = stack[0]
        return (i == 1 or nums[i-2] < nums[i]) or (i+1 == len(nums) or nums[i-1] < nums[i+1])",ye15
1910,https://leetcode.com/problems/remove-all-occurrences-of-a-substring/discuss/1298899/Python3-kmp,"class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        lps = [0]
        k = 0 
        for i in range(1, len(part)): 
            while k and part[k] != part[i]: k = lps[k-1]
            if part[k] == part[i]: k += 1
            lps.append(k)
        
        stack = [("""", 0)]
        for ch in s: 
            k = stack[-1][1]
            while k and part[k] != ch: k = lps[k-1]
            if part[k] == ch: k += 1
            stack.append((ch, k))
            if k == len(part): 
                for _ in range(len(part)): stack.pop()
        return """".join(x for x, _ in stack)",ye15
1911,https://leetcode.com/problems/maximum-alternating-subsequence-sum/discuss/1298531/4-lines-oror-96-faster-oror-Easy-approach,"class Solution:
def maxAlternatingSum(self, nums: List[int]) -> int:
    
    ma=0
    mi=0
    for num in nums:
        ma=max(ma,num-mi)
        mi=min(mi,num-ma)
        
    return ma",abhi9Rai
1913,https://leetcode.com/problems/maximum-product-difference-between-two-pairs/discuss/2822079/Python-oror-96.20-Faster-oror-2-Lines-oror-Sorting,"class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
        nums.sort()
        return (nums[-1]*nums[-2])-(nums[0]*nums[1])",DareDevil_007
1914,https://leetcode.com/problems/cyclically-rotating-a-grid/discuss/1299526/Python3-brute-force,"class Solution:
    def rotateGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0]) # dimensions 
        
        for r in range(min(m, n)//2): 
            i = j = r
            vals = []
            for jj in range(j, n-j-1):     vals.append(grid[i][jj])
            for ii in range(i, m-i-1):     vals.append(grid[ii][n-j-1])
            for jj in range(n-j-1, j, -1): vals.append(grid[m-i-1][jj])
            for ii in range(m-i-1, i, -1): vals.append(grid[ii][j])
                
            kk = k % len(vals)
            vals = vals[kk:] + vals[:kk]
            
            x = 0  
            for jj in range(j, n-j-1):     grid[i][jj] = vals[x]; x += 1
            for ii in range(i, m-i-1):     grid[ii][n-j-1] = vals[x]; x += 1
            for jj in range(n-j-1, j, -1): grid[m-i-1][jj] = vals[x]; x += 1
            for ii in range(m-i-1, i, -1): grid[ii][j] = vals[x]; x += 1
        return grid",ye15
1915,https://leetcode.com/problems/number-of-wonderful-substrings/discuss/1299537/Python3-freq-table-w.-mask,"class Solution:
    def wonderfulSubstrings(self, word: str) -> int:
        ans = mask = 0
        freq = defaultdict(int, {0: 1})
        for ch in word: 
            mask ^= 1 << ord(ch)-97
            ans += freq[mask]
            for i in range(10): ans += freq[mask ^ 1 << i]
            freq[mask] += 1
        return ans",ye15
1916,https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/discuss/1299545/Python3-post-order-dfs,"class Solution:
    def waysToBuildRooms(self, prevRoom: List[int]) -> int:
        tree = defaultdict(list)
        for i, x in enumerate(prevRoom): tree[x].append(i)
        
        def fn(n): 
            """"""Return number of nodes and ways to build sub-tree.""""""
            if not tree[n]: return 1, 1 # leaf 
            c, m = 0, 1
            for nn in tree[n]: 
                cc, mm = fn(nn)
                c += cc
                m = (m * comb(c, cc) * mm) % 1_000_000_007
            return c+1, m
        
        return fn(0)[1]",ye15
1920,https://leetcode.com/problems/build-array-from-permutation/discuss/1314345/Python3-1-line,"class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        return [nums[nums[i]] for i in range(len(nums))]",ye15
1925,https://leetcode.com/problems/count-square-sum-triples/discuss/2318104/Easy-Solution-oror-PYTHON,"```class Solution:
    def countTriples(self, n: int) -> int:
        count = 0
        sqrt = 0
        for i in range(1,n-1):
            for j in range(i+1, n):
                sqrt = ((i*i) + (j*j)) ** 0.5
                if sqrt % 1 == 0 and sqrt <= n:
                    count += 2
        return (count)
		

*Please Upvote if you like*",Jonny69
1926,https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/discuss/1329534/Python-3-or-BFS-Deque-In-place-or-Explanation,"class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        q = collections.deque([(*entrance, 0)])
        m, n = len(maze), len(maze[0])
        maze[entrance[0]][entrance[1]] == '+'    
        while q:
            x, y, c = q.popleft()
            if (x == 0 or x == m-1 or y == 0 or y == n-1) and [x, y] != entrance:
                return c
            for i, j in [(x+_x, y+_y) for _x, _y in [(-1, 0), (1, 0), (0, -1), (0, 1)]]:
                if 0 <= i < m and 0 <= j < n and maze[i][j] == '.':
                    maze[i][j] = '+'
                    q.append((i, j, c + 1))
        return -1",idontknoooo
1927,https://leetcode.com/problems/sum-game/discuss/1330360/Python-3-or-Simple-Math-or-Explanation,"class Solution:
    def sumGame(self, num: str) -> bool:
        n = len(num)
        q_cnt_1 = s1 = 0
        for i in range(n//2):    # get digit sum and question mark count for the first half of `num`
            if num[i] == '?':
                q_cnt_1 += 1
            else:    
                s1 += int(num[i])
        q_cnt_2 = s2 = 0				
        for i in range(n//2, n): # get digit sum and question mark count for the second half of `num`
            if num[i] == '?':
                q_cnt_2 += 1
            else:    
                s2 += int(num[i])
        s_diff = s1 - s2         # calculate sum difference and question mark difference
        q_diff = q_cnt_2 - q_cnt_1
        return not (q_diff % 2 == 0 and q_diff // 2 * 9 == s_diff) # When Bob can't win, Alice wins",idontknoooo
1928,https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/discuss/2841255/Python-Dijkstra's-Algorithm%3A-36-time-8-space,"class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:
        n = len(passingFees)
        mat = {}
        for x, y, time in edges:
            if x not in mat: mat[x] = set()
            if y not in mat: mat[y] = set()
            mat[x].add((y, time))
            mat[y].add((x, time))

        h = [(passingFees[0], 0, 0)]
        visited = set()
        while h:
            fees, time_so_far, city = heappop(h)
            if time_so_far > maxTime: continue
            if city == n - 1: return fees

            if (city, time_so_far) in visited: continue
            visited.add((city, time_so_far))
            
            for nxt, time_to_travel in mat[city]:
                # Check if we are retracing a visited path
                if (nxt, time_so_far - time_to_travel) in visited: continue
                heappush(h, (fees + passingFees[nxt], time_so_far + time_to_travel, nxt))
        return -1",hqz3
1929,https://leetcode.com/problems/concatenation-of-array/discuss/2044719/Easy-Python-two-liner-code,"class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        nums.extend(nums)
        return nums",Shivam_Raj_Sharma
1930,https://leetcode.com/problems/unique-length-3-palindromic-subsequences/discuss/1330186/easy-python-solution,"class Solution(object):
    def countPalindromicSubsequence(self, s):
        d=defaultdict(list)
        for i,c in enumerate(s):
            d[c].append(i)
        ans=0
        for el in d:
            if len(d[el])<2:
                continue
            a=d[el][0]
            b=d[el][-1]
            ans+=len(set(s[a+1:b]))
        return(ans)",aayush_chhabra
1931,https://leetcode.com/problems/painting-a-grid-with-three-different-colors/discuss/1338695/Python3-top-down-dp,"class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        
        @cache
        def fn(i, j, mask): 
            """"""Return number of ways to color grid.""""""
            if j == n: return 1 
            if i == m: return fn(0, j+1, mask)
            ans = 0 
            for x in 1<<2*i, 1<<2*i+1, 0b11<<2*i: 
                mask0 = mask ^ x
                if mask0 &amp; 0b11<<2*i and (i == 0 or (mask0 >> 2*i) &amp; 0b11 != (mask0 >> 2*i-2) &amp; 0b11): 
                    ans += fn(i+1, j, mask0)
            return ans % 1_000_000_007
        
        return fn(0, 0, 0)",ye15
1932,https://leetcode.com/problems/merge-bsts-to-create-single-bst/discuss/1410066/Python3-Recursive-tree-building-solution,"class Solution:
    def canMerge(self, trees: List[TreeNode]) -> TreeNode:
        roots, leaves, loners, n = {}, {}, set(), len(trees)
        if n == 1:
            return trees[0]
        for tree in trees:
            if not tree.left and not tree.right:
                loners.add(tree.val)
                continue
            roots[tree.val] = tree
            for node in [tree.left, tree.right]:
                if node:
                    if node.val in leaves:
                        return None
                    leaves[node.val] = node
                
        for loner in loners:
            if loner not in leaves and loner not in roots:
                return None
            
        orphan = None
        for val, tree in roots.items():
            if val not in leaves:
                if orphan:
                    return None
                orphan = tree
        if not orphan:
            return None
        
        def build(node, small, big):
            nonlocal roots
            if not node:
                return True
            if small >= node.val or node.val >= big:
                return False
            
            if node.val in roots:
                node.left, node.right = roots[node.val].left, roots[node.val].right
                del roots[node.val]
            return build(node.left, small, node.val) and build(node.right, node.val, big)
        del roots[orphan.val]
        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)
        return orphan if result and not roots.keys() else None",yiseboge
1935,https://leetcode.com/problems/maximum-number-of-words-you-can-type/discuss/1355349/Easy-Fast-Python-Solutions-(2-Approaches-28ms-32ms-Faster-than-93),"class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        text = text.split()
        length = len(text)
        brokenLetters = set(brokenLetters)

        for word in text:
            for char in word:
                if char in brokenLetters:
                    length -= 1
                    break
					
        return length",the_sky_high
1936,https://leetcode.com/problems/add-minimum-number-of-rungs/discuss/1344878/Divide-gaps-by-dist,"class Solution:
    def addRungs(self, rungs: List[int], dist: int) -> int:
        return sum((a - b - 1) // dist for a, b in zip(rungs, [0] + rungs))",votrubac
1937,https://leetcode.com/problems/maximum-number-of-points-with-cost/discuss/2119013/Python%3A-Dynamic-Programming-O(mn)-Solution,"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        m, n = len(points), len(points[0])
        
        dp = points[0]
        
        left = [0] * n ## left side contribution
        right = [0] * n ## right side contribution
        
        for r in range(1, m):
            for c in range(n):
                if c == 0:
                    left[c] = dp[c]
                else:
                    left[c] = max(left[c - 1] - 1, dp[c])
            
            for c in range(n - 1, -1, -1):
                if c == n-1:
                    right[c] = dp[c]
                else:
                    right[c] = max(right[c + 1] - 1, dp[c])
                    
            for c in range(n):
                dp[c] = points[r][c] + max(left[c], right[c])
                
        return max(dp)",dadhania
1941,https://leetcode.com/problems/check-if-all-characters-have-equal-number-of-occurrences/discuss/1359715/Python3-1-line,"class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        return len(set(Counter(s).values())) == 1",ye15
1942,https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/discuss/1359713/Python-Simple-Heap-Solution-with-Explanation,"class Solution:
    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:
        arrivals = []
        departures = []
        for ind, (x, y) in enumerate(times):
            heappush(arrivals, (x, ind))
            heappush(departures, (y, ind))
        d = {}
        occupied = [0] * len(times)
        while True:
            if arrivals and departures and arrivals[0][0] < departures[0][0]:
                _, ind = heappop(arrivals)
                d[ind] = occupied.index(0)
                occupied[d[ind]] = 1
                if ind == targetFriend:
                    return d[ind]
            elif arrivals and departures and arrivals[0][0] >= departures[0][0]:
                _, ind = heappop(departures)
                occupied[d[ind]] = 0",ajith6198
1943,https://leetcode.com/problems/describe-the-painting/discuss/1359717/Python-Easy-solution-in-O(n*logn)-with-detailed-explanation,"class Solution:
    def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:
		# via this mapping, we can easily know which coordinates should be took into consideration.
        mapping = defaultdict(int)
        for s, e, c in segments:
            mapping[s] += c
            mapping[e] -= c
        
        res = []
        prev, color = None, 0
        for now in sorted(mapping):
            if color: # if color == 0, it means this part isn't painted.
                res.append((prev, now, color))
            
            color += mapping[now]
            prev = now
            
        return res",fishballLin
1944,https://leetcode.com/problems/number-of-visible-people-in-a-queue/discuss/1359735/Python3-mono-stack,"class Solution:
    def canSeePersonsCount(self, heights: List[int]) -> List[int]:
        ans = [0]*len(heights)
        stack = [] # mono-stack 
        for i in reversed(range(len(heights))): 
            while stack and stack[-1] <= heights[i]: 
                ans[i] += 1
                stack.pop()
            if stack: ans[i] += 1
            stack.append(heights[i])
        return ans",ye15
1945,https://leetcode.com/problems/sum-of-digits-of-string-after-convert/discuss/1360730/Python3-simulation,"class Solution:
    def getLucky(self, s: str, k: int) -> int:
        s = """".join(str(ord(ch) - 96) for ch in s)
        for _ in range(k): 
            x = sum(int(ch) for ch in s)
            s = str(x)
        return x",ye15
1946,https://leetcode.com/problems/largest-number-after-mutating-substring/discuss/1360736/Python3-greedy,"class Solution:
    def maximumNumber(self, num: str, change: List[int]) -> str:
        num = list(num)
        on = False 
        for i, ch in enumerate(num): 
            x = int(ch)
            if x < change[x]: 
                on = True
                num[i] = str(change[x])
            elif x > change[x] and on: break
        return """".join(num)",ye15
1947,https://leetcode.com/problems/maximum-compatibility-score-sum/discuss/1360746/Python3-permutations,"class Solution:
    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:
        m = len(students)
        
        score = [[0]*m for _ in range(m)]
        for i in range(m): 
            for j in range(m): 
                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))
        
        ans = 0 
        for perm in permutations(range(m)): 
            ans = max(ans, sum(score[i][j] for i, j in zip(perm, range(m))))
        return ans",ye15
1948,https://leetcode.com/problems/delete-duplicate-folders-in-system/discuss/1360749/Python3-serialize-sub-trees,"class Solution:
    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        paths.sort()
        
        tree = {""#"": -1}
        for i, path in enumerate(paths): 
            node = tree
            for x in path: node = node.setdefault(x, {})
            node[""#""] = i
        
        seen = {}
        mark = set()
        
        def fn(n): 
            """"""Return serialized value of sub-tree rooted at n.""""""
            if len(n) == 1: return ""$"" # leaf node 
            vals = []
            for k in n: 
                if k != ""#"": vals.append(f""${k}${fn(n[k])}"")
            hs = """".join(vals)
            if hs in seen: 
                mark.add(n[""#""])
                mark.add(seen[hs])
            if hs != ""$"": seen[hs] = n[""#""]
            return hs
        
        fn(tree)
        
        ans = []
        stack = [tree]
        while stack: 
            n = stack.pop()
            if n[""#""] >= 0: ans.append(paths[n[""#""]])
            for k in n: 
                if k != ""#"" and n[k][""#""] not in mark: stack.append(n[k])
        return ans",ye15
1952,https://leetcode.com/problems/three-divisors/discuss/1375468/Python3-1-line,"class Solution:
    def isThree(self, n: int) -> bool:
        return sum(n%i == 0 for i in range(1, n+1)) == 3",ye15
1953,https://leetcode.com/problems/maximum-number-of-weeks-for-which-you-can-work/discuss/1375390/Python-Solution-with-detailed-explanation-and-proof-and-common-failure-analysis,"class Solution:
    def numberOfWeeks(self, milestones: List[int]) -> int:
        _sum, _max = sum(milestones), max(milestones)
		# (_sum - _max) is the sum of milestones from (2) the rest of projects, if True, we can form another project with the same amount of milestones as (1)
		# can refer to the section `Why the greedy strategy works?` for the proof
        if _sum - _max >= _max:  
            return _sum
        return 2 * (_sum - _max) + 1  # start from the project with most milestones (_sum - _max + 1) and work on the the rest of milestones (_sum - _max)",fishballLin
1954,https://leetcode.com/problems/minimum-garden-perimeter-to-collect-enough-apples/discuss/1589250/Explanation-for-Intuition-behind-the-math-formula-derivation,"class Solution:
    def minimumPerimeter(self, nap: int) -> int:
        
        
#         here for n = 2 , there are two series :  
#         (1) Diagnal points for n=3 , diagnal apples = 2*n = 6
#         (2) there is series =   2,3,3 =  2+ (sigma(3)-sigma(2))*2
        
#         how to solve:
            
#             here 3  =  sigma(n+(n-1))-sigma(n) = sigma(2*n-1)-sigma(n) =  0.5*2n*(2n-1)-0.5*n*n-1
#         (3) so our final 2,3,3 =   3*2+2 =   (0.5*2n*(2n-1)-0.5*n*n-1)*2+n
#         (4) so final 2,3,3 =  3*n*n - 2*n
#         (5) we have 4 times repitation of (2,3,3)  = 4*(2,3,3)  =   4*(3*n*n - 2*n)   =  12*n*n - 8*n
#         (6) we have 4 diagnal points so their sum(4 diagnal)  = 4*(2*n)
#         (7)  so final sum(total) = 4 diagnal sum + 4(2,3,3)    =   4(2*n)   + 12*n*n - 8*n    =  12*n*n
        
#         so at nth distance we have total  12*n*n  apples at the circumfrance
        
#         so net sum =  sigma(12*n*n)  = 2*n*(n+1)*(2*n+1)
        
        
        n=1
        val=2*n*(n+1)*(2*n+1)
        while(val<nap):
            n+=1
            val=val=2*n*(n+1)*(2*n+1)
        return n*8",martian_rock
1955,https://leetcode.com/problems/count-number-of-special-subsequences/discuss/1387357/Simple-Python-with-comments.-One-pass-O(n)-with-O(1)-space,"class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        total_zeros = 0 # number of subsequences of 0s so far
        total_ones = 0 # the number of subsequences of 0s followed by 1s so far
        total_twos = 0 # the number of special subsequences so far
        
        M = 1000000007
        
        for n in nums:
            if n == 0:
                # if we have found new 0 we can add it to any existing subsequence of 0s
                # or use only this 0
                total_zeros += (total_zeros + 1) % M
            elif n == 1:
                # if we have found new 1 we can add it to any existing subsequence of 0s or 0s and 1s
                # to get a valid subsequence of 0s and 1s
                total_ones += (total_zeros + total_ones) % M
            else:
                # if we have found new 2 we can add it to any existing subsequence of 0s and 1s 0r 0s,1s and 2s
                # to get a valid subsequence of 0s,1s and 2s
                total_twos += (total_ones + total_twos) % M
        
        return total_twos % M",IlyaL
1957,https://leetcode.com/problems/delete-characters-to-make-fancy-string/discuss/2714159/Python-or-Easy-Solution,"class Solution:
    def makeFancyString(self, s: str) -> str:
        stack = []
        for letter in s:
            if len(stack) > 1 and letter == stack[-1] == stack[-2]:
                stack.pop()
            stack.append(letter)
        return ''.join(stack)",manayathgeorgejames
1958,https://leetcode.com/problems/check-if-move-is-legal/discuss/1389250/Python3-check-8-directions,"class Solution:
    def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:
        for di, dj in (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1): 
            i, j = rMove+di, cMove+dj
            step = 0
            while 0 <= i < 8 and 0 <= j < 8: 
                if board[i][j] == color and step: return True 
                if board[i][j] == ""."" or board[i][j] == color and not step: break 
                i, j = i+di, j+dj
                step += 1
        return False",ye15
1959,https://leetcode.com/problems/minimum-total-space-wasted-with-k-resizing-operations/discuss/1389260/Python3-dp,"class Solution:
    def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:
        
        @cache
        def fn(i, k): 
            """"""Return min waste from i with k ops.""""""
            if i == len(nums): return 0
            if k < 0: return inf 
            ans = inf
            rmx = rsm = 0
            for j in range(i, len(nums)): 
                rmx = max(rmx, nums[j])
                rsm += nums[j]
                ans = min(ans, rmx*(j-i+1) - rsm + fn(j+1, k-1))
            return ans 
        
        return fn(0, k)",ye15
1960,https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/discuss/1393832/Python3-Manacher,"class Solution:
    def maxProduct(self, s: str) -> int:
        n = len(s)
        
        # Manacher's algo
        hlen = [0]*n # half-length
        center = right = 0 
        for i in range(n): 
            if i < right: hlen[i] = min(right - i, hlen[2*center - i])
            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: 
                hlen[i] += 1
            if right < i+hlen[i]: center, right = i, i+hlen[i]
        
        prefix = [0]*n
        suffix = [0]*n
        for i in range(n): 
            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)
            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)
        
        for i in range(1, n): 
            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)
            suffix[i] = max(suffix[i], suffix[i-1]-2)
        
        for i in range(1, n): 
            prefix[i] = max(prefix[i-1], prefix[i])
            suffix[~i] = max(suffix[~i], suffix[~i+1])
        
        return max(prefix[i-1]*suffix[i] for i in range(1, n))",ye15
1961,https://leetcode.com/problems/check-if-string-is-a-prefix-of-array/discuss/1390199/Python3-move-along-s,"class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        i = 0
        for word in words: 
            if s[i:i+len(word)] != word: return False 
            i += len(word)
            if i == len(s): return True 
        return False",ye15
1962,https://leetcode.com/problems/remove-stones-to-minimize-the-total/discuss/1390207/Python3-priority-queue,"class Solution:
    def minStoneSum(self, piles: List[int], k: int) -> int:
        pq = [-x for x in piles]
        heapify(pq)
        for _ in range(k): heapreplace(pq, pq[0]//2)
        return -sum(pq)",ye15
1963,https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/discuss/1390576/Two-Pointers,"class Solution:
    def minSwaps(self, s: str) -> int:
        res, bal = 0, 0
        for ch in s:
            bal += 1 if ch == '[' else -1
            if bal == -1:
                res += 1
                bal = 1
        return res",votrubac
1964,https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/discuss/1390573/Clean-and-Simple-oror-98-faster-oror-Easy-Code,"class Solution:
def longestObstacleCourseAtEachPosition(self, obs: List[int]) -> List[int]:
    local = []
    res=[0 for _ in range(len(obs))]
    for i in range(len(obs)):
        n=obs[i]
        if len(local)==0 or local[-1]<=n:
            local.append(n)
            res[i]=len(local)
        else:
            ind = bisect.bisect_right(local,n)
            local[ind]=n
            res[i]=ind+1
    
    return res",abhi9Rai
1967,https://leetcode.com/problems/number-of-strings-that-appear-as-substrings-in-word/discuss/1404073/Python3-1-line,"class Solution:
    def numOfStrings(self, patterns: List[str], word: str) -> int:
        return sum(x in word for x in patterns)",ye15
1968,https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/discuss/2280763/O(nlogn)-Solution-or-Python,"class Solution:
   
        
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        if len(nums)==3:
            nums[1],nums[0] = nums[0],nums[1]
            return nums
        for i in range(1,len(nums)-1):
            if nums[i]-nums[i-1] == nums[i+1]-nums[i]:
                if i!=len(nums)-2:
                    nums[i+1],nums[i+2] = nums[i+2],nums[i+1] 
                if i==len(nums)-2:
                    nums[i+1],nums[0] = nums[0],nums[i+1]
        return nums",user7457RV
1969,https://leetcode.com/problems/minimum-non-zero-product-of-the-array-elements/discuss/1403953/Python3-2-line,"class Solution:
    def minNonZeroProduct(self, p: int) -> int:
        x = (1 << p) - 1
        return pow(x-1, (x-1)//2, 1_000_000_007) * x % 1_000_000_007",ye15
1970,https://leetcode.com/problems/last-day-where-you-can-still-cross/discuss/2489142/Python3-or-Binary-Search-%2B-BFS,"class Solution(object):
    def latestDayToCross(self, row, col, cells):
        l,h=0,len(cells)-1
        ans=-1
        while l<=h:
            m=(l+h)>>1
            if self.isPath(cells,m,row,col):
                l=m+1
                ans=m+1
            else:
                h=m-1
        return ans
    def isPath(self,cells,ind,row,col):
        grid=[[0 for i in range(col)] for j in range(row)]
        for i in range(ind+1):
            x,y=cells[i]
            grid[x-1][y-1]=1
        vis=set()
        for i in range(col):
            if grid[0][i]!=1:
                dq=deque()
                dq.append((0,i))
                dr=[(-1,0),(0,-1),(1,0),(0,1)]
                while dq:
                    x,y=dq.popleft()
                    if x==row-1:
                        return True
                    for d in dr:
                        dx,dy=d
                        if 0<=x+dx<row and 0<=y+dy<col and grid[x+dx][y+dy]!=1 and (x+dx,y+dy) not in vis:
                            vis.add((x+dx,y+dy))
                            dq.append((x+dx,y+dy))
        return False",swapnilsingh421
1971,https://leetcode.com/problems/find-if-path-exists-in-graph/discuss/1406782/Python-Easy-to-Understand-or-Beginners,"class Solution(object):
    def validPath(self, n, edges, start, end):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type start: int
        :type end: int
        :rtype: bool
        """"""
        visited = [False]*n
        d = {}
		#store the undirected edges for both vertices
        for i in edges:
            if i[0] in d:
                d[i[0]].append(i[1])
            else:
                d[i[0]] = [i[1]]
                
            if i[1] in d:
                d[i[1]].append(i[0])
            else:
                d[i[1]] = [i[0]]
        #create a queue as we will apply BFS
        q = [start]
        while q:
            curr = q.pop(0)  #pop the first element as we do in queue
            if curr == end:  #if its the end then we can return True
                return True
            elif curr in d and not visited[curr]: #else if it is not the end then check whether its visited or not
                q.extend(d[curr])  #add the adjacent vertices of the current node to the queue
            visited[curr] = True  #mark this curr vertex as visited = True, so that we dont visit this vertex again
        return False  #return False if the queue gets empty and we dont reach the end",Sibu0811
1974,https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/discuss/1417585/Python3-greedy,"class Solution:
    def minTimeToType(self, word: str) -> int:
        ans = len(word)
        prev = ""a""
        for ch in word: 
            val = (ord(ch) - ord(prev)) % 26 
            ans += min(val, 26 - val)
            prev = ch
        return ans",ye15
1975,https://leetcode.com/problems/maximum-matrix-sum/discuss/1417592/Python3-greedy,"class Solution:
    def maxMatrixSum(self, matrix: List[List[int]]) -> int:
        ans = mult = 0
        val = inf 
        for i in range(len(matrix)): 
            for j in range(len(matrix)):
                ans += abs(matrix[i][j])
                val = min(val, abs(matrix[i][j]))
                if matrix[i][j] < 0: mult ^= 1
        return ans - 2*mult*val",ye15
1976,https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/discuss/1417598/Python3-dfs-%2B-dp,"class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        graph = {}
        for u, v, time in roads: 
            graph.setdefault(u, {})[v] = time
            graph.setdefault(v, {})[u] = time
            
        dist = [inf]*n
        dist[-1] = 0
        stack = [(n-1, 0)]
        while stack: 
            x, t = stack.pop()
            if t == dist[x]: 
                for xx in graph.get(x, {}): 
                    if t + graph[x][xx] < dist[xx]: 
                        dist[xx] = t + graph[x][xx]
                        stack.append((xx, t + graph[x][xx]))
                        
        @cache
        def fn(x):
            """"""Return """"""
            if x == n-1: return 1 
            if dist[x] == inf: return 0 
            ans = 0 
            for xx in graph.get(x, {}): 
                if graph[x][xx] + dist[xx] == dist[x]: ans += fn(xx)
            return ans % 1_000_000_007
        
        return fn(0)",ye15
1977,https://leetcode.com/problems/number-of-ways-to-separate-numbers/discuss/1424057/Python3-dp,"class Solution:
    def numberOfCombinations(self, num: str) -> int:
        n = len(num)
        lcs = [[0]*(n+1) for _ in range(n)]
        for i in reversed(range(n)): 
            for j in reversed(range(i+1, n)): 
                if num[i] == num[j]: lcs[i][j] = 1 + lcs[i+1][j+1]
        
        def cmp(i, j, d): 
            """"""Return True if """"""
            m = lcs[i][j]
            if m >= d: return True 
            return num[i+m] <= num[j+m]
        
        dp = [[0]*(n+1) for _ in range(n)]
        for i in range(n): 
            if num[i] != ""0"": 
                for j in range(i+1, n+1): 
                    if i == 0: dp[i][j] = 1
                    else: 
                        dp[i][j] = dp[i][j-1]
                        if 2*i-j >= 0 and cmp(2*i-j, i, j-i): dp[i][j] += dp[2*i-j][i]
                        if 2*i-j+1 >= 0 and not cmp(2*i-j+1, i, j-i-1): dp[i][j] += dp[2*i-j+1][i]
        return sum(dp[i][n] for i in range(n)) % 1_000_000_007",ye15
1979,https://leetcode.com/problems/find-greatest-common-divisor-of-array/discuss/2580234/2-lines-PythonJavascript-(no-built-in-gcd-function),"class Solution:
    def findGCD(self, nums: List[int]) -> int:
        gcd = lambda a, b: a if b == 0 else gcd(b, a % b)
        return gcd(max(nums), min(nums))",SmittyWerbenjagermanjensen
1980,https://leetcode.com/problems/find-unique-binary-string/discuss/1657090/One-line-python-Solution,"class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        return list(set(list((map(lambda x:"""".join(list(map(str,x))),list(itertools.product([0,1],repeat=len(nums)))))))-set(nums))[0]",amannarayansingh10
1981,https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/discuss/1418634/100-efficient-or-Pruning-%2B-Memoization-or-Dynamic-Programming-or-Explanation,"class Solution:
    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
        
        # store the mxn size of the matrix
        m = len(mat)
        n = len(mat[0])
        
        dp = defaultdict(defaultdict)
        
        # Sorting each row of the array for more efficient pruning
        # Note:this purely based on the observation on problem constraints (although interesting :))
        for i in range(m):
            mat[i] = sorted(mat[i])
        
        # returns minimum absolute starting from from row i to n-1 for the target
        globalMin = float(""inf"")
        def findMinAbsDiff(i,prevSum):
            nonlocal globalMin
            if i == m:
                globalMin = min(globalMin, abs(prevSum-target))
                return abs(prevSum-target)
            
            # pruning step 1
            # because the array is increasing &amp; prevSum &amp; target will always be positive
            if prevSum-target > globalMin:
                return float(""inf"")
            
            
            if (i in dp) and (prevSum in dp[i]):
                return dp[i][prevSum]
            
            minDiff = float(""inf"")
            # for each candidate select that and backtrack
            for j in range(n):
                diff = findMinAbsDiff(i+1, prevSum+mat[i][j])
                # pruning step 2 - break if we found minDiff 0 --> VERY CRTICIAL
                if diff == 0:
                    minDiff = 0
                    break
                minDiff = min(minDiff, diff)
            
            dp[i][prevSum] = minDiff
            return minDiff
        
        return findMinAbsDiff(0, 0)",CaptainX
1982,https://leetcode.com/problems/find-array-given-subset-sums/discuss/1431457/Easy-Explanation-for-Noobs-%2B-Python-code-with-comments,"class Solution:
    def recoverArray(self, n: int, sums: List[int]) -> List[int]:
        res = []  # Result set
        sums.sort()
        
        while len(sums) > 1:
            num = sums[-1] - sums[-2] # max - secondMax
            countMap = Counter(sums) # Get count of each elements
            excluding = [] # Subset sums that do NOT contain num
            including = [] # Subset sums that contain num
            
            for x in sums:
                if countMap.get(x) > 0:
                    excluding.append(x)
                    including.append(x+num)
                    countMap[x] -= 1
                    countMap[x+num] -= 1
                    
			# Check validity of excluding set	
            if 0 in excluding:
                sums = excluding
                res.append(num)
            else:
                sums = including
                res.append(-1*num)
        
        return res",sumit686215
1984,https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/discuss/1433298/Python3-greedy-2-line,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        return min(nums[i+k-1]-nums[i] for i in range(len(nums)-k+1))",ye15
1985,https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/discuss/1432093/Python-or-The-Right-Way-during-Interview-or-Comparators,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        nums = sorted(map(int, nums), reverse=True)
        return str(nums[k-1])",malraharsh
1986,https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/discuss/1433054/Python-or-Backtracking-or-664ms-or-100-time-and-space-or-Explanation,"class Solution:
    def minSessions(self, tasks: List[int], sessionTime: int) -> int:
        subsets = []
        self.ans = len(tasks)
        
        def func(idx):
            if len(subsets) >= self.ans:
                return
            
            if idx == len(tasks):
                self.ans = min(self.ans, len(subsets))
                return
            
            for i in range(len(subsets)):
                if subsets[i] + tasks[idx] <= sessionTime:
                    subsets[i] += tasks[idx]
                    func(idx + 1)
                    subsets[i] -= tasks[idx]
            
            subsets.append(tasks[idx])
            func(idx + 1)
            subsets.pop()
        
        func(0)
        return self.ans",detective_dp
1987,https://leetcode.com/problems/number-of-unique-good-subsequences/discuss/1433355/Python3-bit-mask-dp,"class Solution:
    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
        
        @cache
        def fn(i, mask, v): 
            """"""Return # unique good subsequences starting with 1.""""""
            if i == len(binary) or not mask: return v
            x = int(binary[i])
            if not mask &amp; (1<<x): return fn(i+1, mask, v)
            return (fn(i+1, 3, 1) + fn(i+1, mask^(1<<x), v)) % 1_000_000_007
        
        return fn(0, 2, 0) + int(""0"" in binary)",ye15
1991,https://leetcode.com/problems/find-the-middle-index-in-array/discuss/2321632/Python-98.85-faster-or-Simplest-solution-with-explanation-or-Beg-to-Adv-or-Prefix-Sum,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        left = 0 # nums[0] + nums[1] + ... + nums[middleIndex-1]
        right = sum(nums) # nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]

        for i, num in enumerate(nums): # we can use normal for loop as well.
            right -= num # as we are trying to find out middle index so iteratively we`ll reduce the value of right to find the middle index
            if left == right: # comparing the values for finding out the middle index.
                return i # if there is any return the index whixh will be our required index.
            left += num # we have to add the num iteratively. 

        return -1",rlakshay14
1992,https://leetcode.com/problems/find-all-groups-of-farmland/discuss/1444115/Python3-dfs,"class Solution:
    def findFarmland(self, land: List[List[int]]) -> List[List[int]]:
        m, n = len(land), len(land[0])
        ans = []
        for i in range(m):
            for j in range(n): 
                if land[i][j]: # found farmland
                    mini, minj = i, j 
                    maxi, maxj = i, j 
                    stack = [(i, j)]
                    land[i][j] = 0 # mark as visited 
                    while stack: 
                        i, j = stack.pop()
                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                            if 0 <= ii < m and 0 <= jj < n and land[ii][jj]: 
                                stack.append((ii, jj))
                                land[ii][jj] = 0 
                                maxi = max(maxi, ii)
                                maxj = max(maxj, jj)
                    ans.append([mini, minj, maxi, maxj])
        return ans",ye15
1994,https://leetcode.com/problems/the-number-of-good-subsets/discuss/1444318/Python3-dp,"class Solution:
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        freq = [0] * 31
        for x in nums: freq[x] += 1
        
        masks = [0] * 31
        for x in range(1, 31): 
            if x == 1: masks[x] = 0b10
            else: 
                bits = 0
                xx = x
                for k in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29): 
                    while xx % k == 0: 
                        if (bits >> k) &amp; 1: break # repeated factors 
                        bits ^= 1 << k
                        xx //= k
                    else: continue 
                    break 
                else: masks[x] = bits
                    
        @cache
        def fn(x, m): 
            """"""Return number of good subsets.""""""
            if x == 31: return int(m > 2)
            ans = fn(x+1, m)
            if freq[x] and masks[x]: 
                if x == 1: ans *= 2**freq[x]
                elif not m &amp; masks[x]: ans += freq[x] * fn(x+1, m | masks[x])
            return ans % 1_000_000_007
        
        return fn(1, 0)",ye15
1995,https://leetcode.com/problems/count-special-quadruplets/discuss/1445362/Python-non-brute-force.-Time%3A-O(N2)-Space%3A-O(N2),"class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        idx = defaultdict(list)
        for i in range(len(nums)-1):
            for j in range(i+1, len(nums)):
                idx[nums[j]-nums[i]].append(i)
        
        count = 0 
        for i in range(len(nums)-3):
            for j in range(i+1, len(nums)-2):
                count += sum(k > j for k in idx[nums[i]+nums[j]])
                        
        return count",blue_sky5
1996,https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/discuss/1445198/Python-Sort,"class Solution:
    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:
        
        properties.sort(key=lambda x: (-x[0],x[1]))
        
        ans = 0
        curr_max = 0
        
        for _, d in properties:
            if d < curr_max:
                ans += 1
            else:
                curr_max = d
        return ans",lokeshsenthilkumar
1997,https://leetcode.com/problems/first-day-where-you-have-been-in-all-the-rooms/discuss/1446619/Python3-dp,"class Solution:
    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:
        odd = [0]
        even = [1]
        for i in range(1, len(nextVisit)): 
            odd.append((even[-1] + 1) % 1_000_000_007)
            even.append((2*odd[-1] - odd[nextVisit[i]] + 1) % 1_000_000_007)
        return odd[-1]",ye15
2000,https://leetcode.com/problems/reverse-prefix-of-word/discuss/1472737/Easy-Python-Solution-(28ms)-or-Faster-than-93,"class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        try:
            ix = word.index(ch)
            return word[:ix+1][::-1] + word[ix+1:]
        except ValueError:
            return word",the_sky_high
2001,https://leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/discuss/2818774/O(n)-solution-of-Combined-Dictionary-and-Pre-sum-in-Python,"class Solution:
    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:
        preSum = []
        for rec in rectangles:
            preSum.append(rec[1]/rec[0])
        
        dic1 = {}
        for i in range(len(preSum)-1, -1, -1):
            if preSum[i] not in dic1.keys():
                dic1[preSum[i]] = [0,1]
            else:
                dic1[preSum[i]][0] = dic1[preSum[i]][0] + dic1[preSum[i]][1]
                dic1[preSum[i]][1] += 1
        
        return sum ([v[0] for v in dic1.values()])",DNST
2002,https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/discuss/1458484/Python-Bruteforce,"class Solution:
    def maxProduct(self, s: str) -> int:
        subs = []
        n = len(s)
        def dfs(curr, ind, inds):
            if ind == n:
                if curr == curr[::-1]:
                    subs.append((curr, inds))
                return
            dfs(curr+s[ind], ind+1, inds|{ind})
            dfs(curr, ind+1, inds)
        
        dfs('', 0, set())
        
        res = 0
        n = len(subs)
        for i in range(n):
            s1, i1 = subs[i]
            for j in range(i+1, n):
                s2, i2 = subs[j]
                if len(i1 &amp; i2) == 0:
                    res = max(res, len(s1)*len(s2))
        return res",ajith6198
2003,https://leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree/discuss/1461767/Python3-dfs,"class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        ans = [1] * len(parents)
        if 1 in nums: 
            tree = {}
            for i, x in enumerate(parents): 
                tree.setdefault(x, []).append(i)
                
            k = nums.index(1)
            val = 1
            seen = set()
            
            while k != -1: 
                stack = [k]
                while stack: 
                    x = stack.pop()
                    seen.add(nums[x])
                    for xx in tree.get(x, []): 
                        if nums[xx] not in seen: 
                            stack.append(xx)
                            seen.add(nums[xx])
                while val in seen: val += 1
                ans[k] = val
                k = parents[k]
        return ans",ye15
2006,https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/discuss/1471015/Python-Clean-and-concise.-Dictionary-T.C-O(N),"class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        seen = defaultdict(int)
        counter = 0
        for num in nums:
            tmp, tmp2 = num - k, num + k
            if tmp in seen:
                counter += seen[tmp]
            if tmp2 in seen:
                counter += seen[tmp2]
            
            seen[num] += 1
        
        return counter",asbefu
2008,https://leetcode.com/problems/maximum-earnings-from-taxi/discuss/1485339/Python-Solution-Maximum-Earnings-from-Taxi,"class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:
        
        d = {}
        for start,end,tip in rides:
            if end not in d:
                d[end] =[[start,tip]]
            else:
                d[end].append([start,tip])
        
       
        dp = [0]*(n+1)
        dp[0] = 0
        
        for i in range(1,n+1):
            dp[i] = dp[i-1]
            if i in d:
                temp_profit = 0
                for start,tip in d[i]:
                    if (i-start)+tip+dp[start] > temp_profit:
                        temp_profit = i-start+tip+dp[start]
                dp[i] = max(dp[i],temp_profit)
                
                
        return dp[-1]",SaSha59
2009,https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/discuss/1471593/Python3-sliding-window,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        nums = sorted(set(nums))
        
        ans = ii = 0
        for i, x in enumerate(nums): 
            if x - nums[ii] >= n: ii += 1
            ans = max(ans, i - ii + 1)
        return n - ans",ye15
2011,https://leetcode.com/problems/final-value-of-variable-after-performing-operations/discuss/1472568/Python3-A-Simple-Solution-and-A-One-Line-Solution,"class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        x = 0
        for o in operations:
            if '+' in o:
                x += 1
            else:
                x -= 1
        return x",terrencetang
2012,https://leetcode.com/problems/sum-of-beauty-in-the-array/discuss/1477177/Python3-or-Brute-Force-(TLE)-and-O(n)-solution-with-explanation-or-86ile-runtime,"class Solution:
    def sumOfBeauties(self, nums: List[int]) -> int:
        beauty=[0]*len(nums)
        for i in range(1,len(nums)-1):
            leftarr=nums[:i]
            rightarr=nums[i+1:]
            if(max(leftarr)<nums[i] and min(rightarr)>nums[i]):
                beauty[i]=2
            elif(nums[i-1]<nums[i] and nums[i+1]>nums[i]):
                beauty[i]=1
            else:
                beauty[i]=0
        return sum(beauty)",aaditya47
2014,https://leetcode.com/problems/longest-subsequence-repeated-k-times/discuss/1477019/Python3-bfs,"class Solution:
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        freq = [0] * 26
        for ch in s: freq[ord(ch)-97] += 1
        
        cand = [chr(i+97) for i, x in enumerate(freq) if x >= k] # valid candidates 
        
        def fn(ss): 
            """"""Return True if ss is a k-repeated sub-sequence of s.""""""
            i = cnt = 0
            for ch in s: 
                if ss[i] == ch: 
                    i += 1
                    if i == len(ss): 
                        if (cnt := cnt + 1) == k: return True  
                        i = 0
            return False 
        
        ans = """"
        queue = deque([""""])
        while queue: 
            x = queue.popleft()
            for ch in cand:  
                xx = x + ch
                if fn(xx): 
                    ans = xx
                    queue.append(xx)
        return ans",ye15
2016,https://leetcode.com/problems/maximum-difference-between-increasing-elements/discuss/1486318/Python3-prefix-min,"class Solution:
    def maximumDifference(self, nums: List[int]) -> int:
        ans = -1 
        prefix = inf
        for i, x in enumerate(nums): 
            if i and x > prefix: ans = max(ans, x - prefix)
            prefix = min(prefix, x)
        return ans",ye15
2017,https://leetcode.com/problems/grid-game/discuss/1486349/Python-Easy,"class Solution(object):
    def gridGame(self, grid):
        
        top, bottom = grid
        top_sum = sum(top)
        bottom_sum = 0
        res = float('inf')
        
        for i in range(len(top)):
            top_sum -= top[i]
            res = min(res, max(top_sum, bottom_sum))
            bottom_sum += bottom[i]
            
        return res",lokeshsenthilkumar
2018,https://leetcode.com/problems/check-if-word-can-be-placed-in-crossword/discuss/1486326/Python3-row-by-row-and-col-by-col,"class Solution:
    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:
        for x in board, zip(*board): 
            for row in x: 
                for s in """".join(row).split(""#""): 
                    for w in word, word[::-1]: 
                        if len(s) == len(w) and all(ss in ("" "", ww) for ss, ww in zip(s, w)): return True 
        return False",ye15
2019,https://leetcode.com/problems/the-score-of-students-solving-math-expression/discuss/1487285/Python3-somewhat-dp,"class Solution:
    def scoreOfStudents(self, s: str, answers: List[int]) -> int:
        
        @cache
        def fn(lo, hi): 
            """"""Return possible answers of s[lo:hi].""""""
            if lo+1 == hi: return {int(s[lo])}
            ans = set()
            for mid in range(lo+1, hi, 2): 
                for x in fn(lo, mid): 
                    for y in fn(mid+1, hi): 
                        if s[mid] == ""+"" and x + y <= 1000: ans.add(x + y)
                        elif s[mid] == ""*"" and x * y <= 1000: ans.add(x * y)
            return ans 
                
        target = eval(s)
        cand = fn(0, len(s))
        ans = 0 
        for x in answers: 
            if x == target: ans += 5
            elif x in cand: ans += 2
        return ans",ye15
2022,https://leetcode.com/problems/convert-1d-array-into-2d-array/discuss/1499000/Python3-simulation,"class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        ans = []
        if len(original) == m*n: 
            for i in range(0, len(original), n): 
                ans.append(original[i:i+n])
        return ans",ye15
2023,https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/discuss/1499007/Python3-freq-table,"class Solution:
    def numOfPairs(self, nums: List[str], target: str) -> int:
        freq = Counter(nums)
        ans = 0 
        for k, v in freq.items(): 
            if target.startswith(k): 
                suffix = target[len(k):]
                ans += v * freq[suffix]
                if k == suffix: ans -= freq[suffix]
        return ans",ye15
2024,https://leetcode.com/problems/maximize-the-confusion-of-an-exam/discuss/1951750/WEEB-DOES-PYTHONC%2B%2B-SLIDING-WINDOW,"class Solution:
	def maxConsecutiveAnswers(self, string: str, k: int) -> int:
		result = 0
		j = 0
		count1 = k
		for i in range(len(string)):
			if count1 == 0 and string[i] == ""F"":
				while string[j] != ""F"":
					j+=1
				count1+=1 
				j+=1

			if string[i] == ""F"":
				if count1 > 0:
					count1-=1

			if i - j + 1 > result:
				result = i - j + 1

		j = 0
		count2 = k
		for i in range(len(string)):
			if count2 == 0 and string[i] == ""T"":
				while string[j] != ""T"":
					j+=1
				count2+=1 
				j+=1

			if string[i] == ""T"":
				if count2 > 0:
					count2-=1

			if i - j + 1 > result:
				result = i - j + 1

		return result",Skywalker5423
2025,https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/discuss/1499024/Python3-binary-search,"class Solution:
    def waysToPartition(self, nums: List[int], k: int) -> int:
        prefix = [0]
        loc = defaultdict(list)
        for i, x in enumerate(nums): 
            prefix.append(prefix[-1] + x)
            if i < len(nums)-1: loc[prefix[-1]].append(i)
        
        ans = 0 
        if prefix[-1] % 2 == 0: ans = len(loc[prefix[-1]//2]) # unchanged 
        
        total = prefix[-1]
        for i, x in enumerate(nums): 
            cnt = 0 
            diff = k - x
            target = total + diff 
            if target % 2 == 0: 
                target //= 2
                cnt += bisect_left(loc[target], i)
                cnt += len(loc[target-diff]) - bisect_left(loc[target-diff], i)
            ans = max(ans, cnt)
        return ans",ye15
2027,https://leetcode.com/problems/minimum-moves-to-convert-string/discuss/1500215/Python3-scan,"class Solution:
    def minimumMoves(self, s: str) -> int:
        ans = i = 0
        while i < len(s): 
            if s[i] == ""X"": 
                ans += 1
                i += 3
            else: i += 1
        return ans",ye15
2028,https://leetcode.com/problems/find-missing-observations/discuss/1506196/Divmod-and-list-comprehension-96-speed,"class Solution:
    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        missing_val, rem = divmod(mean * (len(rolls) + n) - sum(rolls), n)
        if rem == 0:
            if 1 <= missing_val <= 6:
                return [missing_val] * n
        elif 1 <= missing_val < 6:
            return [missing_val + 1] * rem + [missing_val] * (n - rem)
        return []",EvgenySH
2029,https://leetcode.com/problems/stone-game-ix/discuss/1500343/Python3-freq-table,"class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        freq = defaultdict(int)
        for x in stones: freq[x % 3] += 1
        
        if freq[0]%2 == 0: return freq[1] and freq[2]
        return abs(freq[1] - freq[2]) >= 3",ye15
2030,https://leetcode.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/discuss/1502134/PYTHON3-O(n)-using-stack-with-explanation,"class Solution:
    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
        counts,total = 0, 0
        n = len(s)
        for ch in s:
            if ch==letter:
                total +=1
        stack = []
        occ = 0
        for idx,ch in enumerate(s):
            if ch==letter:
                counts +=1
            while stack and stack[-1]>ch and  len(stack)+ (n-1-idx)>=k and (occ+total-counts-(stack[-1]==letter)+(ch==letter)>=repetition ): 
                occ -= stack.pop()==letter
            if ch!=letter  and len(stack)< k-max(0,(repetition-occ)):
                stack.append(ch)
            elif ch==letter and len(stack)+(total-counts)<k:
                stack.append(ch)
                occ +=1
        return ''.join(stack)",irt
2032,https://leetcode.com/problems/two-out-of-three/discuss/1513311/Python3-set,"class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        s1, s2, s3 = set(nums1), set(nums2), set(nums3)
        return (s1&amp;s2) | (s2&amp;s3) | (s1&amp;s3)",ye15
2033,https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/discuss/1513319/Python3-median-4-line,"class Solution:
    def minOperations(self, grid: List[List[int]], x: int) -> int:
        vals = [x for row in grid for x in row]
        if len(set(val%x for val in vals)) > 1: return -1 # impossible
        median = sorted(vals)[len(vals)//2] # O(N) possible via ""quick select""
        return sum(abs(val - median)//x for val in vals)",ye15
2035,https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/discuss/1513435/Python-or-Easy-Explanation-or-Meet-in-the-Middle,"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        N = len(nums) // 2 # Note this is N/2, ie no. of elements required in each.
        
        def get_sums(nums): # generate all combinations sum of k elements
            ans = {}
            N = len(nums)
            for k in range(1, N+1): # takes k element for nums
                sums = []
                for comb in combinations(nums, k):
                    s = sum(comb)
                    sums.append(s)
                ans[k] = sums
            return ans
        
        left_part, right_part = nums[:N], nums[N:]
        left_sums, right_sums = get_sums(left_part), get_sums(right_part)
        ans = abs(sum(left_part) - sum(right_part)) # the case when taking all N from left_part for left_ans, and vice versa
        total = sum(nums) 
        half = total // 2 # the best sum required for each, we have to find sum nearest to this
        for k in range(1, N):
            left = left_sums[k] # if taking k no. from left_sums
            right = right_sums[N-k] # then we have to take remaining N-k from right_sums.
            right.sort() # sorting, so that we can binary search the required value
            for x in left:
                r = half - x # required, how much we need to add in x to bring it closer to half.
                p = bisect.bisect_left(right, r) # we are finding index of value closest to r, present in right, using binary search
                for q in [p, p-1]:
                    if 0 <= q < len(right):
                        left_ans_sum = x + right[q]
                        right_ans_sum = total - left_ans_sum
                        diff = abs(left_ans_sum - right_ans_sum)
                        ans = min(ans, diff) 
        return ans",malraharsh
2037,https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/discuss/1539518/O(n)-counting-sort-in-Python,"class Solution:
    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        seats.sort()
        students.sort()
        return sum(abs(seat - student) for seat, student in zip(seats, students))",mousun224
2038,https://leetcode.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/discuss/1524153/C%2B%2BPythonJava-Count-%22AAA%22-and-%22BBB%22,"class Solution:
    def winnerOfGame(self, s: str) -> bool:
        
        a = b = 0
        
        for i in range(1,len(s)-1):
            if s[i-1] == s[i] == s[i+1]:
                if s[i] == 'A':
                    a += 1
                else:
                    b += 1
                    
        return a>b",lokeshsenthilkumar
2039,https://leetcode.com/problems/the-time-when-the-network-becomes-idle/discuss/1524183/Python3-graph,"class Solution:
    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:
        graph = {}
        for u, v in edges: 
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)
        
        dist = [-1]*len(graph)
        dist[0] = 0 
        val = 0
        queue = [0]
        while queue: 
            val += 2
            newq = []
            for u in queue: 
                for v in graph[u]: 
                    if dist[v] == -1: 
                        dist[v] = val
                        newq.append(v)
            queue = newq
        
        ans = 0
        for d, p in zip(dist, patience): 
            if p: 
                k = d//p - int(d%p == 0)
                ans = max(ans, d + k*p)
        return ans + 1",ye15
2040,https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/discuss/1524190/Python3-binary-search,"class Solution:
    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
        
        def fn(val):
            """"""Return count of products <= val.""""""
            ans = 0
            for x in nums1: 
                if x < 0: ans += len(nums2) - bisect_left(nums2, ceil(val/x))
                elif x == 0: 
                    if 0 <= val: ans += len(nums2)
                else: ans += bisect_right(nums2, floor(val/x))
            return ans 
            
        lo, hi = -10**10, 10**10 + 1
        while lo < hi: 
            mid = lo + hi >> 1
            if fn(mid) < k: lo = mid + 1
            else: hi = mid
        return lo",ye15
2042,https://leetcode.com/problems/check-if-numbers-are-ascending-in-a-sentence/discuss/1525219/Python3-2-line,"class Solution:
    def areNumbersAscending(self, s: str) -> bool:
        nums = [int(w) for w in s.split() if w.isdigit()]
        return all(nums[i-1] < nums[i] for i in range(1, len(nums)))",ye15
2044,https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/discuss/1525225/Python3-top-down-dp,"class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        target = reduce(or_, nums)
        
        @cache
        def fn(i, mask): 
            """"""Return number of subsets to get target.""""""
            if mask == target: return 2**(len(nums)-i)
            if i == len(nums): return 0 
            return fn(i+1, mask | nums[i]) + fn(i+1, mask)
        
        return fn(0, 0)",ye15
2045,https://leetcode.com/problems/second-minimum-time-to-reach-destination/discuss/1525227/Python3-Dijkstra-and-BFS,"class Solution:
    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        graph = [[] for _ in range(n)]
        for u, v in edges: 
            graph[u-1].append(v-1)
            graph[v-1].append(u-1)
        pq = [(0, 0)]
        seen = [[] for _ in range(n)]
        least = None
        while pq: 
            t, u = heappop(pq)
            if u == n-1: 
                if least is None: least = t
                elif least < t: return t 
            if (t//change) &amp; 1: t = (t//change+1)*change # waiting for green
            t += time
            for v in graph[u]: 
                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t: 
                    seen[v].append(t)
                    heappush(pq, (t, v))",ye15
2047,https://leetcode.com/problems/number-of-valid-words-in-a-sentence/discuss/1537625/Python3-check-words,"class Solution:
    def countValidWords(self, sentence: str) -> int:
        
        def fn(word): 
            """"""Return true if word is valid.""""""
            seen = False 
            for i, ch in enumerate(word): 
                if ch.isdigit() or ch in ""!.,"" and i != len(word)-1: return False
                elif ch == '-': 
                    if seen or i == 0 or i == len(word)-1 or not word[i+1].isalpha(): return False 
                    seen = True 
            return True 
        
        return sum(fn(word) for word in sentence.split())",ye15
2048,https://leetcode.com/problems/next-greater-numerically-balanced-number/discuss/1537537/Python3-brute-force,"class Solution:
    def nextBeautifulNumber(self, n: int) -> int:
        while True: 
            n += 1
            nn = n 
            freq = defaultdict(int)
            while nn: 
                nn, d = divmod(nn, 10)
                freq[d] += 1
            if all(k == v for k, v in freq.items()): return n",ye15
2049,https://leetcode.com/problems/count-nodes-with-the-highest-score/discuss/1537603/Python-3-or-Graph-DFS-Post-order-Traversal-O(N)-or-Explanation,"class Solution:
    def countHighestScoreNodes(self, parents: List[int]) -> int:
        graph = collections.defaultdict(list)
        for node, parent in enumerate(parents):  # build graph
            graph[parent].append(node)
        n = len(parents)                         # total number of nodes
        d = collections.Counter()
        def count_nodes(node):                   # number of children node + self
            p, s = 1, 0                          # p: product, s: sum
            for child in graph[node]:            # for each child (only 2 at maximum)
                res = count_nodes(child)         # get its nodes count
                p *= res                         # take the product
                s += res                         # take the sum
            p *= max(1, n - 1 - s)               # times up-branch (number of nodes other than left, right children ans itself)
            d[p] += 1                            # count the product
            return s + 1                         # return number of children node + 1 (self)
        count_nodes(0)                           # starting from root (0)
        return d[max(d.keys())]                  # return max count",idontknoooo
2050,https://leetcode.com/problems/parallel-courses-iii/discuss/1546258/Python-solution-using-topology-sort-and-BFS,"class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        graph = { course:[] for course in range(n)}
        inDegree = [0]*n
        # 1- build graph
        #  convert 1-base into 0-baseindexes and add to graph
        # Note: choose Prev->next since it helps to preserve the topology order
        for prevCourse,nextCourse in relations:
            prevCourse,nextCourse = prevCourse-1, nextCourse-1
            graph[prevCourse].append(nextCourse)
            inDegree[nextCourse] += 1

        # 2 Assign time cost
        q = collections.deque()
        cost = [0] * n
        for course in range(n):
            if inDegree[course] == 0:
                q.append(course)
                cost[course] = time[course] # number of months
        # 3- BFS
        while q:
            prevCourse = q.popleft()
            for nextCourse in graph[prevCourse]:
                # Update cost[nextCourse] using the maximum cost of the predecessor course
                cost[nextCourse] = max(cost[nextCourse], cost[prevCourse] + time[nextCourse])
                inDegree[nextCourse] -= 1
                if inDegree[nextCourse] == 0:
                    q.append(nextCourse)
        return max(cost)
		```",MAhmadian
2053,https://leetcode.com/problems/kth-distinct-string-in-an-array/discuss/1549003/Python3-freq-table,"class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str:
        freq = Counter(arr)
        for x in arr: 
            if freq[x] == 1: k -= 1
            if k == 0: return x
        return """"",ye15
2054,https://leetcode.com/problems/two-best-non-overlapping-events/discuss/1549284/Heap-oror-very-Easy-oror-Well-Explained,"class Solution:
def maxTwoEvents(self, events: List[List[int]]) -> int:
    
    events.sort()
    heap = []
    res2,res1 = 0,0
    for s,e,p in events:
        while heap and heap[0][0]<s:
            res1 = max(res1,heapq.heappop(heap)[1])
        
        res2 = max(res2,res1+p)
        heapq.heappush(heap,(e,p))
    
    return res2",abhi9Rai
2055,https://leetcode.com/problems/plates-between-candles/discuss/1549304/100-faster-Linear-Python-solution-or-Prefix-sum-or-O(N),"class Solution:
    def platesBetweenCandles(self, s: str, qs: List[List[int]]) -> List[int]:
        n=len(s)
        prefcandle=[-1]*n #this stores the position of closest candle from current towards left
        suffcandle=[0]*n #this stores the position of closest candle from current towards right
        
        pref=[0]*n #stores the number of plates  till ith position from 0 - for i = 0 -> n 
        
        ind=-1
        c=0
        #The following method calculates number of plates(*) till ith position from 0 - for i = 0 -> n 
        for i in range(n):
            if ind!=-1 and s[i]=='*':
                c+=1
            elif s[i]=='|':
                ind=i
            pref[i]=c
              
        #this method calculates the left nearest candle to a point
        #intial is -1 as to left of leftmost element no candle can be present
        ind =-1
        for i in range(n):
            if s[i] == '|':
                ind=i
            prefcandle[i]=ind
            
        #this method calculates the right nearest candle to a point
        #intial is infinity as to right of rightmost element no candle can be present
        ind = float('inf')       
        for i in range(n-1, -1, -1):
            if s[i]=='|':
                ind=i
            suffcandle[i]=ind

        #m = no of queries
        m=len(qs)
        ans=[0]*m

        for i in range(m):
            c=0
            l=qs[i][0]
            r=qs[i][1]
            
            #check if left nearest candle of right boundary is after left boundary
            #check if right nearest candle of left boundary is before right boundary
            # to summarise - here we find if there is a pair of candle present within the given range or not
            if prefcandle[r]<l or suffcandle[l]>r:
                continue
            
            #desired answer is no of pplates(*) only inside 2 candles (|) inside the given boundary area
            ans[i]=pref[prefcandle[r]]-pref[suffcandle[l]]
        return ans",acloj97
2057,https://leetcode.com/problems/smallest-index-with-equal-value/discuss/1549993/Python3-1-line,"class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        return next((i for i, x in enumerate(nums) if i%10 == x), -1)",ye15
2058,https://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/discuss/1551353/Python-O(1)-memory-O(n)-time-beats-100.00,"class Solution:
    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:
        min_res = math.inf
        min_point = max_point = last_point = None
        prev_val = head.val
        head = head.next
        i = 1
        while head.next:
            if ((head.next.val < head.val and prev_val < head.val) or
               (head.next.val > head.val and prev_val > head.val)):
                
                if min_point is None:
                    min_point = i
                else:
                    max_point = i
                
                if last_point:
                    min_res = min(min_res, i - last_point)
                
                last_point = i
            
            prev_val = head.val
            i += 1
            head = head.next
        
        if min_res == math.inf:
            min_res = -1
        max_res = max_point - min_point if max_point else -1
        
        return [min_res, max_res]",dereky4
2059,https://leetcode.com/problems/minimum-operations-to-convert-number/discuss/1550007/Python3-bfs,"class Solution:
    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
        ans = 0
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                val = queue.popleft()
                if val == goal: return ans 
                if 0 <= val <= 1000: 
                    for x in nums: 
                        for op in (add, sub, xor): 
                            if op(val, x) not in seen: 
                                seen.add(op(val, x))
                                queue.append(op(val, x))
            ans += 1
        return -1",ye15
2060,https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/discuss/1550012/Python3-dp,"class Solution:
    def possiblyEquals(self, s1: str, s2: str) -> bool:
        
        def gg(s): 
            """"""Return possible length""""""
            ans = [int(s)]
            if len(s) == 2: 
                if s[1] != '0': ans.append(int(s[0]) + int(s[1]))
                return ans
            elif len(s) == 3: 
                if s[1] != '0': ans.append(int(s[:1]) + int(s[1:]))
                if s[2] != '0': ans.append(int(s[:2]) + int(s[2:]))
                if s[1] != '0' and s[2] != '0': ans.append(int(s[0]) + int(s[1]) + int(s[2]))
            return ans 
        
        @cache
        def fn(i, j, diff): 
            """"""Return True if s1[i:] matches s2[j:] with given differences.""""""
            if i == len(s1) and j == len(s2): return diff == 0
            if i < len(s1) and s1[i].isdigit(): 
                ii = i
                while ii < len(s1) and s1[ii].isdigit(): ii += 1
                for x in gg(s1[i:ii]): 
                    if fn(ii, j, diff-x): return True 
            elif j < len(s2) and s2[j].isdigit(): 
                jj = j 
                while jj < len(s2) and s2[jj].isdigit(): jj += 1
                for x in gg(s2[j:jj]): 
                    if fn(i, jj, diff+x): return True 
            elif diff == 0: 
                if i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False 
                return fn(i+1, j+1, 0)
            elif diff > 0: 
                if i == len(s1): return False 
                return fn(i+1, j, diff-1)
            else: 
                if j == len(s2): return False 
                return fn(i, j+1, diff+1)
            
        return fn(0, 0, 0)",ye15
2062,https://leetcode.com/problems/count-vowel-substrings-of-a-string/discuss/1563707/Python3-sliding-window-O(N),"class Solution:
    def countVowelSubstrings(self, word: str) -> int:
        ans = 0 
        freq = defaultdict(int)
        for i, x in enumerate(word): 
            if x in ""aeiou"": 
                if not i or word[i-1] not in ""aeiou"": 
                    jj = j = i # set anchor
                    freq.clear()
                freq[x] += 1
                while len(freq) == 5 and all(freq.values()): 
                    freq[word[j]] -= 1
                    j += 1
                ans += j - jj
        return ans",ye15
2063,https://leetcode.com/problems/vowels-of-all-substrings/discuss/1564075/Detailed-explanation-of-why-(len-pos)-*-(pos-%2B-1)-works,"class Solution:
    def countVowels(self, word: str) -> int:
        count = 0
        sz = len(word)
        
        for pos in range(sz):
            if word[pos] in 'aeiou':
                count += (sz - pos) * (pos + 1)
        
        return count",bitmasker
2064,https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/discuss/1563731/Python3-binary-search,"class Solution:
    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:
        lo, hi = 1, max(quantities)
        while lo < hi: 
            mid = lo + hi >> 1
            if sum(ceil(qty/mid) for qty in quantities) <= n: hi = mid 
            else: lo = mid + 1
        return lo",ye15
2068,https://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/discuss/1576339/Python3-freq-table,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        freq = [0]*26
        for x in word1: freq[ord(x)-97] += 1
        for x in word2: freq[ord(x)-97] -= 1
        return all(abs(x) <= 3 for x in freq)",ye15
2070,https://leetcode.com/problems/most-beautiful-item-for-each-query/discuss/1596922/Well-Explained-oror-99-faster-oror-Mainly-for-Beginners,"class Solution:
	def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:

		items.sort()
		dic = dict()
		res = []
		gmax = 0
		for p,b in items:
			gmax = max(b,gmax)
			dic[p] = gmax

		keys = sorted(dic.keys())
		for q in queries:
			ind = bisect.bisect_left(keys,q)
			if ind<len(keys) and keys[ind]==q:
				res.append(dic[q])
			elif ind==0:
				res.append(0)
			else:
				res.append(dic[keys[ind-1]])

		return res",abhi9Rai
2071,https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/discuss/1588356/python-binary-search-%2B-greedy-with-deque-O(nlogn),"class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:
        # workers sorted in reverse order, tasks sorted in normal order
        def can_assign(n):
            task_i = 0
            task_temp = deque()
            n_pills = pills
            for i in range(n-1,-1,-1):
                while task_i < n and tasks[task_i] <= workers[i]+strength:
                    task_temp.append(tasks[task_i])
                    task_i += 1
                
                if len(task_temp) == 0:
                    return False
                if workers[i] >= task_temp[0]:
                    task_temp.popleft()
                elif n_pills > 0:
                    task_temp.pop()
                    n_pills -= 1
                else:
                    return False
            return True
        
        tasks.sort()
        workers.sort(reverse = True)
        
        l = 0
        r = min(len(tasks), len(workers))
        res = -1
        while l <= r:
            m = (l+r)//2
            if can_assign(m):
                res = m
                l = m+1
            else:
                r = m-1
        return res",hkwu6013
2073,https://leetcode.com/problems/time-needed-to-buy-tickets/discuss/1577018/Python-or-BruteForce-and-O(N),"class Solution:
    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:
        secs = 0 
        i = 0
        while tickets[k] != 0:
            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore
                tickets[i] -= 1 # decrease the value by 1 everytime
                secs += 1 # increase secs by 1

            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator
            
        return secs",GigaMoksh
2074,https://leetcode.com/problems/reverse-nodes-in-even-length-groups/discuss/1577058/Python3-using-stack,"class Solution:
    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:
        n, node = 0, head
        while node: n, node = n+1, node.next
        
        k, node = 0, head 
        while n: 
            k += 1
            size = min(k, n)
            stack = []
            if not size &amp; 1: 
                temp = node 
                for _ in range(size): 
                    stack.append(temp.val)
                    temp = temp.next 
            for _ in range(size): 
                if stack: node.val = stack.pop()
                node = node.next 
            n -= size
        return head",ye15
2075,https://leetcode.com/problems/decode-the-slanted-ciphertext/discuss/1576914/Jump-Columns-%2B-1,"class Solution:
    def decodeCiphertext(self, encodedText: str, rows: int) -> str:
        cols, res = len(encodedText) // rows, """"
        for i in range(cols):
            for j in range(i, len(encodedText), cols + 1):
                res += encodedText[j]
        return res.rstrip()",votrubac
2076,https://leetcode.com/problems/process-restricted-friend-requests/discuss/1577153/Python-272-ms36-MB-Maintain-connected-components-of-the-graph,"class Solution:
    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        
        result = [False for _ in requests]
        
        connected_components = [{i} for i in range(n)]
        
        connected_comp_dict = {}
        for i in range(n):
            connected_comp_dict[i] = i
        
        banned_by_comps = [set() for i in range(n)]
        for res in restrictions:
            banned_by_comps[res[0]].add(res[1])
            banned_by_comps[res[1]].add(res[0])
        for i,r in enumerate(requests):
            n1, n2 = r[0], r[1]
            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]
            if c1 == c2:
                result[i] = True
            else:
                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):
                    connected_components[c1].update(connected_components[c2])
                    banned_by_comps[c1].update(banned_by_comps[c2])
                    for node in connected_components[c2]:
                        connected_comp_dict[node] = c1
                    result[i] = True
                
        return result",LonelyQuantum
2078,https://leetcode.com/problems/two-furthest-houses-with-different-colors/discuss/1589119/Python3-one-of-end-points-will-be-used,"class Solution:
    def maxDistance(self, colors: List[int]) -> int:
        ans = 0 
        for i, x in enumerate(colors): 
            if x != colors[0]: ans = max(ans, i)
            if x != colors[-1]: ans = max(ans, len(colors)-1-i)
        return ans",ye15
2079,https://leetcode.com/problems/watering-plants/discuss/1589030/Python3-simulation,"class Solution:
    def wateringPlants(self, plants: List[int], capacity: int) -> int:
        ans = 0
        can = capacity
        for i, x in enumerate(plants): 
            if can < x: 
                ans += 2*i
                can = capacity
            ans += 1
            can -= x
        return ans",ye15
2081,https://leetcode.com/problems/sum-of-k-mirror-numbers/discuss/1589048/Python3-enumerate-k-symmetric-numbers,"class Solution:
    def kMirror(self, k: int, n: int) -> int:
        
        def fn(x):
            """"""Return next k-symmetric number.""""""
            n = len(x)//2
            for i in range(n, len(x)): 
                if int(x[i])+1 < k: 
                    x[i] = x[~i] = str(int(x[i])+1)
                    for ii in range(n, i): x[ii] = x[~ii] = '0'
                    return x
            return [""1""] + [""0""]*(len(x)-1) + [""1""]
                
        x = [""0""]
        ans = 0
        for _ in range(n): 
            while True: 
                x = fn(x)
                val = int("""".join(x), k)
                if str(val)[::-1] == str(val): break
            ans += val
        return ans",ye15
2085,https://leetcode.com/problems/count-common-words-with-one-occurrence/discuss/1598944/Python3-2-line-freq-table,"class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        freq1, freq2 = Counter(words1), Counter(words2)
        return len({w for w, v in freq1.items() if v == 1} &amp; {w for w, v in freq2.items() if v == 1})",ye15
2086,https://leetcode.com/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/discuss/1598954/Python3-greedy,"class Solution:
    def minimumBuckets(self, street: str) -> int:
        street = list(street)
        ans = 0 
        for i, ch in enumerate(street): 
            if ch == 'H' and (i == 0 or street[i-1] != '#'): 
                if i+1 < len(street) and street[i+1] == '.': street[i+1] = '#'
                elif i and street[i-1] == '.': street[i-1] = '#'
                else: return -1
                ans += 1
        return ans",ye15
2087,https://leetcode.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/discuss/1598918/Greedy-Approach-oror-Well-Coded-and-Explained-oror-95-faster,"class Solution:
def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:
    src_x,src_y = startPos[0],startPos[1]
    end_x,end_y = homePos[0], homePos[1]
    
    if src_x < end_x:
        rc = sum(rowCosts[src_x+1:end_x+1])
    elif src_x > end_x:
        rc = sum(rowCosts[end_x:src_x])
    else:
        rc=0
    
    if src_y < end_y:
        cc = sum(colCosts[src_y+1:end_y+1])
    elif src_y > end_y:
        cc = sum(colCosts[end_y:src_y])
    else:
        cc=0
    
    return cc+rc",abhi9Rai
2088,https://leetcode.com/problems/count-fertile-pyramids-in-a-land/discuss/1598873/Python3-just-count,"class Solution:
    def countPyramids(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        vals = [[inf]*n for _ in range(m)]
        for i in range(m):
            for j in range(n): 
                if grid[i][j] == 0: vals[i][j] = 0
                elif j == 0: vals[i][j] = 1
                else: vals[i][j] = min(vals[i][j], 1 + vals[i][j-1])
                if grid[i][~j] == 0: vals[i][~j] = 0
                elif j == 0: vals[i][~j] = 1
                else: vals[i][~j] = min(vals[i][~j], 1 + vals[i][~j+1])
        
        def fn(vals): 
            """"""Return count of pyramid in given grid.""""""
            ans = 0 
            for j in range(n):
                width = 0
                for i in range(m): 
                    if vals[i][j]: width = min(width+1, vals[i][j])
                    else: width = 0
                    ans += max(0, width-1)
            return ans 
        
        return fn(vals) + fn(vals[::-1])",ye15
2089,https://leetcode.com/problems/find-target-indices-after-sorting-array/discuss/2024498/Python-Solution-%2B-One-Line!,"class Solution:
    def targetIndices(self, nums, target):
        ans = []
        for i,num in enumerate(sorted(nums)):
            if num == target: ans.append(i)
        return ans",domthedeveloper
2090,https://leetcode.com/problems/k-radius-subarray-averages/discuss/1599973/Python-3-or-Sliding-Window-or-Illustration-with-picture,"class Solution:
  def getAverages(self, nums: List[int], k: int) -> List[int]:
    res = [-1]*len(nums)

    left, curWindowSum, diameter = 0, 0, 2*k+1
    for right in range(len(nums)):
      curWindowSum += nums[right]
      if (right-left+1 >= diameter):
        res[left+k] = curWindowSum//diameter
        curWindowSum -= nums[left]
        left += 1
    return res",ndus
2091,https://leetcode.com/problems/removing-minimum-and-maximum-from-array/discuss/1599862/Python3-3-candidates,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        imin = nums.index(min(nums))
        imax = nums.index(max(nums))
        return min(max(imin, imax)+1, len(nums)-min(imin, imax), len(nums)+1+min(imin, imax)-max(imin, imax))",ye15
2092,https://leetcode.com/problems/find-all-people-with-secret/discuss/1599870/Python3-BFS-or-DFS-by-group,"class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        can = {0, firstPerson}
        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): 
            queue = set()
            graph = defaultdict(list)
            for x, y, _ in grp: 
                graph[x].append(y)
                graph[y].append(x)
                if x in can: queue.add(x)
                if y in can: queue.add(y)
                    
            queue = deque(queue)
            while queue: 
                x = queue.popleft()
                for y in graph[x]: 
                    if y not in can: 
                        can.add(y)
                        queue.append(y)
        return can",ye15
2094,https://leetcode.com/problems/finding-3-digit-even-numbers/discuss/1611987/Python3-brute-force,"class Solution:
    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        ans = set()
        for x, y, z in permutations(digits, 3): 
            if x != 0 and z &amp; 1 == 0: 
                ans.add(100*x + 10*y + z) 
        return sorted(ans)",ye15
2095,https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/discuss/2700533/Fastest-python-solution-TC%3A-O(N)SC%3A-O(1),"class Solution:
    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow,fast,prev=head,head,None
        while fast and fast.next:
            prev=slow
            slow=slow.next
            fast=fast.next.next
        if prev==None:
            return None
        prev.next=slow.next
        return head",shubham_1307
2096,https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/discuss/1612179/Python3-lca,"class Solution:
    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
        
        def lca(node): 
            """"""Return lowest common ancestor of start and dest nodes.""""""
            if not node or node.val in (startValue , destValue): return node 
            left, right = lca(node.left), lca(node.right)
            return node if left and right else left or right
        
        root = lca(root) # only this sub-tree matters
        
        ps = pd = """"
        stack = [(root, """")]
        while stack: 
            node, path = stack.pop()
            if node.val == startValue: ps = path 
            if node.val == destValue: pd = path
            if node.left: stack.append((node.left, path + ""L""))
            if node.right: stack.append((node.right, path + ""R""))
        return ""U""*len(ps) + pd",ye15
2097,https://leetcode.com/problems/valid-arrangement-of-pairs/discuss/1612010/Python3-Hierholzer's-algo,"class Solution:
    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(list)
        degree = defaultdict(int) # net out degree 
        for x, y in pairs: 
            graph[x].append(y)
            degree[x] += 1
            degree[y] -= 1
                
        for k in degree: 
            if degree[k] == 1: 
                x = k
                break 
                
        ans = []

        def fn(x): 
            """"""Return Eulerian path via dfs.""""""
            while graph[x]: fn(graph[x].pop()) 
            ans.append(x)
        
        fn(x)
        ans.reverse()
        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",ye15
2099,https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/discuss/1705383/Python-Simple-Solution-or-100-Time,"class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        tuple_heap = [] # Stores (value, index) as min heap
        for i, val in enumerate(nums):
            if len(tuple_heap) == k:
                heappushpop(tuple_heap, (val, i)) # To prevent size of heap growing larger than k
            else:
                heappush(tuple_heap, (val, i))
		# heap now contains only the k largest elements with their indices as well.
        tuple_heap.sort(key=lambda x: x[1]) # To get the original order of values. That is why we sort it by index(x[1]) &amp; not value(x[0])
        ans = []
        for i in tuple_heap:
            ans.append(i[0])
        return ans",anCoderr
2100,https://leetcode.com/problems/find-good-days-to-rob-the-bank/discuss/1623325/Python3-prefix-and-suffix,"class Solution:
    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:
        suffix = [0]*len(security)
        for i in range(len(security)-2, 0, -1): 
            if security[i] <= security[i+1]: suffix[i] = suffix[i+1] + 1
        
        ans = []
        prefix = 0
        for i in range(len(security)-time): 
            if i and security[i-1] >= security[i]: prefix += 1
            else: prefix = 0
            if prefix >= time and suffix[i] >= time: ans.append(i)
        return ans",ye15
2101,https://leetcode.com/problems/detonate-the-maximum-bombs/discuss/1870271/Python-Solution-that-you-want-%3A,"class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        if len(bombs)==1:
            return 1
        
        adlist={i:[] for i in range(len(bombs))}
        
        for i in range(len(bombs)):
            x1,y1,r1=bombs[i]
            for j in range(i+1,len(bombs)):
                x2,y2,r2=bombs[j]
                dist=((x2-x1)**2+(y2-y1)**2)**(1/2)
                if dist<=r1:
                    adlist[i].append(j)  
                if dist<=r2:
                    adlist[j].append(i)
        
        def dfs(adlist,seen,start):
            seen.add(start)
            for i in adlist[start]:
                if i not in seen:
                    dfs(adlist,seen,i)
        maxx=1   
        for v in adlist:
            seen=set()
            seen.add(v)
            dfs(adlist,seen,v)
            maxx=max(maxx,len(seen))
        return maxx",goxy_coder
2103,https://leetcode.com/problems/rings-and-rods/discuss/2044864/Python-simple-solution,"class Solution:
    def countPoints(self, r: str) -> int:
        ans = 0
        for i in range(10):
            i = str(i)
            if 'R'+i in r and 'G'+i in r and 'B'+i in r:
                ans += 1
        return ans",StikS32
2104,https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624416/Python3-stack,"class Solution:
    def subArrayRanges(self, nums: List[int]) -> int:
        
        def fn(op): 
            """"""Return min sum (if given gt) or max sum (if given lt).""""""
            ans = 0 
            stack = []
            for i in range(len(nums) + 1): 
                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): 
                    mid = stack.pop()
                    ii = stack[-1] if stack else -1 
                    ans += nums[mid] * (i - mid) * (mid - ii)
                stack.append(i)
            return ans 
        
        return fn(lt) - fn(gt)",ye15
2105,https://leetcode.com/problems/watering-plants-ii/discuss/1624252/Python3-2-pointers,"class Solution:
    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:
        ans = 0 
        lo, hi = 0, len(plants)-1
        canA, canB = capacityA, capacityB
        while lo < hi: 
            if canA < plants[lo]: ans += 1; canA = capacityA
            canA -= plants[lo]
            if canB < plants[hi]: ans += 1; canB = capacityB
            canB -= plants[hi]
            lo, hi = lo+1, hi-1
        if lo == hi and max(canA, canB) < plants[lo]: ans += 1
        return ans",ye15
2106,https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/discuss/1624294/Sliding-Window-or-Prefix-Suffix-Sum-or-Easy-to-understand,"class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
    
        fruitMap = defaultdict(int)
        
        for position, amount in fruits:
            fruitMap[position] = amount
        
        
        if k == 0:
            return fruitMap[startPos]
        
        totalLeft = 0 # max sum if we go k steps to the left
        totalRight = 0 # max sum if we go k steps to the right
        inBetween = 0 # max sum if we go x steps to the left &amp; k steps to the right (ensuring that we don't move more than k steps in total)
        
        dp = dict()
        
        for i in range(startPos,startPos-k-1, -1):
            totalLeft += fruitMap[i]
            dp[i] = totalLeft
            
        for i in range(startPos,startPos+k+1):
            totalRight += fruitMap[i]
            dp[i] = totalRight
            
        
        leftSteps = 1
        rightSteps = k-2
        
        while rightSteps > 0:
            currAmount = 0
            
            # go right &amp; collect
            currAmount += dp[startPos-leftSteps]
            # go left &amp; collect
            currAmount += dp[startPos+rightSteps]
            
            
            inBetween = max(inBetween, currAmount-fruitMap[startPos])
            
            leftSteps += 1
            rightSteps -= 2
        
        
        leftSteps = k-2
        rightSteps = 1
        
        while leftSteps > 0:
            currAmount = 0
            
            # go right &amp; collect
            currAmount += dp[startPos-leftSteps]
            # go left &amp; collect
            currAmount += dp[startPos+rightSteps]
            
            inBetween = max(inBetween, currAmount-fruitMap[startPos])
            
            leftSteps -= 2
            rightSteps += 1
        
            
        return max(totalLeft, totalRight, inBetween)",CaptainX
2108,https://leetcode.com/problems/find-first-palindromic-string-in-the-array/discuss/2022159/Python-Clean-and-Simple-%2B-One-Liner!,"class Solution:
    def firstPalindrome(self, words):
        for word in words:
            if word == word[::-1]: return word
        return """"",domthedeveloper
2109,https://leetcode.com/problems/adding-spaces-to-a-string/discuss/1635075/Python-Split-and-Join-to-the-rescue.-From-TLE-to-Accepted-!-Straightforward,"class Solution:
    def addSpaces(self, s: str, spaces: List[int]) -> str:
        
        arr = []
        prev = 0
        for space in spaces:
            arr.append(s[prev:space])
            prev = space
        arr.append(s[space:])
       
        return "" "".join(arr)",mostlyAditya
2110,https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/discuss/1635103/Python3-counting,"class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        ans = 0 
        for i, x in enumerate(prices): 
            if i == 0 or prices[i-1] != x + 1: cnt = 0
            cnt += 1
            ans += cnt 
        return ans",ye15
2111,https://leetcode.com/problems/minimum-operations-to-make-the-array-k-increasing/discuss/1635109/Python3-almost-LIS,"class Solution:
    def kIncreasing(self, arr: List[int], k: int) -> int:
        
        def fn(sub): 
            """"""Return ops to make sub non-decreasing.""""""
            vals = []
            for x in sub: 
                k = bisect_right(vals, x)
                if k == len(vals): vals.append(x)
                else: vals[k] = x
            return len(sub) - len(vals)
        
        return sum(fn(arr[i:len(arr):k]) for i in range(k))",ye15
2114,https://leetcode.com/problems/maximum-number-of-words-found-in-sentences/discuss/1646786/Count-Spaces,"class Solution:
    def mostWordsFound(self, ss: List[str]) -> int:
        return max(s.count("" "") for s in ss) + 1",votrubac
2115,https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/discuss/1646903/DFS,"class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        graph, can_make, supplies = {recipe : [] for recipe in recipes},  {}, set(supplies)
        def dfs(recipe : str) -> bool:
            if recipe not in can_make:
                can_make[recipe] = False
                can_make[recipe] = all([dfs(ingr) for ingr in graph[recipe]])
            return can_make[recipe]
        for i, recipe in enumerate(recipes):
            for ingr in ingredients[i]:
                if ingr not in supplies:
                    graph[recipe].append(ingr if ingr in graph else recipe)
        return [recipe for recipe in recipes if dfs(recipe)]",votrubac
2116,https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/discuss/1646594/Left-to-right-and-right-to-left,"class Solution:
    def canBeValid(self, s: str, locked: str) -> bool:
        def validate(s: str, locked: str, op: str) -> bool:
            bal, wild = 0, 0
            for i in range(len(s)):
                if locked[i] == ""1"":
                    bal += 1 if s[i] == op else -1
                else:
                    wild += 1
                if wild + bal < 0:
                    return False
            return bal <= wild
        return len(s) % 2 == 0 and validate(s, locked, '(') and validate(s[::-1], locked[::-1], ')')",votrubac
2117,https://leetcode.com/problems/abbreviating-the-product-of-a-range/discuss/1646615/Python3-quasi-brute-force,"class Solution:
    def abbreviateProduct(self, left: int, right: int) -> str:
        ans = prefix = suffix = 1
        trailing = 0 
        flag = False 
        for x in range(left, right+1): 
            if not flag: 
                ans *= x
                while ans % 10 == 0: ans //= 10 
                if ans >= 1e10: flag = True 
            prefix *= x
            suffix *= x
            while prefix >= 1e12: prefix //= 10 
            while suffix % 10 == 0: 
                trailing += 1
                suffix //= 10 
            if suffix >= 1e10: suffix %= 10_000_000_000
        while prefix >= 100000: prefix //= 10 
        suffix %= 100000
        if flag: return f""{prefix}...{suffix:>05}e{trailing}""
        return f""{ans}e{trailing}""",ye15
2119,https://leetcode.com/problems/a-number-after-a-double-reversal/discuss/1648940/Python3-1-Liner-or-O(1)-Time-and-Space-or-Short-and-Clean-Explanation,"class Solution:
    def isSameAfterReversals(self, num: int) -> bool:
        return not num or num % 10",PatrickOweijane
2120,https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/2838969/Python-Straight-forward-O(n-2)-solution-(still-fast-85),"class Solution:
    def executeInstructions(self, n: int, startPos: list[int], s: str) -> list[int]:

        def num_of_valid_instructions(s, pos, start, end):
            row, colon = pos
            k = 0
            for i in range(start, end):
                cur = s[i]
                row += (cur == 'D') - (cur == 'U')
                colon += (cur == 'R') - (cur == 'L')
                if not (0 <= row < n and 0 <= colon < n):
                    return k
                k += 1
            return k

        ans = []
        for i in range(len(s)):
            ans.append(num_of_valid_instructions(s, startPos, i, len(s)))
        return ans",Mark_computer
2121,https://leetcode.com/problems/intervals-between-identical-elements/discuss/1647480/Python3-prefix-sum,"class Solution:
    def getDistances(self, arr: List[int]) -> List[int]:
        loc = defaultdict(list)
        for i, x in enumerate(arr): loc[x].append(i)
        
        for k, idx in loc.items(): 
            prefix = list(accumulate(idx, initial=0))
            vals = []
            for i, x in enumerate(idx): 
                vals.append(prefix[-1] - prefix[i] - prefix[i+1] - (len(idx)-2*i-1)*x)
            loc[k] = deque(vals)
        
        return [loc[x].popleft() for x in arr]",ye15
2122,https://leetcode.com/problems/recover-the-original-array/discuss/1647488/Python3-brute-force,"class Solution:
    def recoverArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        cnt = Counter(nums)
        for i in range(1, len(nums)): 
            diff = nums[i] - nums[0]
            if diff and diff&amp;1 == 0: 
                ans = []
                freq = cnt.copy()
                for k, v in freq.items(): 
                    if v: 
                        if freq[k+diff] < v: break 
                        ans.extend([k+diff//2]*v)
                        freq[k+diff] -= v
                else: return ans",ye15
2124,https://leetcode.com/problems/check-if-all-as-appears-before-all-bs/discuss/1662586/Python-O(NlogN)-sort-solution-and-O(N)-linear-scan-solution,"class Solution:
    def checkString(self, s: str) -> bool:
        return ''.join(sorted(s)) == s",kryuki
2125,https://leetcode.com/problems/number-of-laser-beams-in-a-bank/discuss/2272999/PYTHON-3-99.13-LESS-MEMORY-or-94.93-FASTER-or-EXPLANATION,"class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        a, s = [x.count(""1"") for x in bank if x.count(""1"")], 0

		# ex: bank is [[00101], [01001], [00000], [11011]]
		# a would return [2, 2, 4]

        for c in range(len(a)-1):
            s += (a[c]*a[c+1])

			# basic math to find the total amount of lasers
			# for the first iteration: s += 2*2
			# for the second iteration: s += 2*4
			# returns s = 12

        return s",omkarxpatel
2126,https://leetcode.com/problems/destroying-asteroids/discuss/1775912/Simple-python-solution-or-85-lesser-memory,"class Solution:
    def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:
        asteroids = sorted(asteroids)
        for i in asteroids:
            if i <= mass:
                mass += i
            else:
                return False
        return True",Coding_Tan3
2127,https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1661041/Python3-quite-a-tedious-solution,"class Solution:
    def maximumInvitations(self, favorite: List[int]) -> int:
        n = len(favorite)
        graph = [[] for _ in range(n)]
        for i, x in enumerate(favorite): graph[x].append(i)
        
        def bfs(x, seen): 
            """"""Return longest arm of x.""""""
            ans = 0 
            queue = deque([x])
            while queue: 
                for _ in range(len(queue)): 
                    u = queue.popleft()
                    for v in graph[u]: 
                        if v not in seen: 
                            seen.add(v)
                            queue.append(v)
                ans += 1
            return ans 
        
        ans = 0 
        seen = [False]*n
        for i, x in enumerate(favorite): 
            if favorite[x] == i and not seen[i]: 
                seen[i] = seen[x] = True 
                ans += bfs(i, {i, x}) + bfs(x, {i, x})
                
        dp = [0]*n
        for i, x in enumerate(favorite): 
            if dp[i] == 0: 
                ii, val = i, 0
                memo = {}
                while ii not in memo: 
                    if dp[ii]: 
                        cycle = dp[ii]
                        break
                    memo[ii] = val
                    val += 1
                    ii = favorite[ii]
                else: cycle = val - memo[ii]
                for k in memo: dp[k] = cycle
        return max(ans, max(dp))",ye15
2129,https://leetcode.com/problems/capitalize-the-title/discuss/1716077/Python-Easy-Solution,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        title = title.split()
        word = """"
        for i in range(len(title)):
            if len(title[i]) < 3:
                word = word + title[i].lower() + "" ""
            else:
                word = word + title[i].capitalize() + "" ""
        return word[:-1]",yashitanamdeo
2130,https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/discuss/1676025/Need-to-know-O(1)-space-solution-in-Python,"class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        nums = []
        curr = head
        while curr:
            nums.append(curr.val)
            curr = curr.next
        
        N = len(nums)
        res = 0
        for i in range(N // 2):
            res = max(res, nums[i] + nums[N - i - 1])
        return res",kryuki
2131,https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/discuss/2772128/using-dictnory-in-TCN,"class Solution:
    def longestPalindrome(self, words: List[str]) -> int:
        dc=defaultdict(lambda:0)
        for a in words:
            dc[a]+=1
        count=0
        palindromswords=0
        inmiddle=0
        wds=set(words)
        for a in wds:
            if(a==a[::-1]):
                if(dc[a]%2==1):
                    inmiddle=1
                palindromswords+=(dc[a]//2)*2
            elif(dc[a[::-1]]>0):
                count+=(2*(min(dc[a],dc[a[::-1]])))
                dc[a]=0
        return (palindromswords+count+inmiddle)*2
        ``",droj
2132,https://leetcode.com/problems/stamping-the-grid/discuss/2489712/Python3-solution%3A-faster-than-most-submissions-oror-Very-simple,"class Solution:
    def prefix_sum(self, grid: List[List[int]]) -> List[List[int]]:
            ps = [[grid[row][col] for col in range(len(grid[0]))]for row in range(len(grid))]
            
            for row in range(len(grid)):
                for col in range(1, len(grid[0])):
                    ps[row][col] = ps[row][col-1] + grid[row][col]
            
            for row in range(1, len(grid)):
                for col in range(len(grid[0])):
                    ps[row][col] = ps[row-1][col] + ps[row][col]
            
            return ps
			
    def sumRegion(self, ps, row1: int, col1: int, row2: int, col2: int) -> int:
            ans = 0
            if row1 == 0 and col1 == 0:
                ans = ps[row2][col2]
            elif row1 == 0:
                ans = ps[row2][col2] - ps[row2][col1-1]
            elif col1 == 0:
                ans = ps[row2][col2] - ps[row1-1][col2]
            else:
                ans = ps[row2][col2] - ps[row1-1][col2] - ps[row2][col1-1] + ps[row1-1][col1-1]
            return ans

    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:
        diff = [[0 for col in range(len(grid[0])+1)]for row in range(len(grid)+1)]
        
        ps = self.prefix_sum(grid)
        cover = 0
        
        for row in range(len(grid)-(stampHeight-1)):
            for col in range(len(grid[0])-(stampWidth-1)):
                sub_sum = self.sumRegion(ps, row, col, row+stampHeight-1, col+stampWidth-1)
                if sub_sum == 0:
                    diff[row][col] += 1
                    diff[row][col+stampWidth] -= 1
                    diff[row+stampHeight][col] -= 1
                    diff[row+stampHeight][col+stampWidth] = 1
        pref_diff = self.prefix_sum(diff)
        m, n = len(grid), len(grid[0])
        
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == 0 and pref_diff[row][col] == 0: return False 
        
        return True",Omegang
2133,https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/discuss/1775747/Python-3-or-7-Line-solution-or-87-Faster-runtime-or-92.99-lesser-memory,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        lst = [0]*len(matrix)
        for i in matrix:
            if len(set(i)) != len(matrix):
                return False
            for j in range(len(i)):
                lst[j] += i[j]
        return len(set(lst)) == 1",Coding_Tan3
2134,https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/discuss/1677262/Sliding-window-with-comments-Python,"class Solution:
    def minSwaps(self, nums: List[int]) -> int:
        width = sum(num == 1 for num in nums) #width of the window
        nums += nums
        res = width
        curr_zeros = sum(num == 0 for num in nums[:width]) #the first window is nums[:width]
        
        for i in range(width, len(nums)):
            curr_zeros -= (nums[i - width] == 0) #remove the leftmost 0 if exists
            curr_zeros += (nums[i] == 0) #add the rightmost 0 if exists
            res = min(res, curr_zeros) #update if needed
        
        return res",kryuki
2135,https://leetcode.com/problems/count-words-obtained-after-adding-a-letter/discuss/1676852/Python3-bitmask,"class Solution:
    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:
        seen = set()
        for word in startWords: 
            m = 0
            for ch in word: m ^= 1 << ord(ch)-97
            seen.add(m)
            
        ans = 0 
        for word in targetWords: 
            m = 0 
            for ch in word: m ^= 1 << ord(ch)-97
            for ch in word: 
                if m ^ (1 << ord(ch)-97) in seen: 
                    ans += 1
                    break 
        return ans",ye15
2136,https://leetcode.com/problems/earliest-possible-day-of-full-bloom/discuss/1676837/Grow-then-plant,"class Solution:
    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:
        res = 0
        for grow, plant in sorted(zip(growTime, plantTime)):
            res = max(res, grow) + plant
        return res",votrubac
2138,https://leetcode.com/problems/divide-a-string-into-groups-of-size-k/discuss/1694807/Python-O(n)-solution,"class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        length = len(s)
        res=[]
        for i in range(0,length,k):
            if i+k>length:
                break
            res.append(s[i:i+k])
        mod =length%k 
        
        if mod!= 0:
            fill_str = fill *(k-mod)
            add_str = s[i:]+fill_str
            res.append(add_str)
            
        return res",SamyakKrSahoo
2139,https://leetcode.com/problems/minimum-moves-to-reach-target-score/discuss/1722491/Easy-Solution-python-explained-30ms,"class Solution:
   def minMoves(self, target: int, maxDoubles: int) -> int:
       moves = 0
       while maxDoubles > 0 and target > 1:
           if target % 2 == 1:
               target -= 1
           else:
               target //= 2
               maxDoubles -= 1
           moves += 1
       moves += target - 1
       return moves",Volver805
2140,https://leetcode.com/problems/solving-questions-with-brainpower/discuss/1692963/DP,"class Solution:
    def mostPoints(self, q: List[List[int]]) -> int:
        @cache
        def dfs(i: int) -> int:
            return 0 if i >= len(q) else max(dfs(i + 1), q[i][0] + dfs(i + 1 + q[i][1]))
        return dfs(0)",votrubac
2141,https://leetcode.com/problems/maximum-running-time-of-n-computers/discuss/1692965/Python3-greedy,"class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        batteries.sort()
        extra = sum(batteries[:-n])
        batteries = batteries[-n:]
        
        ans = prefix = 0 
        for i, x in enumerate(batteries): 
            prefix += x 
            if i+1 < len(batteries) and batteries[i+1]*(i+1) - prefix > extra: return (prefix + extra) // (i+1)
        return (prefix + extra) // n",ye15
2144,https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/discuss/1712364/Python-Simple-solution-or-100-faster-or-O(N-logN)-Time-or-O(1)-Space,"class Solution:
    def minimumCost(self, cost: List[int]) -> int:
        cost.sort(reverse=True)
        res, i, N = 0, 0, len(cost)
        while i < N:
            res += sum(cost[i : i + 2])
            i += 3
        return res",eshikashah
2145,https://leetcode.com/problems/count-the-hidden-sequences/discuss/1714246/Right-Left,"class Solution:
    def numberOfArrays(self, diff: List[int], lower: int, upper: int) -> int:
        diff = list(accumulate(diff, initial = 0))
        return max(0, upper - lower - (max(diff) - min(diff)) + 1)",votrubac
2146,https://leetcode.com/problems/k-highest-ranked-items-within-a-price-range/discuss/1709702/Python3-bfs,"class Solution:
    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        ans = []
        queue = deque([(0, *start)])
        grid[start[0]][start[1]] *= -1 
        while queue: 
            x, i, j = queue.popleft()
            if pricing[0] <= -grid[i][j] <= pricing[1]: ans.append((x, -grid[i][j], i, j))
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] > 0: 
                    queue.append((x+1, ii, jj))
                    grid[ii][jj] *= -1
        return [[i, j] for _, _, i, j in sorted(ans)[:k]]",ye15
2147,https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/discuss/1709706/simple-Python-solution-(time%3A-O(N)-space%3A-O(1)),"class Solution:
    def numberOfWays(self, corridor: str) -> int:
        #edge case
        num_S = corridor.count('S')
        if num_S == 0 or num_S % 2 == 1:
            return 0
        
        mod = 10 ** 9 + 7
        curr_s = 0
        divide_spots = []
        
        for char in corridor:
			curr_s += (char == 'S')
            if curr_s > 0 and curr_s % 2 == 0:
                divide_spots[-1] += 1
            else:
                if not divide_spots or divide_spots[-1] > 0:
                    divide_spots.append(0)
        
        res = 1
        for num in divide_spots[:-1]:
            res = res * num % mod
        return res",kryuki
2148,https://leetcode.com/problems/count-elements-with-strictly-smaller-and-greater-elements/discuss/2507825/Very-very-easy-code-in-just-3-lines-using-Python,"class Solution:
    def countElements(self, nums: List[int]) -> int:
        res = 0
        mn = min(nums)
        mx = max(nums)
        for i in nums:
            if i > mn and i < mx:
                res += 1
        return res",ankurbhambri
2149,https://leetcode.com/problems/rearrange-array-elements-by-sign/discuss/1711329/Two-Pointers,"class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        return [i for t in zip([p for p in nums if p > 0], [n for n in nums if n < 0]) for i in t]",votrubac
2150,https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/discuss/1711316/Counter,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        m = Counter(nums)
        return [n for n in nums if m[n] == 1 and m[n - 1] + m[n + 1] == 0]",votrubac
2151,https://leetcode.com/problems/maximum-good-people-based-on-statements/discuss/1711677/Python-3-or-Itertools-and-Bitmask-or-Explanation,"class Solution:
    def maximumGood(self, statements: List[List[int]]) -> int:
        ans, n = 0, len(statements)
        for person in itertools.product([0, 1], repeat=n): # use itertools to create a list only contains 0 or 1
            valid = True                                   # initially, we think the `person` list is valid
            for i in range(n):
                if not person[i]: continue                 # only `good` person's statement can lead to a contradiction, we don't care what `bad` person says
                for j in range(n):
                    if statements[i][j] == 2: continue     # ignore is no statement was made
                    if statements[i][j] != person[j]:      # if there is a contradiction, then valid = False
                        valid = False
                        break                              # optimization: break the loop when not valid
                if not valid:                              # optimization: break the loop when not valid
                    break        
            if valid: 
                ans = max(ans, sum(person))                # count sum only when valid == True
        return ans",idontknoooo
2154,https://leetcode.com/problems/keep-multiplying-found-values-by-two/discuss/2531609/Python-solution-simple-faster-than-80-less-memory-than-99,"class Solution:

 def findFinalValue(self, nums: List[int], original: int) -> int:

    while original in nums:
	
        original *= 2
		
    return original",Theo704
2155,https://leetcode.com/problems/all-divisions-with-the-highest-score-of-a-binary-array/discuss/1732887/Python3-scan,"class Solution:
    def maxScoreIndices(self, nums: List[int]) -> List[int]:
        ans = [0]
        cand = most = nums.count(1)
        for i, x in enumerate(nums): 
            if x == 0: cand += 1
            elif x == 1: cand -= 1
            if cand > most: ans, most = [i+1], cand
            elif cand == most: ans.append(i+1)
        return ans",ye15
2156,https://leetcode.com/problems/find-substring-with-given-hash-value/discuss/1732936/Python3-rolling-hash,"class Solution:
    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
        pp = pow(power, k-1, modulo)
        hs = ii = 0 
        for i, ch in enumerate(reversed(s)): 
            if i >= k: hs -= (ord(s[~(i-k)]) - 96)*pp
            hs = (hs * power + (ord(ch) - 96)) % modulo
            if i >= k-1 and hs == hashValue: ii = i 
        return s[~ii:~ii+k or None]",ye15
2160,https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/discuss/1747018/Python-simple-and-fast-with-explanation-no-permutation,"class Solution:
    def minimumSum(self, num: int) -> int:
        num = sorted(str(num),reverse=True)
        n = len(num)    
        res = 0
        even_iteration = False
        position = 0
        for i in range(n):
            res += int(num[i])*(10**position)
            if even_iteration:
                position += 1
                even_iteration = False
            else:
                even_iteration = True
        return res",fatamorgana
2161,https://leetcode.com/problems/partition-array-according-to-given-pivot/discuss/1748566/Python-Simple-and-Clean-Python-Solution-by-Removing-and-Appending,"class Solution:
	def pivotArray(self, nums: List[int], pivot: int) -> List[int]:

		ans=[]

		nums.remove(pivot)

		i=0
		ans.append(pivot)

		for j in nums:
			if j<pivot:
				ans.insert(i,j)
				i=i+1
			elif j==pivot:
				ans.insert(i+1,j)
			else:
				ans.append(j)

		return ans",ASHOK_KUMAR_MEGHVANSHI
2162,https://leetcode.com/problems/minimum-cost-to-set-cooking-time/discuss/1746996/Simple-Python-Solution,"class Solution:
    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:
        def count_cost(minutes, seconds): # Calculates cost for certain configuration of minutes and seconds
            time = f'{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}' # mm:ss
            time = time.lstrip('0') # since 0's are prepended we remove the 0's to the left to minimize cost
            t = [int(i) for i in time]
            current = startAt
            cost = 0
            for i in t:
                if i != current:
                    current = i
                    cost += moveCost
                cost += pushCost
            return cost
        ans = float('inf')
        for m in range(100): # Check which [mm:ss] configuration works out
            for s in range(100):
                if m * 60 + s == targetSeconds: 
                    ans = min(ans, count_cost(m, s))
        return ans",anCoderr
2163,https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/discuss/2392142/Python-solution-or-O(nlogn)-or-explained-with-diagram-or-heap-and-dp-solution,"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 3

        # calculate max_sum using min_heap for second part
        min_heap = nums[(2 * n) :]
        heapq.heapify(min_heap)

        max_sum = [0] * (n + 2)
        max_sum[n + 1] = sum(min_heap)
        for i in range((2 * n) - 1, n - 1, -1):
            # push current
            heapq.heappush(min_heap, nums[i])
            # popout minimum from heap
            val = heapq.heappop(min_heap)
            # max_sum for this partition
            max_sum[i - n + 1] = max_sum[i - n + 2] - val + nums[i]


        # calculate min_sum using max_heap for first part
        max_heap = [-x for x in nums[:n]]
        heapq.heapify(max_heap)

        min_sum = [0] * (n + 2)
        min_sum[0] = -sum(max_heap)
        for i in range(n, (2 * n)):
            # push current
            heapq.heappush(max_heap, -nums[i])
            # popout maximum from heap
            val = -heapq.heappop(max_heap)
            # min_sum for this partition
            min_sum[i - n + 1] = min_sum[i - n] - val + nums[i]


        # find min difference bw second part (max_sum) and first part (min_sum)
        ans = math.inf
        for i in range(0, n + 1):
            print(i, min_sum[i], max_sum[i])
            ans = min((min_sum[i] - max_sum[i + 1]), ans)

        return ans",wilspi
2164,https://leetcode.com/problems/sort-even-and-odd-indices-independently/discuss/2214566/Python-oror-In-Place-Sorting,"class Solution:
	def sortEvenOdd(self, nums: List[int]) -> List[int]:
		n = len(nums)
		for i in range(0,n,2):
			for j in range(i+2,n,2):
				if nums[i] > nums[j]:
					nums[i],nums[j] = nums[j], nums[i]

		for i in range(1,n,2):
			for j in range(i+2,n,2):
				if nums[i] < nums[j]:
					nums[i],nums[j] = nums[j], nums[i]
		return nums",morpheusdurden
2165,https://leetcode.com/problems/smallest-value-of-the-rearranged-number/discuss/1755847/PYTHON3-or-EASY-SOLUTION-or,"class Solution:
    def smallestNumber(self, num: int) -> int:
        
        if num == 0 : return 0 
        snum = sorted(str(num))
        if snum[0] == '-' :
            return -int("""".join(snum[:0:-1]))
        elif snum[0] == '0' :
            x = snum.count('0')
            return """".join([snum[x]]+['0'*x]+snum[x+1:])
        else :
            return """".join(snum)",rohitkhairnar
2167,https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/2465604/Python3-dp,"class Solution:
    def minimumTime(self, s: str) -> int:
        ans = inf 
        prefix = 0 
        for i, ch in enumerate(s): 
            if ch == '1': prefix = min(2 + prefix, i+1)
            ans = min(ans, prefix + len(s)-1-i)
        return ans",ye15
2169,https://leetcode.com/problems/count-operations-to-obtain-zero/discuss/1766882/Python3-simulation,"class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        ans = 0 
        while num1 and num2: 
            ans += num1//num2
            num1, num2 = num2, num1%num2
        return ans",ye15
2170,https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/discuss/1766909/Python3-4-line,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        pad = lambda x: x + [(None, 0)]*(2-len(x))
        even = pad(Counter(nums[::2]).most_common(2))
        odd = pad(Counter(nums[1::2]).most_common(2))
        return len(nums) - (max(even[0][1] + odd[1][1], even[1][1] + odd[0][1]) if even[0][0] == odd[0][0] else even[0][1] + odd[0][1])",ye15
2171,https://leetcode.com/problems/removing-minimum-number-of-magic-beans/discuss/1766873/Python3-2-line,"class Solution:
    def minimumRemoval(self, beans: List[int]) -> int:
        beans.sort()
        return sum(beans) - max((len(beans)-i)*x for i, x in enumerate(beans))",ye15
2172,https://leetcode.com/problems/maximum-and-sum-of-array/discuss/1766984/Python3-dp-(top-down),"class Solution:
    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
        
        @cache
        def fn(k, m): 
            """"""Return max AND sum.""""""
            if k == len(nums): return 0 
            ans = 0 
            for i in range(numSlots): 
                if m &amp; 1<<2*i == 0 or m &amp; 1<<2*i+1 == 0: 
                    if m &amp; 1<<2*i == 0: mm = m ^ 1<<2*i
                    else: mm = m ^ 1<<2*i+1
                    ans = max(ans, (nums[k] &amp; i+1) + fn(k+1, mm))
            return ans 
        
        return fn(0, 0)",ye15
2176,https://leetcode.com/problems/count-equal-and-divisible-pairs-in-an-array/discuss/1783447/Python3-Solution-fastest,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        n=len(nums)
        c=0
        for i in range(0,n):
            for j in range(i+1,n):
                if nums[i]==nums[j] and ((i*j)%k==0):
                    c+=1
        return c",Anilchouhan181
2177,https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/discuss/1783425/Python3-1-line,"class Solution:
    def sumOfThree(self, num: int) -> List[int]:
        return [] if num % 3 else [num//3-1, num//3, num//3+1]",ye15
2178,https://leetcode.com/problems/maximum-split-of-positive-even-integers/discuss/1783966/Simple-Python-Solution-with-Explanation-oror-O(sqrt(n))-Time-Complexity-oror-O(1)-Space-Complexity,"class Solution:
    def maximumEvenSplit(self, finalSum: int) -> List[int]:
        l=set()
        if finalSum%2!=0:
            return l
        else:
            s=0
            i=2                       # even pointer 2, 4, 6, 8, 10, 12...........
            while(s<finalSum):
                s+=i                #sum 
                l.add(i)      # append the i in list
                i+=2
            if s==finalSum:  #if sum s is equal to finalSum then no modidfication required
                return l
            else:
                l.discard(s-finalSum)  #Deleting the element which makes s greater than finalSum
				return l",HimanshuGupta_p1
2179,https://leetcode.com/problems/count-good-triplets-in-an-array/discuss/1783361/Python-3-SortedList-solution-O(NlogN),"class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        hashmap2 = {}
        for i in range(n):
            hashmap2[nums2[i]] = i
        indices = []
        for num in nums1:
            indices.append(hashmap2[num])
        from sortedcontainers import SortedList
        left, right = SortedList(), SortedList()
        leftCount, rightCount = [], []
        for i in range(n):
            leftCount.append(left.bisect_left(indices[i]))
            left.add(indices[i])
        for i in range(n - 1, -1, -1):
            rightCount.append(len(right) - right.bisect_right(indices[i]))
            right.add(indices[i])
        count = 0
        for i in range(n):
            count += leftCount[i] * rightCount[n - 1 - i]
        return count",xil899
2180,https://leetcode.com/problems/count-integers-with-even-digit-sum/discuss/1785049/lessPython3greater-O(1)-Discrete-Formula-100-faster-1-LINE,"class Solution:
    def countEven(self, num: int) -> int:
        return num // 2 if sum([int(k) for k in str(num)]) % 2 == 0 else (num - 1) // 2",drknzz
2181,https://leetcode.com/problems/merge-nodes-in-between-zeros/discuss/1784873/Python-3-or-Dummy-Node-O(N)-Time-Solution,"class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        d=ListNode(0)
        t=0
        r=ListNode(0,d)
        while head:
            if head.val!=0:
                t+=head.val
            else:
                print(t)
                if t!=0:
                    d.next=ListNode(t)
                    d=d.next
                    t=0
            head=head.next
        return r.next.next",MrShobhit
2182,https://leetcode.com/problems/construct-string-with-repeat-limit/discuss/1784789/Python3-priority-queue,"class Solution:
    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:
        pq = [(-ord(k), v) for k, v in Counter(s).items()] 
        heapify(pq)
        ans = []
        while pq: 
            k, v = heappop(pq)
            if ans and ans[-1] == k: 
                if not pq: break 
                kk, vv = heappop(pq)
                ans.append(kk)
                if vv-1: heappush(pq, (kk, vv-1))
                heappush(pq, (k, v))
            else: 
                m = min(v, repeatLimit)
                ans.extend([k]*m)
                if v-m: heappush(pq, (k, v-m))
        return """".join(chr(-x) for x in ans)",ye15
2183,https://leetcode.com/problems/count-array-pairs-divisible-by-k/discuss/1784801/Python3-factors,"class Solution:
    def coutPairs(self, nums: List[int], k: int) -> int:
        factors = []
        for x in range(1, int(sqrt(k))+1):
            if k % x == 0: factors.append(x)
        ans = 0 
        freq = Counter()
        for x in nums: 
            x = gcd(x, k)
            ans += freq[k//x]
            for f in factors: 
                if x % f == 0 and f <= x//f: 
                    freq[f] += 1
                    if f < x//f: freq[x//f] += 1
        return ans",ye15
2185,https://leetcode.com/problems/counting-words-with-a-given-prefix/discuss/1803163/Python-1-Liner-Solution,"class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        return sum(word.find(pref) == 0 for word in words)",anCoderr
2186,https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/discuss/1802652/Python3-freq-table,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        fs, ft = Counter(s), Counter(t)
        return sum((fs-ft).values()) + sum((ft-fs).values())",ye15
2187,https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/1802433/Python-Solution-oror-Detailed-Article-on-Binary-Search-on-Answer,"class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        r = min(time) * totalTrips + 1 # This is the worst case answer possible for any case. Could use big values like 10^15 as well but they might slow the time down for smaller cases.
        l = 0
        ans = 0

        def check_status(expected_time: int) -> int:
            nonlocal ans
            count = 0
            for i in time:
                count += expected_time // i # Total trips with time expected_time should be integer part of expected_time // i
            if count < totalTrips:
                return 1 # Since number of trips are less then required, left moves to mid
            elif count >= totalTrips:
                ans = expected_time # stores the latest result. This is guaranteed to be the minimum possible answer.
                return -1 # Since number of trips are greater/equal to required, right moves to mid

        while l < r-1: # Till Binary Search can continue. 
            mid = (l + r) // 2 # mid is the current expected time.
            status = check_status(mid) # The return values 1/-1 in check_status function determines which pointer to move.
            if status == 1:
                l = mid
            else:
                r = mid
                
        return ans",anCoderr
2188,https://leetcode.com/problems/minimum-time-to-finish-the-race/discuss/1803014/Python-DP-with-pre-treatment-to-reduce-time-complexity,"class Solution:
    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
        tires.sort()
        newTires = []
        minTime = [changeTime*(i-1) + tires[0][0]*i for i in range(numLaps+1)]
        minTime[0] = 0
        maxi = 0
        for f,r in tires:
            if not newTires or f>newTires[-1][0] and r<newTires[-1][1]:
                newTires.append([f,r])
                t = f
                i = 1
                while i<numLaps and t*(r-1)<changeTime:
                    t = t*r + f
                    i += 1
                    if minTime[i]>t:
                        minTime[i]=t
                        maxi = max(i,maxi)
        for lap in range(numLaps+1):
            for run in range(min(lap,maxi+1)):
                minTime[lap] = min(minTime[lap],minTime[lap-run]+changeTime+minTime[run])
        return minTime[numLaps]",wssx349
2190,https://leetcode.com/problems/most-frequent-number-following-key-in-an-array/discuss/1924231/Python-Multiple-Solutions-%2B-One-Liners-or-Clean-and-Simple,"class Solution:
    def mostFrequent(self, nums, key):
        counts = {}
        
        for i in range(1,len(nums)):
            if nums[i-1]==key:
                if nums[i] not in counts: counts[nums[i]] = 1
                else: counts[nums[i]] += 1
        
        return max(counts, key=counts.get)",domthedeveloper
2191,https://leetcode.com/problems/sort-the-jumbled-numbers/discuss/1822244/Sorted-Lambda,"class Solution:
    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
        @cache
        def convert(i: int):
            res, pow10 = 0, 1
            while i:
                res += pow10 * mapping[i % 10]
                i //= 10
                pow10 *= 10
            return res
        return sorted(nums, key=lambda i: mapping[i] if i < 10 else convert(i))",votrubac
2192,https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/discuss/2333862/Python3-or-Solved-using-Topo-Sort(Kahn-Algo)-with-Queue(BFS),"class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        #Use Kahn's algorithm of toposort using a queue and bfs!
        graph = [[] for _ in range(n)]
        indegrees = [0] * n
        
        #Time: O(n^2)
        #Space: O(n^2 + n + n) -> O(n^2)
        
        #1st step: build adjacency list grpah and update the initial indegrees of every node!
        for edge in edges:
            src, dest = edge[0], edge[1]
            graph[src].append(dest)
            indegrees[dest] += 1
        
        
        queue = deque()
        ans = [set() for _ in range(n)]
        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!
        for i in range(len(indegrees)):
            if(indegrees[i] == 0):
                queue.append(i)
        
        #Kahn's algorithm initiation!
        #while loop will run for each and every node in graph!
        #in worst case, adjacency list for one particular node may contain all other vertices!
        while queue:
            cur = queue.pop()
            
            #for each neighbor
            for neighbor in graph[cur]:
                #current node is ancestor to each and every neighboring node!
                ans[neighbor].add(cur)
                #every ancestor of current node is also an ancestor to the neighboring node!
                ans[neighbor].update(ans[cur])
                indegrees[neighbor] -= 1
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        
        #at the end, we should have set of ancestors for each and every node!
        #in worst case, set s for ith node could have all other vertices be ancestor to node i !
        ans = [(sorted(list(s))) for s in ans]
        return ans",JOON1234
2193,https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/discuss/2152484/Python3-peel-the-string,"class Solution:
    def minMovesToMakePalindrome(self, s: str) -> int:
        ans = 0 
        while len(s) > 2: 
            lo = s.find(s[-1])
            hi = s.rfind(s[0])
            if lo < len(s)-hi-1: 
                ans += lo 
                s = s[:lo] + s[lo+1:-1]
            else: 
                ans += len(s)-hi-1
                s = s[1:hi] + s[hi+1:]
        return ans",ye15
2194,https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/discuss/1823607/Python3-1-line,"class Solution:
    def cellsInRange(self, s: str) -> List[str]:
        return [chr(c)+str(r) for c in range(ord(s[0]), ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]",ye15
2195,https://leetcode.com/problems/append-k-integers-with-minimal-sum/discuss/1823628/Python3-swap,"class Solution:
    def minimalKSum(self, nums: List[int], k: int) -> int:
        ans = k*(k+1)//2
        prev = -inf 
        for x in sorted(nums): 
            if prev < x: 
                if x <= k: 
                    k += 1
                    ans += k - x
                else: break
                prev = x
        return ans",ye15
2196,https://leetcode.com/problems/create-binary-tree-from-descriptions/discuss/1823644/Python3-simulation,"class Solution:
    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:
        mp = {}
        seen = set()
        for p, c, left in descriptions: 
            if p not in mp: mp[p] = TreeNode(p)
            if c not in mp: mp[c] = TreeNode(c)
            if left: mp[p].left = mp[c]
            else: mp[p].right = mp[c]
            seen.add(c)
        for p, _, _ in descriptions: 
            if p not in seen: return mp[p]",ye15
2197,https://leetcode.com/problems/replace-non-coprime-numbers-in-array/discuss/1825538/Python-3-Stack-solution,"class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:       

        stack = nums[:1]
        
        for j in range(1, len(nums)):
            cur = nums[j]
            while stack and math.gcd(stack[-1], cur) > 1:
                prev = stack.pop()
                cur = math.lcm(prev, cur)
            stack.append(cur)            
               
        return stack",chestnut890123
2200,https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/discuss/2171271/Python-easy-to-understand-oror-Beginner-friendly,"class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        ind_j = []
        for ind, elem in enumerate(nums):
            if elem == key:
                ind_j.append(ind)
        res = []
        for i in range(len(nums)):
            for j in ind_j:
                if abs(i - j) <= k:
                    res.append(i)
                    break
        return sorted(res)",Shivam_Raj_Sharma
2201,https://leetcode.com/problems/count-artifacts-that-can-be-extracted/discuss/1844361/Python-elegant-short-and-simple-to-understand-with-explanations,"class Solution:
    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:
	    # Time: O(max(artifacts, dig)) which is O(N^2) as every position in the grid can be in dig
		# Space: O(dig) which is O(N^2)
        result, dig_pos = 0, set(tuple(pos) for pos in dig)
        for pos in artifacts:
            if all((x, y) in dig_pos for x in range(pos[0], pos[2] + 1) for y in range(pos[1], pos[3] + 1)):     
                result += 1
        return result",yangshun
2202,https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/discuss/1844186/Python-3-Find-Maximum-of-first-k-1-elements-or-(k%2B1)th-element-or-Beats-100,"class Solution:
    def maximumTop(self, nums: List[int], k: int) -> int:
        if len(nums) == 1:
            if k%2 != 0:
                return -1
            return nums[0]
        
        if k == 0:
            return nums[0]
        if k == len(nums):
            return max(nums[:-1])
        if k > len(nums):
            return max(nums)
        if k == 1:
            return nums[1]
        m = max(nums[:k-1])
        m = max(m, nums[k])
        return m",hari19041
2203,https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/discuss/1867689/Three-min-costs-to-every-node-97-speed,"class Solution:
    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:
        forward, backward = dict(), dict()
        for start, end, weight in edges:
            if start in forward:
                if end in forward[start]:
                    forward[start][end] = min(weight, forward[start][end])
                else:
                    forward[start][end] = weight
            else:
                forward[start] = {end: weight}
            if end in backward:
                if start in backward[end]:
                    backward[end][start] = min(weight, backward[end][start])
                else:
                    backward[end][start] = weight
            else:
                backward[end] = {start: weight}

        def travel(origin: int, relations: dict, costs: list) -> None:
            level = {origin}
            costs[origin] = 0
            while level:
                new_level = set()
                for node in level:
                    if node in relations:
                        for next_node, w in relations[node].items():
                            if w + costs[node] < costs[next_node]:
                                new_level.add(next_node)
                                costs[next_node] = w + costs[node]
                level = new_level

        from_src1 = [inf] * n
        from_src2 = [inf] * n
        from_dest = [inf] * n

        travel(src1, forward, from_src1)
        travel(src2, forward, from_src2)
        travel(dest, backward, from_dest)

        combined_cost = min(sum(tpl)
                            for tpl in zip(from_src1, from_src2, from_dest))

        return combined_cost if combined_cost < inf else -1",EvgenySH
2206,https://leetcode.com/problems/divide-array-into-equal-pairs/discuss/1864079/Python-Solution-Using-Counter-oror-Beats-99-oror-O(n),"class Solution:

    def divideArray(self, nums: List[int]) -> bool:
        lena = len(nums)
        count = sum(num//2 for num in Counter(nums).values())
        return (lena/2 == count)",IvanTsukei
2207,https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/discuss/2501496/Python-Easy-Solution,"class Solution:
    def maximumSubsequenceCount(self, string: str, pattern: str) -> int:

        text = pattern[0]+string
        text1 = string + pattern[1]
        cnt,cnt1 = 0,0
        ans,ans1 = 0,0
        
        for i in range(len(text)):
            if text[i] == pattern[0]:
                cnt+=1
            elif text[i] == pattern[1]:
                ans+= cnt
        if pattern[0] == pattern[1]:
            ans = ((cnt)*(cnt-1))//2
        # appending at the last 
        for i in range(len(text1)):
            if text1[i] == pattern[0]:
                cnt1+=1
            elif text1[i] == pattern[1]:
                ans1+= cnt1
        if pattern[0] == pattern[1]:
            ans1 = ((cnt1)*(cnt1-1))//2
        return max(ans1,ans)",Abhi_009
2208,https://leetcode.com/problems/minimum-operations-to-halve-array-sum/discuss/1984994/python-3-oror-priority-queue,"class Solution:
    def halveArray(self, nums: List[int]) -> int:
        s = sum(nums)
        goal = s / 2
        res = 0
        
        for i, num in enumerate(nums):
            nums[i] = -num
        heapq.heapify(nums)
        
        while s > goal:
            halfLargest = -heapq.heappop(nums) / 2
            s -= halfLargest
            heapq.heappush(nums, -halfLargest)
            res += 1
        
        return res",dereky4
2209,https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/discuss/1874969/Python3-dp,"class Solution:
    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:
        
        @cache
        def fn(i, n):
            """"""Return min while tiles at k with n carpets left.""""""
            if n < 0: return inf 
            if i >= len(floor): return 0 
            if floor[i] == '1': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))
            return fn(i+1, n)
        
        return fn(0, numCarpets)",ye15
2210,https://leetcode.com/problems/count-hills-and-valleys-in-an-array/discuss/1866869/Python3-One-pass-oror-O(1)-space,"class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        
        #cnt: An integer to store total hills and valleys
        #left: Highest point of hill or lowest point of valley left of the current index
        cnt, left = 0, nums[0]
        
        for i in range(1, len(nums)-1):
            if (left<nums[i] and nums[i]>nums[i+1]) or (left>nums[i] and nums[i]<nums[i+1]):
                cnt+=1
                left=nums[i]
        return cnt",__PiYush__
2211,https://leetcode.com/problems/count-collisions-on-a-road/discuss/1865694/One-liner-in-Python,"class Solution:
    def countCollisions(self, directions: str) -> int:
        return sum(d!='S' for d in directions.lstrip('L').rstrip('R'))",LuckyBoy88
2212,https://leetcode.com/problems/maximum-points-in-an-archery-competition/discuss/1866042/Python3-DP-100-with-Detailed-Explanation,"class Solution:
    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:
        
        # Initialization with round 1 (round 0 is skipped)
        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}
        
        # Loop from round 2
        for i in range(2, 12):
            prev = dp
            dp = {}
            
            # Consider two possible strategies for each state from last round: to bid and not to bid
            for key in prev:
                
                # Base case: not to bid in this round. Score and arrows left do not change.
                # Simply append 0 at the end to the key.
                newkey1 = list(key)
                newkey1.append(0)
                score, arrowleft = prev[key]
                
                newval1 = (score, arrowleft)
                dp[tuple(newkey1)] = newval1
                
                # If we still have enough arrows, we can bid in this round
                if arrowleft >= aliceArrows[i] + 1:
                    newkey2 = list(key)
                    newkey2.append(aliceArrows[i] + 1)
                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))
                    dp[tuple(newkey2)] = newval2
        
        # Select the bidding history with max score
        maxscore, res = 0, None
        for key in dp:
            score, _ = dp[key]
            if score > maxscore:
                maxscore = score
                res = list(key)
        
        # Taking care of the corner case, where too many arrows are given
        if sum(res) < numArrows:
            res[0] = numArrows - sum(res)
        
        return res",hsjiang
2215,https://leetcode.com/problems/find-the-difference-of-two-arrays/discuss/2668224/Python-solution.-Clean-code-with-full-comments.-95.96-speed.,"class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        
        set_1 = list_to_set(nums1)
        set_2 = list_to_set(nums2)
        
        return remove_same_elements(set_1, set_2)
                
# Convert the lists into sets via helper method.      
def list_to_set(arr: List[int]):
    
    s = set()
    
    for i in arr:
        s.add(i)
        
    return s   

# Now when the two lists are sets, use the difference attribute to filter common elements of the two sets.
def remove_same_elements(x, y):
    
    x, y = list(x - y), list(y - x)
        
    return [x, y]


# Runtime: 185 ms, faster than 95.96% of Python3 online submissions for Find the Difference of Two Arrays.
# Memory Usage: 14.3 MB, less than 51.66% of Python3 online submissions for Find the Difference of Two Arrays.

# If you like my work, then I'll appreciate a like. Thanks!",375d
2216,https://leetcode.com/problems/minimum-deletions-to-make-array-beautiful/discuss/1886918/Python-or-Greedy,"class Solution:
    def minDeletion(self, nums: List[int]) -> int:
        # Greedy !
        # we first only consider requirement 2: nums[i] != nums[i + 1] for all i % 2 == 0
        # at the begining, we consider the num on the even index
        # when we delete a num, we need consider the num on the odd index
        # then repeat this process
        # at the end we check the requirement 1: nums.length is even or not
        
        n = len(nums)
        count = 0
        # flag is true then check the even index
        # flag is false then check the odd index
        flag = True
        
        for i in range(n):
            # check the even index
            if flag:
                if i % 2 == 0 and i != n -1 and nums[i] == nums[i + 1]:
                    count += 1
                    flag = False
            # check the odd index
            elif not flag:
                if i % 2 == 1 and i != n -1 and nums[i] == nums[i + 1]:
                    count += 1
                    flag = True
        
        curLength = n - count
        
        return count if curLength % 2 == 0 else count + 1",Mikey98
2217,https://leetcode.com/problems/find-palindrome-with-fixed-length/discuss/1886956/Python-or-simple-and-straightforward,"class Solution:
    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:
        # think the palindromes in half
        # e.g. len  = 4 we only consider the first 2 digits
        # half: 10, 11, 12, 13, 14, ..., 19, 20, 
        # full: 1001, 1111, 1221, 1331, ...
        # e.g. len = 5 we consider the first 3 digits
        # half: 100, 101, 102, ...
        # full: 10001, 10101, 10201, ...
        
        result = []
        
        for i in queries:
            result.append(self.generatePalindrome(intLength, i))
        
        return result
    
    def generatePalindrome(self, length, num):
        # index start from 0
		# e.g. num =1 means we want to find the most smallest palindrome, then its index is 0
		# e.g. num =2 means we want to find the second most smallest palindrome, then its index is 1
        index = num -1
        
		# if the length is even
		# we only think about the fisrt half of digits
        if length % 2 == 0:
            cur = int('1' + '0' * (length // 2 -1))
            maxLength = len(str(cur))
            cur += index
            
            if len(str(cur)) > maxLength:
                return -1
            
            else:
                cur = str(cur)
                cur = cur + cur[::-1]
                cur = int(cur)
                return cur
				
        # if the length is odd
		# we consider first (length // 2 + 1) digits
        else:
            cur = int('1' + '0' * (length // 2))
            maxLength = len(str(cur))
            cur += index
            
            if len(str(cur)) > maxLength:
                return -1
            
            else:
                cur = str(cur)
                temp = str(cur)[:-1]
                cur = cur + temp[::-1]
                cur = int(cur)
                return cur",Mikey98
2218,https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/discuss/1889647/Python-Bottom-up-DP-solution,"class Solution:
    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:
        n, m = len(piles), 0
        prefixSum = []
        for i in range(n):
            temp = [0]
            for j in range(len(piles[i])):
                temp.append(temp[-1] + piles[i][j])
                m += 1
            prefixSum.append(temp)
        if m == k:
            return sum(temp[-1] for temp in prefixSum)
            
        dp = [[0] * (k + 1) for _ in range(n)]
        for j in range(1, k + 1):
            if j < len(prefixSum[0]):
                dp[0][j] = prefixSum[0][j]
        
        for i in range(1, n):
            for j in range(1, k + 1):
                for l in range(len(prefixSum[i])):
                    if l > j:
                        break
                    dp[i][j] = max(dp[i][j], prefixSum[i][l] + dp[i - 1][j - l])
        return dp[n - 1][k]",xil899
2220,https://leetcode.com/problems/minimum-bit-flips-to-convert-number/discuss/2775126/Python-Solution-without-XOR,"class Solution:
    def minBitFlips(self, s: int, g: int) -> int:
        count = 0
        while s or g:
            if s%2 != g%2: count+=1
            s, g = s//2, g//2
        return count",keioon
2221,https://leetcode.com/problems/find-triangular-sum-of-an-array/discuss/1909302/Pascal-Triangle,"class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        return sum(n * comb(len(nums) - 1, i) for i, n in enumerate(nums)) % 10",votrubac
2222,https://leetcode.com/problems/number-of-ways-to-select-buildings/discuss/1979756/python-3-oror-short-and-simple-oror-O(n)O(1),"class Solution:
    def numberOfWays(self, s: str) -> int:
        zeros = s.count('0')
        ones = len(s) - zeros
        zeroPrefix = onePrefix = res = 0
        for c in s:
            if c == '0':
                res += onePrefix * (ones - onePrefix)
                zeroPrefix += 1
            else:
                res += zeroPrefix * (zeros - zeroPrefix)
                onePrefix += 1
        
        return res",dereky4
2223,https://leetcode.com/problems/sum-of-scores-of-built-strings/discuss/2256814/Python3-rolling-hash-and-z-algorithm,"class Solution:
    def sumScores(self, s: str) -> int:
        mod = 119_218_851_371
        hs = 0 
        vals = [0]
        for i, ch in enumerate(s): 
            hs = (hs * 26 + ord(ch) - 97) % mod
            vals.append(hs)
        
        p26 = [1]
        for _ in range(len(s)): p26.append(p26[-1] * 26 % mod)
        
        ans = 0 
        for i in range(len(s)): 
            if s[0] == s[i]: 
                lo, hi = i, len(s)
                while lo < hi: 
                    mid = lo + hi + 1 >> 1
                    hs = (vals[mid] - vals[i]*p26[mid-i]) % mod
                    if hs == vals[mid-i]: lo = mid
                    else: hi = mid - 1
                ans += lo - i 
        return ans",ye15
2224,https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/discuss/1908786/Easy-Python-Solution-or-Convert-time-to-minutes,"class Solution:
    def convertTime(self, current: str, correct: str) -> int:
        current_time = 60 * int(current[0:2]) + int(current[3:5]) # Current time in minutes
        target_time = 60 * int(correct[0:2]) + int(correct[3:5]) # Target time in minutes
        diff = target_time - current_time # Difference b/w current and target times in minutes
        count = 0 # Required number of operations
		# Use GREEDY APPROACH to calculate number of operations
        for i in [60, 15, 5, 1]:
            count += diff // i # add number of operations needed with i to count
            diff %= i # Diff becomes modulo of diff with i
        return count",anCoderr
2225,https://leetcode.com/problems/find-players-with-zero-or-one-losses/discuss/1908760/Python-Solution-with-Hashmap,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        winners, losers, table = [], [], {}
        for winner, loser in matches:
            # map[key] = map.get(key, 0) + change . This format ensures that KEY NOT FOUND error is always prevented.
            # map.get(key, 0) returns map[key] if key exists and 0 if it does not.
            table[winner] = table.get(winner, 0)  # Winner
            table[loser] = table.get(loser, 0) + 1
        for k, v in table.items(): # Player k with losses v
            if v == 0:
                winners.append(k) # If player k has no loss ie v == 0
            if v == 1:
                losers.append(k) # If player k has one loss ie v == 1
        return [sorted(winners), sorted(losers)] # Problem asked to return sorted arrays.",anCoderr
2226,https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1912213/Easy-To-Understand-Python-Solution-(Binary-Search),"class Solution:
    def maximumCandies(self, candies, k):
        n = len(candies)
        left = 1  # the least number of candy in each stack we can give to each student is one
        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array
        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. 
               # If we don't have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.

        while left <= right:  # binary search
            numberOfPiles = 0
            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack

            for i in range(n):   # loop through the array to find the numbers of stack we can form
                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)

            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute
                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student 
                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student
            else: 
                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student
        return ans",danielkua
2231,https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/discuss/1931017/Python-Solution-using-Sorting,"class Solution:
    def largestInteger(self, num: int):
        n = len(str(num))
        arr = [int(i) for i in str(num)]
        odd, even = [], []
        for i in arr:
            if i % 2 == 0:
                even.append(i)
            else:
                odd.append(i)
        odd.sort()
        even.sort()
        res = 0
        for i in range(n):
            if arr[i] % 2 == 0:
                res = res*10 + even.pop()
            else:
                res = res*10 + odd.pop()
        return res",anCoderr
2232,https://leetcode.com/problems/minimize-result-by-adding-parentheses-to-expression/discuss/1931004/Python-Solution-using-2-Pointers-Brute-Force,"class Solution:
    def minimizeResult(self, expression: str) -> str:
        plus_index, n, ans = expression.find('+'), len(expression), [float(inf),expression] 
        def evaluate(exps: str):
            return eval(exps.replace('(','*(').replace(')', ')*').lstrip('*').rstrip('*'))
        for l in range(plus_index):
            for r in range(plus_index+1, n):
                exps = f'{expression[:l]}({expression[l:plus_index]}+{expression[plus_index+1:r+1]}){expression[r+1:n]}'
                res = evaluate(exps)
                if ans[0] > res:
                    ans[0], ans[1] = res, exps
        return ans[1]",anCoderr
2233,https://leetcode.com/problems/maximum-product-after-k-increments/discuss/1930986/Python-Solution-using-Min-Heap,"class Solution:
    def maximumProduct(self, nums: List[int], k: int) -> int:
        heap = nums.copy()
        heapify(heap)
        for i in range(k):
            t = heappop(heap)
            heappush(heap, t + 1)
        ans = 1
        mod = 1000000007
        for i in heap:
            ans = (ans*i) % mod
        return ans",anCoderr
2234,https://leetcode.com/problems/maximum-total-beauty-of-the-gardens/discuss/2313576/Python3-2-pointer,"class Solution:
    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        flowers = sorted(min(target, x) for x in flowers)
        prefix = [0]
        ii = -1 
        for i in range(len(flowers)): 
            if flowers[i] < target: ii = i 
            if i: prefix.append(prefix[-1] + (flowers[i]-flowers[i-1])*i)
        ans = 0 
        for k in range(len(flowers)+1): 
            if k: newFlowers -= target - flowers[-k]
            if newFlowers >= 0: 
                while 0 <= ii and (ii+k >= len(flowers) or prefix[ii] > newFlowers): ii -= 1
                if 0 <= ii: kk = min(target-1, flowers[ii] + (newFlowers - prefix[ii])//(ii+1))
                else: kk = 0 
                ans = max(ans, k*full + kk*partial)
        return ans",ye15
2235,https://leetcode.com/problems/add-two-integers/discuss/2670517/Solutions-in-Every-Language-*on-leetcode*-or-One-Liner,"class Solution:
    def sum(self, num1: int, num2: int) -> int:
        return num1 + num2",qing306037
2236,https://leetcode.com/problems/root-equals-sum-of-children/discuss/2178260/Python-oneliner,"class Solution:
    def checkTree(self, root: Optional[TreeNode]) -> bool:
        return root.left.val+root.right.val == root.val",StikS32
2239,https://leetcode.com/problems/find-closest-number-to-zero/discuss/1959624/Python-dollarolution,"class Solution:
    def findClosestNumber(self, nums: List[int]) -> int:
        m = 10 ** 6
        for i in nums:
            x = abs(i-0)
            if x < m:
                m = x
                val = i
            elif x == m and val < i:
                val = i
        return val",AakRay
2240,https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/discuss/1962778/Python-easy-solution-faster-than-90,"class Solution:
    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:
        if total < cost1 and total < cost2:
            return 1
        ways = 0
        if cost1 > cost2:
            for i in range(0, (total // cost1)+1):
                rem = total - (i * cost1)
                ways += (rem // cost2) + 1
            return ways
        for i in range(0, (total // cost2)+1):
            rem = total - (i * cost2)
            ways += (rem // cost1) + 1
        return ways",alishak1999
2242,https://leetcode.com/problems/maximum-score-of-a-node-sequence/discuss/1984916/Python3-O(orEor)-solution,"class Solution:
    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
      
      connection = {}
      
      for source, target in edges:
        if source not in connection: connection[source] = [target]
        else: connection[source].append(target)
          
        if target not in connection: connection[target] = [source]
        else: connection[target].append(source)
          
      res = -1
      
      max_dict = {}
      for key, value in connection.items():
        max1, max2, max3 = -sys.maxsize, -sys.maxsize, -sys.maxsize
        n1, n2, n3 = None, None, None
        for element in value:
          if scores[element] > max1:
            max1, max2, max3 = scores[element], max1, max2
            n1, n2, n3 = element, n1, n2
          elif scores[element] > max2:
            max2, max3 = scores[element], max2
            n2, n3 = element, n2
          elif scores[element] > max3:
            max3 = scores[element]
            n3 = element
        max_dict[key] = []
        if n1 != None: max_dict[key].append(n1)
        if n2 != None: max_dict[key].append(n2)
        if n3 != None: max_dict[key].append(n3)
             
      for source, target in edges:
        base = scores[source] + scores[target]
        
        n_s = max_dict[source]
        n_t = max_dict[target]
        if len(n_s) == 1 or len(n_t) == 1:
          pass
        else:
          new_n_s = [x for x in n_s if x != target]
          new_n_t = [x for x in n_t if x != source]
          if new_n_s[0] != new_n_t[0]:
            res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[0]])
          else:
            if len(new_n_s) > 1:
              res = max(res, base + scores[new_n_s[1]] + scores[new_n_t[0]])
            if len(new_n_t) > 1:
              res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[1]])      
    
      return res",xxHRxx
2243,https://leetcode.com/problems/calculate-digit-sum-of-a-string/discuss/1955460/Python3-elegant-pythonic-clean-and-easy-to-understand,"class Solution:
    def digitSum(self, s: str, k: int) -> str:
        while len(s) > k:
            set_3 = [s[i:i+k] for i in range(0, len(s), k)]
            s = ''
            for e in set_3:
                val = 0
                for n in e:
                    val += int(n)
                s += str(val)
        return s",Tallicia
2244,https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/discuss/1955367/Well-Explained-Python-Solution,"class Solution:
    def minimumRounds(self, tasks: List[int]) -> int:
        table, res = Counter(tasks), 0 # Counter to hold frequency of ith task and res stores the result.
        for count in table.values():
            if count <= 1: return -1 # If count <= 1 then it cannot follow the condition hence return -1.
            res += ceil(count / 3) # Total number of groups increments after 3 values. 
        return res",anCoderr
2245,https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955502/Python-Prefix-Sum-O(m-*-n),"class Solution:
    def maxTrailingZeros(self, grid: List[List[int]]) -> int:
        ans = 0
        m, n = len(grid), len(grid[0])
        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]
        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]
        for i in range(m):
            for j in range(n):
                temp= grid[i][j]
                while temp % 2 == 0:
                    prefixH[i][j + 1][0] += 1
                    prefixV[i + 1][j][0] += 1
                    temp //= 2
                while temp % 5 == 0:
                    prefixH[i][j + 1][1] += 1
                    prefixV[i + 1][j][1] += 1
                    temp //= 5
                for k in range(2):
                    prefixH[i][j + 1][k] += prefixH[i][j][k]
                    prefixV[i + 1][j][k] += prefixV[i][j][k]
        for i in range(m):
            for j in range(n):
                left = prefixH[i][j]
                up = prefixV[i][j]
                right, down, center = [0] * 2, [0] * 2, [0] * 2
                for k in range(2):
                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]
                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]
                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]
                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2
                for k in range(2):
                    LU[k] += left[k] + up[k] + center[k]
                    LD[k] += left[k] + down[k] + center[k]
                    RU[k] += right[k] + up[k] + center[k]
                    RD[k] += right[k] + down[k] + center[k]
                ans = max(ans,
                          min(LU[0], LU[1]),
                          min(LD[0], LD[1]),
                          min(RU[0], RU[1]),
                          min(RD[0], RD[1]))
        return ans",xil899
2246,https://leetcode.com/problems/longest-path-with-different-adjacent-characters/discuss/2494179/Python-oror-Faster-than-100-oror-Simple-DFS-oror-Easy-Explanation,"class Solution:
    def longestPath(self, par: List[int], s: str) -> int:
        dit = {}
        # store tree in dictionary
        for i in range(len(par)):
            if par[i] in dit:
                dit[par[i]].append(i)
            else:
                dit[par[i]] = [i]
                
        ans = 1        
        def dfs(n):
            nonlocal ans
            if n not in dit:
                return 1
            
            largest=0 # largest path lenght among all children
            second_largest=0 # second largest path lenght among all children
            for u in dit[n]:
                curr = dfs(u)
                if s[u]!=s[n]: # pick child path if child and parent both have different value
                    if curr>largest:
                        second_largest = largest
                        largest = curr
                    elif curr>second_largest:
                        second_largest = curr
                        
            ans = max(ans,largest+second_largest+1) # largest path including parent with at most two children 
            
            return largest+1  # return largest path end at parent
        
        dfs(0)
        return ans
        ```",Laxman_Singh_Saini
2248,https://leetcode.com/problems/intersection-of-multiple-arrays/discuss/2428232/94.58-faster-using-set-and-and-operator-in-Python,"class Solution:
    def intersection(self, nums: List[List[int]]) -> List[int]:
        res = set(nums[0])
        for i in range(1, len(nums)):
            res &amp;= set(nums[i])
        res = list(res)
        res.sort()
        return res",ankurbhambri
2249,https://leetcode.com/problems/count-lattice-points-inside-a-circle/discuss/1977094/Python-Math-(Geometry)-and-Set-Solution-No-Brute-Force,"class Solution:
    def countLatticePoints(self, circles: List[List[int]]) -> int:
        points = set()
        for x, y, r in circles:
            for dx in range(-r, r + 1, 1):
                temp = math.floor(math.sqrt(r ** 2 - dx ** 2))
                for dy in range(-temp, temp + 1):
                    points.add((x + dx, y + dy))
        return len(points)",xil899
2250,https://leetcode.com/problems/count-number-of-rectangles-containing-each-point/discuss/1980349/Python3-binary-search,"class Solution:
    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:
        mp = defaultdict(list)
        for l, h in rectangles: mp[h].append(l)
        for v in mp.values(): v.sort()
        ans = []
        for x, y in points: 
            cnt = 0 
            for yy in range(y, 101): 
                if yy in mp: cnt += len(mp[yy]) - bisect_left(mp[yy], x)
            ans.append(cnt)
        return ans",ye15
2251,https://leetcode.com/problems/number-of-flowers-in-full-bloom/discuss/2757459/Binary-Search-with-Explanation-Fast-and-Easy-Solution,"class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:
        start, end, res = [], [], []
        for i in flowers:
            start.append(i[0])
            end.append(i[1])
        start.sort() #bisect only works with sorted data
        end.sort()

        for p in persons:
            num = bisect_right(start, p) - bisect_left(end, p)
            res.append(num)
        return res
#bisect_right(start, p) gives you the number of flowers that are in full bloom at person p.
#bisect_left(end, p) gives you number of flowers that are not in full bloom at person p.
#we have to tighten our bound to get exact number of flowers that are in bloom or not, thats why we are using right and left of bisect module.",user6770yv
2255,https://leetcode.com/problems/count-prefixes-of-a-given-string/discuss/2076295/Easy-python-solution,"class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        count=0
        for i in words:
            if (s[:len(i)]==i):
                count+=1
        return count",tusharkhanna575
2256,https://leetcode.com/problems/minimum-average-difference/discuss/2098497/PYTHON-oror-EASY-oror-BEGINER-FRIENDLY,"class Solution:
    def minimumAverageDifference(self, a: List[int]) -> int:
        l=0
        r=sum(a)
        z=100001
        y=0
        n=len(a)
        
        for i in range(n-1):
            l+=a[i]
            r-=a[i]
        
            d=abs((l//(i+1))-(r//(n-i-1)))
            if d<z:
                z=d
                y=i
        
        if sum(a)//n<z:
            y=n-1
        
        return y",karan_8082
2257,https://leetcode.com/problems/count-unguarded-cells-in-the-grid/discuss/1994806/Simple-python-code,"class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        vis = [[0]*n for _ in range(m)]
        # i - rows, j - colums
        # sum(row.count('hit') for row in grid)
        for i,j in walls:
            vis[i][j] = 2
        for i,j in guards:
            vis[i][j] = 2
        for i,j in guards:
            for l in range(j-1,-1,-1):
                if self.checkWall(i,l,vis):
                    break    
                vis[i][l] = 1
            for r in range(j+1,n):
                if self.checkWall(i,r,vis):
                    break
                vis[i][r] = 1
            for u in range(i-1,-1,-1):
                if self.checkWall(u,j,vis):
                    break
                vis[u][j] = 1
            for d in range(i+1,m):
                if self.checkWall(d,j, vis):
                    break
                vis[d][j] = 1
        return sum(row.count(0) for row in vis)
        
    def checkWall(self, i, j, vis):
        if vis[i][j] ==2:
            return True",beast316
2258,https://leetcode.com/problems/escape-the-spreading-fire/discuss/2005513/Python3-BFS-%2B-DFS-%2B-Binary-Search-Solution,"class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
      
      #region growing to assign each grass with the time that it will catch fire
      
      m, n = len(grid), len(grid[0])
      
      start = []
      
      for i in range(m):
        for j in range(n):
          if grid[i][j] == 1:
            start.append([i,j])
            grid[i][j] = 'F'
          elif grid[i][j] == 2:
            grid[i][j] = 'W'
            
      visited = set()
      for element in start: visited.add(tuple(element))
        
      time = 1
      
      while start:
        new_start = []
        for x, y in start:
          if x >= 1:
            if grid[x-1][y] == 0 and (x-1, y) not in visited:
              new_start.append([x-1, y])
              visited.add((x-1, y))
              grid[x-1][y] = time
          if x < m-1:
            if grid[x+1][y] == 0 and (x+1, y) not in visited:
              new_start.append([x+1, y])
              visited.add((x+1, y))
              grid[x+1][y] = time
          if y >= 1:
            if grid[x][y-1] == 0 and (x, y-1) not in visited:
              new_start.append([x, y-1])
              visited.add((x, y-1))
              grid[x][y-1] = time
          if y < n-1:
            if grid[x][y+1] == 0 and (x, y+1) not in visited:
              new_start.append([x, y+1])
              visited.add((x, y+1))
              grid[x][y+1] = time
        time += 1
        start = new_start
        
        
      #memo variable will save time from search path that is already proved to be impossible
      memo = {}
      def search(x, y, time, visited):
        if (x,y) in memo and time >= memo[(x,y)]: return False
        if time > grid[-1][-1]: return False
        if x == m-1 and y == n-1:
          if grid[x][y] == 0:
            return True
          else: 
            if grid[x][y] >= time:
              return True
        else:
          if grid[x][y] == time: return False
          visited.add((x,y))
          if x >= 1:
            if grid[x-1][y] != 'W' and grid[x-1][y] != 'F' and grid[x-1][y] > time  and (x-1, y) not in visited:
              res = search(x-1, y, time+1, visited)
              if res: return True
          if x < m-1:
            if grid[x+1][y] != 'W' and grid[x+1][y] != 'F' and grid[x+1][y] > time  and (x+1, y) not in visited:
              res = search(x+1, y, time+1, visited)
              if res: return True
          if y >= 1:
            if grid[x][y-1] != 'W' and grid[x][y-1] != 'F' and grid[x][y-1] > time  and (x, y-1) not in visited:
              res = search(x, y-1, time+1, visited)
              if res: return True
          if y < n-1:
            if grid[x][y+1] != 'W' and grid[x][y+1] != 'F' and grid[x][y+1] > time  and (x, y+1) not in visited:
              res = search(x, y+1, time+1, visited)
              if res: return True
          visited.remove((x,y))
          if (x,y) not in memo: memo[(x,y)] = time
          else: memo[(x,y)] = min(time, memo[(x,y)])
          return False
        
      if grid[0][0] == 0:
        if search(0, 0, -sys.maxsize, set()): return 10**9
        else: return -1
      else:
        start, end = 0, grid[0][0]-1
        
        #binary search
 
        while start < end:
          mid = ceil((start + end)/2)
          if search(0, 0, mid, set()):
            start = mid
          else:
            end = mid - 1
        if start != 0: return start
        else:
          if search(0, 0, 0, set()): return 0
          else: return -1",xxHRxx
2259,https://leetcode.com/problems/remove-digit-from-number-to-maximize-result/discuss/2074599/Python-O(N)-solution-oror-Faster-than-99-submissions-oror-Detailed-explanation.,"class Solution:
    def removeDigit(self, number: str, digit: str) -> str:
        
        # Initializing the last index as zero
        last_index = 0
        
        #iterating each number to find the occurences, \
        # and to find if the number is greater than the next element \ 

        for num in range(1, len(number)):
            
            # Handling [case 1] and [case 2]
            if number[num-1] == digit:
                if int(number[num]) > int(number[num-1]):
                    return number[:num-1] + number[num:]
                else:
                    last_index = num - 1
        
        # If digit is the last number (last occurence) in the string [case 3]
        if number[-1] == digit:
            last_index = len(number) - 1

        return number[:last_index] + number[last_index + 1:]",litdatascience
2260,https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/discuss/1996393/Python3-or-Beginner-friendly-explained-or,"class Solution:
    def minimumCardPickup(self, cards: List[int]) -> int:
        minPick = float('inf')
        seen = {}
        for i, n in enumerate(cards):
            if n in seen:
                if i - seen[n] + 1 < minPick:
                    minPick = i - seen[n] + 1
            seen[n] = i
        if minPick == float('inf'):
            return -1
        return minPick",hanjo108
2261,https://leetcode.com/problems/k-divisible-elements-subarrays/discuss/1996643/Python-Simple-Count-all-combinations,"class Solution:
    def countDistinct(self, nums: List[int], k: int, p: int) -> int:
        n = len(nums)                        
        sub_arrays = set()
        
		# generate all combinations of subarray
        for start in range(n):
            cnt = 0
            temp = ''
            for i in range(start, n):
                if nums[i]%p == 0:
                    cnt+=1                 
                temp+=str(nums[i]) + ',' # build the sequence subarray in CSV format          
                if cnt>k: # check for termination 
                    break
                sub_arrays.add(temp)                                    
                
        return len(sub_arrays)",constantine786
2262,https://leetcode.com/problems/total-appeal-of-a-string/discuss/1996203/DP,"class Solution:
    def appealSum(self, s: str) -> int:
        res, cur, prev = 0, 0, defaultdict(lambda: -1)
        for i, ch in enumerate(s):
            cur += i - prev[ch]
            prev[ch] = i
            res += cur
        return res",votrubac
2264,https://leetcode.com/problems/largest-3-same-digit-number-in-string/discuss/2017786/Compare-with-2-previous,"class Solution:
    def largestGoodInteger(self, n: str) -> str:
        return max(n[i-2:i+1] if n[i] == n[i - 1] == n[i - 2] else """" for i in range(2, len(n)))",votrubac
2265,https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/discuss/2017794/Python3-post-order-dfs,"class Solution:
    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:
        
        def fn(node): 
            nonlocal ans
            if not node: return 0, 0 
            ls, ln = fn(node.left)
            rs, rn = fn(node.right)
            s = node.val + ls + rs
            n = 1 + ln + rn
            if s//n == node.val: ans += 1
            return s, n
        
        ans = 0 
        fn(root)
        return ans",ye15
2266,https://leetcode.com/problems/count-number-of-texts/discuss/2017834/Python3-group-by-group,"class Solution:
    def countTexts(self, pressedKeys: str) -> int:
        MOD = 1_000_000_007 
        
        @cache 
        def fn(n, k): 
            """"""Return number of possible text of n repeated k times.""""""
            if n < 0: return 0
            if n == 0: return 1
            ans = 0
            for x in range(1, k+1): ans = (ans + fn(n-x, k)) % MOD
            return ans 
        
        ans = 1
        for key, grp in groupby(pressedKeys): 
            if key in ""79"": k = 4
            else: k = 3
            ans = (ans * fn(len(list(grp)), k)) % MOD 
        return ans",ye15
2267,https://leetcode.com/problems/check-if-there-is-a-valid-parentheses-string-path/discuss/2018005/Python-Simple-MemoisationCaching,"class Solution:
    def hasValidPath(self, grid: List[List[str]]) -> bool:  
        m = len(grid)
        n = len(grid[0])
        @lru_cache(maxsize=None)
        def hasValidPathInner(x, y, cnt):
            # cnt variable would act as a counter to track 
            # the balance of parantheses sequence
            if x == m or y == n or cnt < 0:
                return False
            
            # logic to check the balance of sequence
            cnt += 1 if grid[x][y] == '(' else -1
            
            # if balanced and end of grid, return True
            if x == m - 1 and y == n - 1 and not cnt:
                return True
            
            return hasValidPathInner(x + 1, y, cnt) or hasValidPathInner(x, y + 1, cnt)

        return hasValidPathInner(0, 0, 0)",constantine786
2269,https://leetcode.com/problems/find-the-k-beauty-of-a-number/discuss/2611592/Python-Elegant-and-Short-or-Sliding-window-or-O(log10(n))-time-or-O(1)-memory,"class Solution:
    """"""
    Time:   O(log10(n)*k)
    Memory: O(log10(n))
    """"""

    def divisorSubstrings(self, num: int, k: int) -> int:
        str_num = str(num)
        return sum(
            num % int(str_num[i - k:i]) == 0
            for i in range(k, len(str_num) + 1)
            if int(str_num[i - k:i]) != 0
        )",Kyrylo-Ktl
2270,https://leetcode.com/problems/number-of-ways-to-split-array/discuss/2038567/Prefix-Sum,"class Solution:
    def waysToSplitArray(self, n: List[int]) -> int:
        n = list(accumulate(n))
        return sum(n[i] >= n[-1] - n[i] for i in range(len(n) - 1))",votrubac
2271,https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/discuss/2148636/Python3-greedy,"class Solution:
    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        tiles.sort()
        ans = ii = val = 0 
        for i in range(len(tiles)): 
            hi = tiles[i][0] + carpetLen - 1
            while ii < len(tiles) and tiles[ii][1] <= hi:
                val += tiles[ii][1] - tiles[ii][0] + 1
                ii += 1
            partial = 0 
            if ii < len(tiles): partial = max(0, hi - tiles[ii][0] + 1)
            ans = max(ans, val + partial)
            val -= tiles[i][1] - tiles[i][0] + 1
        return ans",ye15
2272,https://leetcode.com/problems/substring-with-largest-variance/discuss/2148640/Python3-pairwise-prefix-sum,"class Solution:
    def largestVariance(self, s: str) -> int:
        ans = 0 
        seen = set(s)
        for x in ascii_lowercase: 
            for y in ascii_lowercase: 
                if x != y and x in seen and y in seen: 
                    vals = []
                    for ch in s: 
                        if ch == x: vals.append(1)
                        elif ch == y: vals.append(-1)
                    cand = prefix = least = 0 
                    ii = -1 
                    for i, v in enumerate(vals): 
                        prefix += v
                        if prefix < least: 
                            least = prefix 
                            ii = i 
                        ans = max(ans, min(prefix-least, i-ii-1))
        return ans",ye15
2273,https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/discuss/2039752/Weird-Description,"class Solution:
    def removeAnagrams(self, w: List[str]) -> List[str]:
        return [next(g) for _, g in groupby(w, sorted)]",votrubac
2274,https://leetcode.com/problems/maximum-consecutive-floors-without-special-floors/discuss/2039754/Python-Simulation-Just-sort-the-array-special,"class Solution:
    def maxConsecutive(self, bottom: int, top: int, special: list[int]) -> int:
        special.sort()
        res = special[0] - bottom
        
        for i in range(1, len(special)):
            res = max(res, special[i] - special[i - 1] - 1)
            
        return max(res, top - special[-1])",GigaMoksh
2275,https://leetcode.com/problems/largest-combination-with-bitwise-and-greater-than-zero/discuss/2039717/Check-Each-Bit,"class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
        return max(sum(n &amp; (1 << i) > 0 for n in candidates) for i in range(0, 24))",votrubac
2278,https://leetcode.com/problems/percentage-of-letter-in-string/discuss/2061930/Simple-Python-Solution-or-Easy-to-Understand-or-Two-Liner-Solution-or-O(N)-Solution,"class Solution:
    def percentageLetter(self, s: str, letter: str) -> int:
        a = s.count(letter)
        return (a*100)//len(s)",AkashHooda
2279,https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/discuss/2062186/Python-Easy-Solution,"class Solution:
    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
        remaining = [0] * len(capacity)
        res = 0
        
        for i in range(len(capacity)):
            remaining[i] = capacity[i] - rocks[i]
        remaining.sort()
        
        for i in range(len(remaining)):
            if remaining[i] > additionalRocks:
                break
                
            additionalRocks -= remaining[i]
            res += 1
        
        return res",MiKueen
2280,https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/discuss/2061893/Python-or-Easy-to-Understand,"class Solution:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        # key point: never use devision to judge whether 3 points are on a same line or not, use the multiplication instead !!
        
        n = len(stockPrices)
        stockPrices.sort(key = lambda x: (x[0], x[1]))
        
        if n == 1:
            return 0
        
        pre_delta_y = stockPrices[0][1] - stockPrices[1][1]
        pre_delta_x = stockPrices[0][0] - stockPrices[1][0]
        num = 1
        
        for i in range(1, n-1):
            cur_delta_y = stockPrices[i][1] - stockPrices[i+1][1]
            cur_delta_x = stockPrices[i][0] - stockPrices[i+1][0]
            
            if pre_delta_y * cur_delta_x != pre_delta_x * cur_delta_y:
                num += 1
                pre_delta_x = cur_delta_x
                pre_delta_y = cur_delta_y
        
        return num",Mikey98
2281,https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2373525/faster-than-98.90-or-easy-python-or-solution,"class Solution:
    def totalStrength(self, strength: List[int]) -> int:
        strength = [0] + strength + [0]
        def calc_prefix_sum(array):
            if not array: return []
            result = [array[0]]
            for el in array[1:]:
                result.append(array[-1]+el)
            return result
        prefix_sums = calc_prefix_sum(strength)
        pp_sums = calc_prefix_sum(prefix_sums)
        stack = [0]
        total = 0
        for right in range(len(strength)):
            while pp_sums[stack[-1]] > pp_sums[right]:
                left = stack[-2]
                i = stack.pop()
                pos = (i - left) * (pp_sums[right] - pp_sums[i])
                neg = (right - i) * (pp_sums[i] - pp_sums[left])
                total += pp_sums[i] * (pos - neg)
                stack.push(right)
        return total % (10**9+7)
    def totalStrength(self, strength):
        res, S, A = 0, [0], [0] + strength + [0]                           # O(N)
        P = list(itertools.accumulate(itertools.accumulate(A), initial=0)) # O(N)
        for r in range(len(A)):                                            # O(N)
            while A[S[-1]] > A[r]:                                         # O(1) amortized
                l, i = S[-2], S.pop()
                res += A[i] * ((i - l) * (P[r] - P[i]) - (r - i) * (P[i] - P[l]))
            S.append(r)
        return res % (10 ** 9 + 7)",vimla_kushwaha
2283,https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/discuss/2084112/Python-Easy-solution,"class Solution:
    def digitCount(self, num: str) -> bool:
        counter=Counter(num)
        for i in range(len(num)):
            if counter[f'{i}'] != int(num[i]):
                return False
        return True",constantine786
2284,https://leetcode.com/problems/sender-with-largest-word-count/discuss/2084222/Easy-Python-Solution-With-Dictionary,"class Solution:
    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:
        d={}
        l=[]
        for i in range(len(messages)):
            if senders[i] not in d:
                d[senders[i]]=len(messages[i].split())
            else:
                d[senders[i]]+=len(messages[i].split())
        x=max(d.values())
        for k,v in d.items():
            if v==x :
                l.append(k)
        if len(l)==1:
            return l[0]
        else:
            l=sorted(l)[::-1]      #Lexigograhical sorting of list
            return l[0]",a_dityamishra
2285,https://leetcode.com/problems/maximum-total-importance-of-roads/discuss/2083990/Very-simple-Python-solution-O(nlog(n)),"class Solution:
    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:
        Arr = [0] * n  # i-th city has Arr[i] roads
        for A,B in roads:
            Arr[A] += 1 # Each road increase the road count
            Arr[B] += 1
        Arr.sort()  # Cities with most road should receive the most score
        summ = 0
        for i in range(len(Arr)):
            summ += Arr[i] * (i+1)  # Multiply city roads with corresponding score
        
        return summ",Eba472
2287,https://leetcode.com/problems/rearrange-characters-to-make-target-string/discuss/2085849/Python-Two-Liner-Beats-~95,"class Solution:
    def rearrangeCharacters(self, s: str, target: str) -> int:
        counter_s = Counter(s)        
        return min(counter_s[c] // count for c,count in Counter(target).items())",constantine786
2288,https://leetcode.com/problems/apply-discount-to-prices/discuss/2085723/Simple-Python-with-explanation,"class Solution:
    def discountPrices(self, sentence: str, discount: int) -> str:
        s = sentence.split() # convert to List to easily update
        m = discount / 100 
        for i,word in enumerate(s):
            if word[0] == ""$"" and word[1:].isdigit(): # Check whether it is in correct format
                num = int(word[1:]) * (1-m) # discounted price
                w = ""$"" + ""{:.2f}"".format(num) #correctly format
                s[i] = w #Change inside the list
        
        return "" "".join(s) #Combine the updated list
		```",Eba472
2289,https://leetcode.com/problems/steps-to-make-array-non-decreasing/discuss/2567529/BFS-with-updating-neighbours-or-O(n)-or-Python3,"class Solution:
    def totalSteps(self, nums: List[int]) -> int:
        n = len(nums)
        l = [i-1 for i in range(n)]
        r = [i+1 for i in range(n)]
        q = []
        dist = dict()
        ans = 0
        for i in range(1, n):
            if nums[i] < nums[i-1]:
                q.append(i)
                dist[i] = 1
                ans = 1
        while len(q) != 0:
            u = q.pop(0)
            ans = max(ans, dist[u])
            if r[u] < n:
                l[r[u]] = l[u]
            if l[u] > -1:
                r[l[u]] = r[u]
            if r[u] not in dist and r[u] < n and nums[r[u]] < nums[l[u]]:
                dist[r[u]] = dist[u] + 1
                q.append(r[u])
        return ans",DheerajGadwala
2290,https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/discuss/2313936/Python3-Dijkstra's-algo,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dist = [[inf]*n for _ in range(m)]
        dist[0][0] = 0
        pq = [(0, 0, 0)]
        while pq: 
            x, i, j = heappop(pq)
            if i == m-1 and j == n-1: return x
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 <= ii < m and 0 <= jj < n and x + grid[ii][jj] < dist[ii][jj]: 
                    dist[ii][jj] = x + grid[ii][jj]
                    heappush(pq, (dist[ii][jj], ii, jj))",ye15
2293,https://leetcode.com/problems/min-max-game/discuss/2112349/Python-Easy-Approach,"class Solution:
    def minMaxGame(self, nums: List[int]) -> int:                
        l=nums
        while len(l)>1:
            is_min=True     
            tmp=[]
            for i in range(0, len(l), 2):
                if is_min:
                    tmp.append(min(l[i:i+2]))
                else:
                    tmp.append(max(l[i:i+2]))
                is_min=not is_min            
            l=tmp            
        return l[0]",constantine786
2294,https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/discuss/2111923/Python-Easy-Solution-using-Sorting,"class Solution:
    def partitionArray(self, nums: List[int], k: int) -> int:
        nums.sort()
        ans = 1
		# To keep track of starting element of each subsequence
        start = nums[0]
        
        for i in range(1, len(nums)):
            diff = nums[i] - start
            if diff > k:
				# If difference of starting and current element of subsequence is greater
				# than K, then only start new subsequence
                ans += 1
                start = nums[i]
        
        return ans",MiKueen
2295,https://leetcode.com/problems/replace-elements-in-an-array/discuss/2112285/Python-Simple-Map-Approach,"class Solution:
    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:
            replacements = {}
            for x, y in reversed(operations):
                replacements[x] = replacements.get(y, y)
            for idx, val in enumerate(nums):
                if val in replacements:
                    nums[idx] = replacements[val]
            return nums",constantine786
2299,https://leetcode.com/problems/strong-password-checker-ii/discuss/2139499/Nothing-Special,"class Solution:
    def strongPasswordCheckerII(self, pwd: str) -> bool:
        return (
            len(pwd) > 7
            and max(len(list(p[1])) for p in groupby(pwd)) == 1
            and reduce(
                lambda a, b: a | (1 if b.isdigit() else 2 if b.islower() else 4 if b.isupper() else 8), pwd, 0
            ) == 15
        )",votrubac
2300,https://leetcode.com/problems/successful-pairs-of-spells-and-potions/discuss/2139547/Python-3-or-Math-Binary-Search-or-Explanation,"class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        potions.sort()
        ans, n = [], len(potions)
        for spell in spells:
            val = success // spell
            if success % spell == 0:
                idx = bisect.bisect_left(potions, val)
            else:    
                idx = bisect.bisect_right(potions, val)
            ans.append(n - idx)
        return ans",idontknoooo
2301,https://leetcode.com/problems/match-substring-after-replacement/discuss/2140652/Python-Precalculation-O(n*k)-without-TLE,"class Solution:
    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:
        s_maps = defaultdict(lambda : set())
        for x,y in mappings:
            s_maps[x].add(y)
                
        # build a sequence of set for substring match
        # eg: sub=leet, mappings = {e: 3, t:7}
        # subs = [{l}, {e, 3}, {e, 3}, {t, 7}]
        # precalculation helps to eliminate TLE
        subs = [s_maps[c] | {c} for c in sub] 
        
        for i in range(len(s)-len(sub) + 1):
            c=s[i]            
            j=i
            # Try to match substring
            while j-i<len(sub) and s[j] in subs[j-i]:                                        
                j+=1
            if j-i==len(sub): # a valid match if iterated through the whole length of substring
                return True
    
        return False",constantine786
2302,https://leetcode.com/problems/count-subarrays-with-score-less-than-k/discuss/2138778/Sliding-Window,"class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        sum, res, j = 0, 0, 0
        for i, n in enumerate(nums):
            sum += n
            while sum * (i - j + 1) >= k:
                sum -= nums[j]
                j += 1
            res += i - j + 1
        return res",votrubac
2303,https://leetcode.com/problems/calculate-amount-paid-in-taxes/discuss/2141187/Python3-bracket-by-bracket,"class Solution:
    def calculateTax(self, brackets: List[List[int]], income: int) -> float:
        ans = prev = 0 
        for hi, pct in brackets: 
            hi = min(hi, income)
            ans += (hi - prev)*pct/100
            prev = hi 
        return ans",ye15
2304,https://leetcode.com/problems/minimum-path-cost-in-a-grid/discuss/2141004/Python-Recursion-%2B-Memoization,"class Solution:
    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        max_row, max_col = len(grid), len(grid[0])
        dp = [[-1] * max_col for _ in range(max_row)] 

        def recursion(row, col):
            if row == max_row - 1: # If last row then return nodes value
                return grid[row][col]
            if dp[row][col] == -1: # If DP for this node is not computed then we will do so now.
                current = grid[row][col] # Current Node Value
                res = float('inf') # To store best path from Current Node
                for c in range(max_col): # Traverse all path from Current Node
                    val = moveCost[current][c] + recursion(row + 1, c) # Move cost + Target Node Value
                    res = min(res, val)
                dp[row][col] = res + current # DP[current node] = Best Path + Target Node Val + Current Node Val
            return dp[row][col]

        for c in range(max_col):
            recursion(0, c) # Start recursion from all nodes in 1st row
        return min(dp[0]) # Return min value from 1st row",anCoderr
2305,https://leetcode.com/problems/fair-distribution-of-cookies/discuss/2141013/Python-optimized-solution-or-Backtracking-Implemented-or-O(KN)-Time-Complexity,"class Solution:
    def distributeCookies(self, cookies: List[int], k: int) -> int:
        l = [0]*k 
        self.s = float('inf')
        def ser(l,i):
            if i>=len(cookies):
                self.s = min(self.s,max(l))
                return 
            if max(l)>=self.s:
                return 
            for j in range(k):
                l[j]+=cookies[i]
                ser(l,i+1)
                l[j]-=cookies[i]
        
        ser(l,0)
        return self.s",AkashHooda
2306,https://leetcode.com/problems/naming-a-company/discuss/2147565/Python-or-Faster-than-100-or-groupby-detailed-explanation,"class Solution:
    def distinctNames(self, ideas: List[str]) -> int:
        
        names=defaultdict(set)
        res=0  
        
        #to store first letter as key and followed suffix as val
        for i in ideas:
            names[i[0]].add(i[1:])
            
        #list of distinct first-letters available in ideas (may or may not contain all alphabets,depends upon elements in ideas)
        arr=list(names.keys())
        ans,n=0,len(arr)
        
        for i in range(n):
            for j in range(i+1,n):
                #a,b => 2 distinct first letters
                a,b=arr[i],arr[j]
                # adding the number of distinct posssible suffixes and multiplying by 2 as the new word formed might be ""newword1 newword2"" or ""newword2 newword1""
                res+=len(names[a]-names[b])*len(names[b]-names[a])*2
                
        return res",anjalianupam23
2309,https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/discuss/2168442/Counter,"class Solution:
    def greatestLetter(self, s: str) -> str:
        cnt = Counter(s)
        return next((u for u in reversed(ascii_uppercase) if cnt[u] and cnt[u.lower()]), """")",votrubac
2310,https://leetcode.com/problems/sum-of-numbers-with-units-digit-k/discuss/2168546/Python-oror-Easy-Approach-oror-beats-90.00-Both-Runtime-and-Memory-oror-Remainder,"class Solution:
    def minimumNumbers(self, num: int, k: int) -> int:
        
        if num == 0:
            return 0
        
        if num < k:
            return -1
        
        if num == k:
            return 1
        
        ans = -1
        i = 1

        while i <= 10:
            if (num - i * k) % 10 == 0 and i * k <= num:
                return i
            i += 1

        return ans",chuhonghao01
2311,https://leetcode.com/problems/longest-binary-subsequence-less-than-or-equal-to-k/discuss/2168527/PythonororGreedyororFastororEasy-to-undestandoror-With-explanations,"class Solution:
    def longestSubsequence(self, s: str, k: int) -> int:
        n = len(s)
        ones = []
		# Notice how I reversed the string,
		# because the binary representation is written from greatest value of 2**n
        for i, val in enumerate(s[::-1]):
            if val == '1':
                ones.append(i)
		# Initialize ans, there are already number of zeroes (num_of_zeroes = len(nums) - len(ones)
        ans = n - len(ones)
        i = 0
		# imagine k == 5 and binary string 001011
		# ones = [0, 1, 3]
		# first loop: 5 - 2**0 -> 4, ans += 1
		# second loop: 4 - 2**1 -> 2, ans +=1
		# Third loop does not occur because 2 - 2**3 -> -6 which is less than zero
		# So the ans is 3 + 2 = 5
        while i < len(ones) and k - 2 ** ones[i] >= 0:
            ans += 1
            k -= 2 ** ones[i]
            i += 1
	
        return ans",muctep_k
2312,https://leetcode.com/problems/selling-pieces-of-wood/discuss/2194345/Python-bottom-up-DP-faster-than-99,"class Solution:
    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:
        dp = [[0]*(n+1) for _ in range(m+1)]
        for h, w, p in prices:
            dp[h][w] = p
        for i in range(1, m+1):
            for j in range(1, n+1):
                v = max(dp[k][j] + dp[i - k][j] for k in range(1, i // 2 + 1)) if i > 1 else 0
                h = max(dp[i][k] + dp[i][j - k] for k in range(1, j // 2 + 1)) if j > 1 else 0
                dp[i][j] = max(dp[i][j], v, h)
        return dp[m][n]",metaphysicalist
2315,https://leetcode.com/problems/count-asterisks/discuss/2484633/Python-Elegant-and-Short-or-Two-solutions-or-One-pass-One-line,"class Solution:
	""""""
	Time:   O(n)
	Memory: O(1)
	""""""

	def countAsterisks(self, s: str) -> int:
		is_closed = True
		count = 0

		for c in s:
			count += is_closed * c == '*'
			is_closed ^= c == '|'

		return count


class Solution:
	""""""
	Time:   O(n)
	Memory: O(n)
	""""""

	def countAsterisks(self, s: str) -> int:
		return sum(chunk.count('*') for chunk in s.split('|')[0::2])",Kyrylo-Ktl
2316,https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/discuss/2199190/Simple-and-easy-to-understand-using-dfs-with-explanation-Python,"class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        def dfs(graph,node,visited):
            visited.add(node)
            self.c += 1
            for child in graph[node]:
                if child not in visited:
                    dfs(graph, child, visited)
        
        #build graph
        graph = {}
        for i in range(n):
            graph[i] = []
            
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        visited = set()
        count = 0
        totalNodes = 0
        
        #run dfs in unvisited nodes
        for i in range(n):
            if i not in visited:
                self.c = 0
                dfs(graph, i, visited)
                
                count += totalNodes*self.c    # result 
                totalNodes += self.c          # total nodes visited 
        return count",ratre21
2317,https://leetcode.com/problems/maximum-xor-after-operations/discuss/2366537/Python3-oror-1-line-bit-operations-w-explanation-oror-TM%3A-8887,"class Solution:
   def maximumXOR(self, nums: List[int]) -> int:
       return reduce(lambda x,y: x|y, nums)

class Solution:
   def maximumXOR(self, nums: List[int]) -> int:
       return reduce(or_, nums)

class Solution:
   def maximumXOR(self, nums: List[int]) -> int:
       
       ans = 0
       for n in nums:
           ans |= n      
       return ans",warrenruud
2318,https://leetcode.com/problems/number-of-distinct-roll-sequences/discuss/2196009/Python3-top-down-dp,"class Solution:
    def distinctSequences(self, n: int) -> int:
        
        @lru_cache
        def fn(n, p0, p1): 
            """"""Return total number of distinct sequences.""""""
            if n == 0: return 1
            ans = 0
            for x in range(1, 7): 
                if x not in (p0, p1) and gcd(x, p0) == 1: ans += fn(n-1, x, p0)
            return ans % 1_000_000_007
        
        return fn(n, -1, -1)",ye15
2319,https://leetcode.com/problems/check-if-matrix-is-x-matrix/discuss/2368873/Easiest-Python-solution-you-will-find.......-Single-loop,"class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        a=0
        j=len(grid)-1
        for i in range(0,len(grid)):
            if grid[i][i]==0 or grid[i][j]==0:
                return False
            else:
                if i!=j:
                    a=grid[i][i]+grid[i][j]
                elif i==j:
                    a=grid[i][i]
            if a!=sum(grid[i]):
                return False
            j-=1
        return True",guneet100
2320,https://leetcode.com/problems/count-number-of-ways-to-place-houses/discuss/2198265/Python-Simple-Solution-or-O(n)-time-complexity-or-Basic-Approach-or-DP,"class Solution:
    def countHousePlacements(self, n: int) -> int:
        pre,ppre = 2,1
        if n==1:
            return 4
        for i in range(1,n):
            temp = pre+ppre 
            ppre = pre 
            pre = temp 
        return ((pre)**2)%((10**9) + 7)",AkashHooda
2321,https://leetcode.com/problems/maximum-score-of-spliced-array/discuss/2198195/Python-or-Easy-to-Understand-or-With-Explanation-or-No-Kadane,"class Solution:
    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:
        # create a difference array between nums1 and nums2
        # idea: find two subarray(elements are contiguous) in the diff
        # one is the subarray that have the minimum negative sum
        # another one is the subarray that have the maximum positive sum
        # so there are four candidates for maximum score:
        # 1. original_sum1 
        # 2. original_sum 
        # 3. original_sum1 - min_negative_sum
        # 4. original_sum2 + max_positive_sum
        
        original_sum1 = sum(nums1)
        original_sum2 = sum(nums2)
        diff = [num1 - num2 for num1, num2 in zip(nums1, nums2)]
        min_negative_sum = float('inf')
        max_positive_sum = - float('inf')
        cur_negative_sum = 0
        cur_positive_sum = 0
        
        for val in diff:
            cur_negative_sum += val

            if cur_negative_sum > 0:
                cur_negative_sum = 0
            
            cur_positive_sum += val
            
            if cur_positive_sum < 0:
                cur_positive_sum = 0
                    
            min_negative_sum = min(min_negative_sum, cur_negative_sum)
            max_positive_sum = max(max_positive_sum, cur_positive_sum)

        return max(original_sum1 - min_negative_sum, original_sum2 + max_positive_sum, original_sum2, original_sum1)",Mikey98
2322,https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/discuss/2198386/Python3-dfs,"class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:        
        n = len(nums)
        graph = [[] for _ in range(n)]
        for u, v in edges: 
            graph[u].append(v)
            graph[v].append(u)
            
        def fn(u): 
            score[u] = nums[u]
            child[u] = {u}
            for v in graph[u]: 
                if seen[v] == 0: 
                    seen[v] = 1
                    fn(v)
                    score[u] ^= score[v]
                    child[u] |= child[v]
        
        seen = [1] + [0]*(n-1)
        score = [0]*n
        child = [set() for _ in range(n)]
        fn(0)
        
        ans = inf 
        for u in range(1, n): 
            for v in range(u+1, n): 
                if u in child[v]: 
                    uu = score[u]
                    vv = score[v] ^ score[u]
                    xx = score[0] ^ score[v]
                elif v in child[u]: 
                    uu = score[u] ^ score[v]
                    vv = score[v]
                    xx = score[0] ^ score[u]
                else: 
                    uu = score[u]
                    vv = score[v]
                    xx = score[0] ^ score[u] ^ score[v]
                ans = min(ans, max(uu, vv, xx) - min(uu, vv, xx))
        return ans",ye15
2325,https://leetcode.com/problems/decode-the-message/discuss/2229844/Easy-Python-solution-using-Hashing,"class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        mapping = {' ': ' '}
        i = 0
        res = ''
        letters = 'abcdefghijklmnopqrstuvwxyz'
        
        for char in key:
            if char not in mapping:
                mapping[char] = letters[i]
                i += 1
        
        for char in message:
            res += mapping[char]
                
        return res",MiKueen
2326,https://leetcode.com/problems/spiral-matrix-iv/discuss/2230251/Python-easy-solution-using-direction-variable,"class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        
        matrix = [[-1]*n for i in range(m)]
        
        current = head
        direction = 1
        i, j = 0, -1
        
        while current:
            for _ in range(n):
                if current:
                    j += direction
                    matrix[i][j] = current.val
                    current = current.next
                    
            m -= 1
            
            for _ in range(m):
                if current:
                    i += direction
                    matrix[i][j] = current.val
                    current = current.next
            n -= 1
            
            direction *= -1
        
        return matrix",HunkWhoCodes
2327,https://leetcode.com/problems/number-of-people-aware-of-a-secret/discuss/2229808/Two-Queues-or-Rolling-Array,"class Solution:
    def peopleAwareOfSecret(self, n: int, d: int, f: int) -> int:
        dp, md = [1] + [0] * (f - 1), 10**9 + 7
        for i in range(1, n):
            dp[i % f] = (md + dp[(i + f - d) % f] - dp[i % f] + (0 if i == 1 else dp[(i - 1) % f])) % md
        return sum(dp) % md",votrubac
2328,https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/discuss/2691096/Python-(Faster-than-94)-or-DFS-%2B-DP-O(N*M)-solution,"class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        dp = {}
        mod = (10 ** 9) + 7

        def dfs(r, c, prev):
            if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] <= prev:
                return 0

            if (r, c) in dp:
                return dp[(r, c)]

            pathLength = 1
            pathLength += (dfs(r + 1, c, grid[r][c]) + dfs(r - 1, c, grid[r][c]) +
                dfs(r, c + 1, grid[r][c]) + dfs(r, c - 1, grid[r][c]))
            dp[(r, c)] = pathLength
            return pathLength
            
        count = 0
        for r in range(rows):
            for c in range(cols):
                count += dfs(r, c, 0)

        return count % mod",KevinJM17
2335,https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/discuss/2262041/Python-or-Straightforward-MaxHeap-Solution,"class Solution:
    def fillCups(self, amount: List[int]) -> int:
        pq = [-q for q in amount if q != 0]
        heapq.heapify(pq)
        ret = 0
        
        while len(pq) > 1:
            first = heapq.heappop(pq)
            second = heapq.heappop(pq)
            first += 1
            second += 1
            ret += 1
            if first:
                heapq.heappush(pq, first)
            if second:
                heapq.heappush(pq, second)

        if pq:
            return ret - pq[0]
        else:
            return ret",lukefall425
2354,https://leetcode.com/problems/number-of-excellent-pairs/discuss/2324641/Python3-Sorting-Hamming-Weights-%2B-Binary-Search-With-Detailed-Explanations,"class Solution:
    def countExcellentPairs(self, nums: List[int], k: int) -> int:
        hamming = sorted([self.hammingWeight(num) for num in set(nums)])
        ans = 0
        for h in hamming:
            ans += len(hamming) - bisect.bisect_left(hamming, k - h)
        return ans
        
    def hammingWeight(self, n):
        ans = 0
        while n:
            n &amp;= (n - 1)
            ans += 1
        return ans",xil899
2369,https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/discuss/2390552/Python3-Iterative-DFS,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:
        idxs = defaultdict(list)
        n = len(nums)
        
        #Find all doubles
        for idx in range(1, n):
            if nums[idx] == nums[idx - 1]:
                idxs[idx - 1].append(idx + 1)
                
        #Find all triples
        for idx in range(2, n):
            if nums[idx] == nums[idx - 1] == nums[idx - 2]:
                idxs[idx - 2].append(idx + 1)
                
        #Find all triple increments
        for idx in range(2, n):
            if nums[idx] == nums[idx - 1] + 1 == nums[idx - 2] + 2:
                idxs[idx - 2].append(idx + 1)
        
        #DFS 
        seen = set()
        stack = [0]

        while stack:
            node = stack.pop()

            if node not in seen:
                if node == n:
                    return True
                seen.add(node)

            for adj in idxs[node]:
                if adj not in seen:
                    stack.append(adj)
        
        return False",0xRoxas
2370,https://leetcode.com/problems/longest-ideal-subsequence/discuss/2390471/DP,"class Solution:
    def longestIdealString(self, s: str, k: int) -> int:
        dp = [0] * 26
        for ch in s:
            i = ord(ch) - ord(""a"")
            dp[i] = 1 + max(dp[max(0, i - k) : min(26, i + k + 1)])
        return max(dp)",votrubac
2376,https://leetcode.com/problems/count-special-integers/discuss/2422258/Python3-dp,"class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        vals = list(map(int, str(n)))
        
        @cache
        def fn(i, m, on): 
            """"""Return count at index i with mask m and profile flag (True/False)""""""
            ans = 0 
            if i == len(vals): return 1
            for v in range(vals[i] if on else 10 ): 
                if m &amp; 1<<v == 0: 
                    if m or v: ans += fn(i+1, m ^ 1<<v, False)
                    else: ans += fn(i+1, m, False)
            if on and m &amp; 1<<vals[i] == 0: ans += fn(i+1, m ^ 1<<vals[i], True)
            return ans 
        
        return fn(0, 0, True)-1",ye15
2383,https://leetcode.com/problems/minimum-hours-of-training-to-win-a-competition/discuss/2456759/Python-oror-Easy-Approach,"class Solution:
    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:
        
        ans = 0
        n = len(energy)

        for i in range(n):
            while initialEnergy <= energy[i] or initialExperience <= experience[i]:
                if initialEnergy <= energy[i]:
                    initialEnergy += 1
                    ans += 1
                if initialExperience <= experience[i]:
                    initialExperience += 1
                    ans += 1
            initialEnergy -= energy[i]
            initialExperience += experience[i]
        
        return ans",chuhonghao01
2384,https://leetcode.com/problems/largest-palindromic-number/discuss/2456725/Python-oror-Easy-Approach-oror-Hashmap,"class Solution:
    def largestPalindromic(self, num: str) -> str:

        ans = []
        b = [str(x) for x in range(9, -1, -1)]
        from collections import defaultdict

        a = defaultdict(int)

        for x in num:
            a[x] += 1

        for x in b:
            n = len(ans)
            if n % 2 == 0:
                if a[x] > 0:
                    ans = ans[:n // 2] + [x] * a[x] + ans[n // 2:]
            else:
                if x == '0':
                    if len(ans) != 1:
                        ans = ans[:n // 2] + [x] * (a[x] // 2) + [ans[n // 2]] + [x] * (a[x] // 2) + ans[n // 2 + 1:]
                else:
                    if a[x] >= 2:
                        ans = ans[:n // 2] + [x] * (a[x] // 2) + [ans[n // 2]] + [x] * (a[x] // 2) + ans[n // 2 + 1:]

        res = """".join(ans)
        return str(int(res))",chuhonghao01
2385,https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/discuss/2456656/Python3-bfs,"class Solution: 		
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.popleft()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans",ye15